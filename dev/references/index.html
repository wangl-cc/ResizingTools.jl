<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>References · ResizingTools.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ResizingTools.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../interfaces/">Resizing Interfaces</a></li><li class="is-active"><a class="tocitem" href>References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/wangl-cc/ResizingTools.jl/blob/master/docs/src/references.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ResizingTools.AbstractRDArray" href="#ResizingTools.AbstractRDArray"><code>ResizingTools.AbstractRDArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRDArray{T,N} &lt;: DenseArray{T,N}</code></pre><p><code>N</code>-dimensional resizable dense array with elements of type <code>T</code> with some pre-defined array methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wangl-cc/ResizingTools.jl/blob/70067368ac76b826cfce566d0550e6f90a6f6a15/src/type.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ResizingTools.SimpleRDArray" href="#ResizingTools.SimpleRDArray"><code>ResizingTools.SimpleRDArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleRDArray{T,N} &lt;: AbstractRDArray{T,N}</code></pre><p>A simple implementation of resizable dense array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wangl-cc/ResizingTools.jl/blob/70067368ac76b826cfce566d0550e6f90a6f6a15/src/type.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ResizingTools.Size" href="#ResizingTools.Size"><code>ResizingTools.Size</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Size{N}</code></pre><p>A mutable warpper of <code>NTuple{N,Int}</code> used to represent the dimension of an resizable array. Mutate &#39;i&#39;th dimension to <code>ndim</code> by <code>sz[i] = ndim</code> mutate the whole dimensions to <code>ndims</code> by <code>set!(sz, ndims)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wangl-cc/ResizingTools.jl/blob/70067368ac76b826cfce566d0550e6f90a6f6a15/src/utils.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.resize!-Tuple{AbstractArray, Any, Integer}" href="#Base.resize!-Tuple{AbstractArray, Any, Integer}"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.resize!(A::AbstractArray{T,N}, I, i::Integer)</code></pre><p>Resize the <code>i</code>th dimension to <code>I</code>, where <code>I</code> can be an integer or a colon or an iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wangl-cc/ResizingTools.jl/blob/70067368ac76b826cfce566d0550e6f90a6f6a15/src/methods.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.resize!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}}} where {T, N}" href="#Base.resize!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}}} where {T, N}"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.resize!(A::AbstractArray{T,N}, sz)</code></pre><p>Resize <code>A</code> to <code>sz</code>. <code>sz</code> can be a tuple of integer or Colon or iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wangl-cc/ResizingTools.jl/blob/70067368ac76b826cfce566d0550e6f90a6f6a15/src/methods.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ResizingTools.getsize-Tuple{AbstractArray, Integer}" href="#ResizingTools.getsize-Tuple{AbstractArray, Integer}"><code>ResizingTools.getsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getsize(A::AbstractArray, [dim])</code></pre><p>Return the dimensions of <code>A</code> unlike <code>size</code> which may not return a <code>NTuple{N,Int}</code>. For a <a href="#ResizingTools.AbstractRDArray"><code>AbstractRDArray</code></a>, <code>convert(Tuple, getsize(A))</code> is the default implementation of <code>size(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wangl-cc/ResizingTools.jl/blob/70067368ac76b826cfce566d0550e6f90a6f6a15/src/methods.jl#L36-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ResizingTools.isresizable-Tuple{AbstractArray}" href="#ResizingTools.isresizable-Tuple{AbstractArray}"><code>ResizingTools.isresizable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isresizable(A::AbstractArray)</code></pre><p>Check if the type of <code>A</code> is resizable.</p><p>!!! Note</p><pre><code class="nohighlight hljs">`isresizable(A)` for a `Vector` or a `BitVector` will return `false` even
which can be resized by `resize!(A, n)`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wangl-cc/ResizingTools.jl/blob/70067368ac76b826cfce566d0550e6f90a6f6a15/src/methods.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ResizingTools.mapindex-Tuple{AbstractArray, Tuple}" href="#ResizingTools.mapindex-Tuple{AbstractArray, Tuple}"><code>ResizingTools.mapindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapindex(A::AbstractArray, I::Tuple)
mapindex(A::AbstractArray, i::Integer, I)</code></pre><p>Map the index or indices <code>I</code> of <code>A</code> to index of <code>parent(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wangl-cc/ResizingTools.jl/blob/70067368ac76b826cfce566d0550e6f90a6f6a15/src/methods.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ResizingTools.setsize!-Tuple{AbstractArray, Integer, Integer}" href="#ResizingTools.setsize!-Tuple{AbstractArray, Integer, Integer}"><code>ResizingTools.setsize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setsize!(A::AbstractArray, d::Integer, i::Integer)</code></pre><p>Set the <code>i</code>th dimension to <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wangl-cc/ResizingTools.jl/blob/70067368ac76b826cfce566d0550e6f90a6f6a15/src/methods.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ResizingTools.setsize!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}}} where {T, N}" href="#ResizingTools.setsize!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}}} where {T, N}"><code>ResizingTools.setsize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setsize!(A::AbstractArray{T,N}, sz) where {T,N}</code></pre><p>Set the size of <code>A</code> to <code>sz</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/wangl-cc/ResizingTools.jl/blob/70067368ac76b826cfce566d0550e6f90a6f6a15/src/methods.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base" href="#Base"><code>Base</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Base</code></pre><p>The base library of Julia. <code>Base</code> is a module that contains basic functionality (the contents of <code>base/</code>). All modules implicitly contain <code>using Base</code>, since this is needed in the vast majority of cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/docs/basedocs.jl#L2535-L2539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ARGS" href="#Base.ARGS"><code>Base.ARGS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ARGS</code></pre><p>An array of the command line arguments passed to Julia, as strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/initdefs.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractVecOrMat" href="#Base.AbstractVecOrMat"><code>Base.AbstractVecOrMat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVecOrMat{T}</code></pre><p>Union type of <a href="#Base.AbstractVector"><code>AbstractVector{T}</code></a> and <a href="#Base.AbstractMatrix"><code>AbstractMatrix{T}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.C_NULL" href="#Base.C_NULL"><code>Base.C_NULL</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">C_NULL</code></pre><p>The C null pointer constant, sometimes used when calling external code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/pointer.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.DEPOT_PATH" href="#Base.DEPOT_PATH"><code>Base.DEPOT_PATH</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">DEPOT_PATH</code></pre><p>A stack of &quot;depot&quot; locations where the package manager, as well as Julia&#39;s code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:</p><ol><li><code>~/.julia</code> where <code>~</code> is the user home as appropriate on the system;</li><li>an architecture-specific shared system directory, e.g. <code>/usr/local/share/julia</code>;</li><li>an architecture-independent shared system directory, e.g. <code>/usr/share/julia</code>.</li></ol><p>So <code>DEPOT_PATH</code> might be:</p><pre><code class="language-julia hljs">[joinpath(homedir(), &quot;.julia&quot;), &quot;/usr/local/share/julia&quot;, &quot;/usr/share/julia&quot;]</code></pre><p>The first entry is the &quot;user depot&quot; and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.</p><p><code>DEPOT_PATH</code> is populated based on the <a href="@ref JULIA_DEPOT_PATH"><code>JULIA_DEPOT_PATH</code></a> environment variable if set.</p><p><strong>DEPOT_PATH contents</strong></p><p>Each entry in <code>DEPOT_PATH</code> is a path to a directory which contains subdirectories used by Julia for various purposes. Here is an overview of some of the subdirectories that may exist in a depot:</p><ul><li><code>clones</code>: Contains full clones of package repos. Maintained by <code>Pkg.jl</code> and used as a cache.</li><li><code>compiled</code>: Contains precompiled <code>*.ji</code> files for packages. Maintained by Julia.</li><li><code>dev</code>: Default directory for <code>Pkg.develop</code>. Maintained by <code>Pkg.jl</code> and the user.</li><li><code>environments</code>: Default package environments. For instance the global environment for a specific julia version. Maintained by <code>Pkg.jl</code>.</li><li><code>logs</code>: Contains logs of <code>Pkg</code> and <code>REPL</code> operations. Maintained by <code>Pkg.jl</code> and <code>Julia</code>.</li><li><code>packages</code>: Contains packages, some of which were explicitly installed and some which are implicit dependencies. Maintained by <code>Pkg.jl</code>.</li><li><code>registries</code>: Contains package registries. By default only <code>General</code>. Maintained by <code>Pkg.jl</code>.</li></ul><p>See also: <a href="@ref JULIA_DEPOT_PATH"><code>JULIA_DEPOT_PATH</code></a>, and <a href="@ref code-loading">Code Loading</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/initdefs.jl#L44-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.DenseVecOrMat" href="#Base.DenseVecOrMat"><code>Base.DenseVecOrMat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DenseVecOrMat{T}</code></pre><p>Union type of <a href="#Base.DenseVector"><code>DenseVector{T}</code></a> and <a href="#Base.DenseMatrix"><code>DenseMatrix{T}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ENDIAN_BOM" href="#Base.ENDIAN_BOM"><code>Base.ENDIAN_BOM</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ENDIAN_BOM</code></pre><p>The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value <code>0x04030201</code>. Big-endian machines will contain the value <code>0x01020304</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L575-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ENV" href="#Base.ENV"><code>Base.ENV</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">ENV</code></pre><p>Reference to the singleton <code>EnvDict</code>, providing a dictionary interface to system environment variables.</p><p>(On Windows, system environment variables are case-insensitive, and <code>ENV</code> correspondingly converts all keys to uppercase for display, iteration, and copying. Portable code should not rely on the ability to distinguish variables by case, and should beware that setting an ostensibly lowercase variable may result in an uppercase <code>ENV</code> key.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/env.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Inf" href="#Base.Inf"><code>Base.Inf</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Inf, Inf64</code></pre><p>Positive infinity of type <a href="@ref"><code>Float64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Inf16" href="#Base.Inf16"><code>Base.Inf16</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Inf16</code></pre><p>Positive infinity of type <a href="@ref"><code>Float16</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Inf32" href="#Base.Inf32"><code>Base.Inf32</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Inf32</code></pre><p>Positive infinity of type <a href="@ref"><code>Float32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Inf64" href="#Base.Inf64"><code>Base.Inf64</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">Inf, Inf64</code></pre><p>Positive infinity of type <a href="@ref"><code>Float64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.LOAD_PATH" href="#Base.LOAD_PATH"><code>Base.LOAD_PATH</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">LOAD_PATH</code></pre><p>An array of paths for <code>using</code> and <code>import</code> statements to consider as project environments or package directories when loading code. It is populated based on the <a href="@ref JULIA_LOAD_PATH"><code>JULIA_LOAD_PATH</code></a> environment variable if set; otherwise it defaults to <code>[&quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]</code>. Entries starting with <code>@</code> have special meanings:</p><ul><li><p><code>@</code> refers to the &quot;current active environment&quot;, the initial value of which is initially determined by the <a href="@ref JULIA_PROJECT"><code>JULIA_PROJECT</code></a> environment variable or the <code>--project</code> command-line option.</p></li><li><p><code>@stdlib</code> expands to the absolute path of the current Julia installation&#39;s standard library directory.</p></li><li><p><code>@name</code> refers to a named environment, which are stored in depots (see <a href="@ref JULIA_DEPOT_PATH"><code>JULIA_DEPOT_PATH</code></a>) under the <code>environments</code> subdirectory. The user&#39;s named environments are stored in <code>~/.julia/environments</code> so <code>@name</code> would refer to the environment in <code>~/.julia/environments/name</code> if it exists and contains a <code>Project.toml</code> file. If <code>name</code> contains <code>#</code> characters, then they are replaced with the major, minor and patch components of the Julia version number. For example, if you are running Julia 1.2 then <code>@v#.#</code> expands to <code>@v1.2</code> and will look for an environment by that name, typically at <code>~/.julia/environments/v1.2</code>.</p></li></ul><p>The fully expanded value of <code>LOAD_PATH</code> that is searched for projects and packages can be seen by calling the <code>Base.load_path()</code> function.</p><p>See also: <a href="@ref JULIA_LOAD_PATH"><code>JULIA_LOAD_PATH</code></a>, <a href="@ref JULIA_PROJECT"><code>JULIA_PROJECT</code></a>, <a href="@ref JULIA_DEPOT_PATH"><code>JULIA_DEPOT_PATH</code></a>, and <a href="@ref code-loading">Code Loading</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/initdefs.jl#L135-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.NaN" href="#Base.NaN"><code>Base.NaN</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">NaN, NaN64</code></pre><p>A not-a-number value of type <a href="@ref"><code>Float64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.NaN16" href="#Base.NaN16"><code>Base.NaN16</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">NaN16</code></pre><p>A not-a-number value of type <a href="@ref"><code>Float16</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.NaN32" href="#Base.NaN32"><code>Base.NaN32</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">NaN32</code></pre><p>A not-a-number value of type <a href="@ref"><code>Float32</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.NaN64" href="#Base.NaN64"><code>Base.NaN64</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">NaN, NaN64</code></pre><p>A not-a-number value of type <a href="@ref"><code>Float64</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.PROGRAM_FILE" href="#Base.PROGRAM_FILE"><code>Base.PROGRAM_FILE</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">PROGRAM_FILE</code></pre><p>A string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see <a href="#Base.@__FILE__-Tuple{}"><code>@__FILE__</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/initdefs.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.VERSION" href="#Base.VERSION"><code>Base.VERSION</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">VERSION</code></pre><p>A <code>VersionNumber</code> object describing which version of Julia is in use. For details see <a href="@ref man-version-number-literals">Version Number Literals</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/version.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.VecOrMat" href="#Base.VecOrMat"><code>Base.VecOrMat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VecOrMat{T}</code></pre><p>Union type of <a href="#Base.Vector"><code>Vector{T}</code></a> and <a href="#Base.Matrix"><code>Matrix{T}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.im" href="#Base.im"><code>Base.im</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">im</code></pre><p>The imaginary unit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; im * im
-1 + 0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.missing" href="#Base.missing"><code>Base.missing</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">missing</code></pre><p>The singleton instance of type <a href="#Base.Missing"><code>Missing</code></a> representing a missing value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L802-L806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.stderr" href="#Base.stderr"><code>Base.stderr</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">stderr</code></pre><p>Global variable referring to the standard error stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/libuv.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.stdin" href="#Base.stdin"><code>Base.stdin</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">stdin</code></pre><p>Global variable referring to the standard input stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/libuv.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.stdout" href="#Base.stdout"><code>Base.stdout</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">stdout</code></pre><p>Global variable referring to the standard out stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/libuv.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.text_colors" href="#Base.text_colors"><code>Base.text_colors</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Dictionary of color codes for the terminal.</p><p>Available colors are: <code>:normal</code>, <code>:default</code>, <code>:bold</code>, <code>:black</code>, <code>:blink</code>, <code>:blue</code>, <code>:cyan</code>, <code>:green</code>, <code>:hidden</code>, <code>:light_black</code>, <code>:light_blue</code>, <code>:light_cyan</code>, <code>:light_green</code>, <code>:light_magenta</code>, <code>:light_red</code>, <code>:light_yellow</code>, <code>:magenta</code>, <code>:nothing</code>, <code>:red</code>, <code>:reverse</code>, <code>:underline</code>, <code>:white</code>, or  <code>:yellow</code> as well as the integers 0 to 255 inclusive.</p><p>The color <code>:default</code> will print text in the default color while the color <code>:normal</code> will print text with all text properties (like boldness) reset. Printing with the color <code>:nothing</code> will print the string without modifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/util.jl#L60-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:=&gt;" href="#Base.:=&gt;"><code>Base.:=&gt;</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pair(x, y)
x =&gt; y</code></pre><p>Construct a <code>Pair</code> object with type <code>Pair{typeof(x), typeof(y)}</code>. The elements are stored in the fields <code>first</code> and <code>second</code>. They can also be accessed via iteration (but a <code>Pair</code> is treated as a single &quot;scalar&quot; for broadcasting operations).</p><p>See also: <a href="#Base.Dict"><code>Dict</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = &quot;foo&quot; =&gt; 7
&quot;foo&quot; =&gt; 7

julia&gt; typeof(p)
Pair{String, Int64}

julia&gt; p.first
&quot;foo&quot;

julia&gt; for x in p
           println(x)
       end
foo
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/pair.jl#L18-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractChannel" href="#Base.AbstractChannel"><code>Base.AbstractChannel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractChannel{T}</code></pre><p>Representation of a channel passing objects of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/channels.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractDict" href="#Base.AbstractDict"><code>Base.AbstractDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDict{K, V}</code></pre><p>Supertype for dictionary-like types with keys of type <code>K</code> and values of type <code>V</code>. <a href="#Base.Dict"><code>Dict</code></a>, <a href="#Base.IdDict"><code>IdDict</code></a> and other types are subtypes of this. An <code>AbstractDict{K, V}</code> should be an iterator of <code>Pair{K, V}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractIrrational" href="#Base.AbstractIrrational"><code>Base.AbstractIrrational</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractIrrational &lt;: Real</code></pre><p>Number type representing an exact irrational value, which is automatically rounded to the correct precision in arithmetic operations with other numeric quantities.</p><p>Subtypes <code>MyIrrational &lt;: AbstractIrrational</code> should implement at least <code>==(::MyIrrational, ::MyIrrational)</code>, <code>hash(x::MyIrrational, h::UInt)</code>, and <code>convert(::Type{F}, x::MyIrrational) where {F &lt;: Union{BigFloat,Float32,Float64}}</code>.</p><p>If a subtype is used to represent values that may occasionally be rational (e.g. a square-root type that represents <code>√n</code> for integers <code>n</code> will give a rational result when <code>n</code> is a perfect square), then it should also implement <code>isinteger</code>, <code>iszero</code>, <code>isone</code>, and <code>==</code> with <code>Real</code> values (since all of these default to <code>false</code> for <code>AbstractIrrational</code> types), as well as defining <a href="#Base.hash-Tuple{Any}"><code>hash</code></a> to equal that of the corresponding <code>Rational</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/irrationals.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractLock" href="#Base.AbstractLock"><code>Base.AbstractLock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLock</code></pre><p>Abstract supertype describing types that implement the synchronization primitives: <a href="#Base.lock-Tuple{Any, Base.AbstractLock}"><code>lock</code></a>, <a href="#Base.trylock-Tuple{ReentrantLock}"><code>trylock</code></a>, <a href="#Base.unlock-Tuple{ReentrantLock}"><code>unlock</code></a>, and <a href="#Base.islocked-Tuple{ReentrantLock}"><code>islocked</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/condition.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractMatch" href="#Base.AbstractMatch"><code>Base.AbstractMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AbstractMatch</code> objects are used to represent information about matches found in a string    using an <code>AbstractPattern</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L139-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractMatrix" href="#Base.AbstractMatrix"><code>Base.AbstractMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMatrix{T}</code></pre><p>Supertype for two-dimensional arrays (or array-like types) with elements of type <code>T</code>. Alias for <a href="#Core.AbstractArray"><code>AbstractArray{T,2}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractPattern" href="#Base.AbstractPattern"><code>Base.AbstractPattern</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">An abstract type representing any sort of pattern matching expression (typically a regular
expression).
`AbstractPattern` objects can be used to match strings with [`match`](@ref).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractPipe" href="#Base.AbstractPipe"><code>Base.AbstractPipe</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPipe</code></pre><p><code>AbstractPipe</code> is the abstract supertype for IO pipes that provide for communication between processes.</p><p>If <code>pipe isa AbstractPipe</code>, it must obey the following interface:</p><ul><li><code>pipe.in</code> or <code>pipe.in_stream</code>, if present, must be of type <code>IO</code> and be used to provide input to the pipe</li><li><code>pipe.out</code> or <code>pipe.out_stream</code>, if present, must be of type <code>IO</code> and be used for output from the pipe</li><li><code>pipe.err</code> or <code>pipe.err_stream</code>, if present, must be of type <code>IO</code> and be used for writing errors from the pipe</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L336-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractRange" href="#Base.AbstractRange"><code>Base.AbstractRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractRange{T}</code></pre><p>Supertype for ranges with elements of type <code>T</code>. <a href="#Base.UnitRange"><code>UnitRange</code></a> and other types are subtypes of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractSet" href="#Base.AbstractSet"><code>Base.AbstractSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSet{T}</code></pre><p>Supertype for set-like types whose elements are of type <code>T</code>. <a href="#Base.Set-Tuple{Any}"><code>Set</code></a>, <a href="#Base.BitSet-Tuple{Any}"><code>BitSet</code></a> and other types are subtypes of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractUnitRange" href="#Base.AbstractUnitRange"><code>Base.AbstractUnitRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractUnitRange{T} &lt;: OrdinalRange{T, T}</code></pre><p>Supertype for ranges with a step size of <a href="#Base.oneunit-Tuple{T} where T"><code>oneunit(T)</code></a> with elements of type <code>T</code>. <a href="#Base.UnitRange"><code>UnitRange</code></a> and other types are subtypes of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractVector" href="#Base.AbstractVector"><code>Base.AbstractVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVector{T}</code></pre><p>Supertype for one-dimensional arrays (or array-like types) with elements of type <code>T</code>. Alias for <a href="#Core.AbstractArray"><code>AbstractArray{T,1}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AlwaysLockedST" href="#Base.AlwaysLockedST"><code>Base.AlwaysLockedST</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AlwaysLockedST</code></pre><p>This struct does not implement a real lock, but instead pretends to be always locked on the original thread it was allocated on, and simply ignores all other interactions. It also does not synchronize tasks; for that use a real lock such as <a href="@ref"><code>RecursiveLock</code></a>. This can be used in the place of a real lock to, instead, simply and cheaply assert that the operation is only occurring on a single cooperatively-scheduled thread. It is thus functionally equivalent to allocating a real, recursive, task-unaware lock immediately calling <code>lock</code> on it, and then never calling a matching <code>unlock</code>, except that calling <code>lock</code> from another thread will throw a concurrency violation exception.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/condition.jl#L31-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AsyncCollector-Tuple{Any, Any, Vararg{Any, N} where N}" href="#Base.AsyncCollector-Tuple{Any, Any, Vararg{Any, N} where N}"><code>Base.AsyncCollector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AsyncCollector(f, results, c...; ntasks=0, batch_size=nothing) -&gt; iterator</code></pre><p>Return an iterator which applies <code>f</code> to each element of <code>c</code> asynchronously and collects output into <code>results</code>.</p><p>Keyword args <code>ntasks</code> and <code>batch_size</code> have the same behavior as in <a href="#Base.asyncmap-Tuple{Any, Vararg{Any, N} where N}"><code>asyncmap</code></a>. If <code>batch_size</code> is specified, <code>f</code> must be a function which operates on an array of argument tuples.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>iterate(::AsyncCollector, state) -&gt; (nothing, state)</code>. A successful return from <code>iterate</code> indicates that the next element from the input collection is being processed asynchronously. It blocks until a free worker task becomes available.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>for _ in AsyncCollector(f, results, c...; ntasks=1) end</code> is equivalent to <code>map!(f, results, c...)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/asyncmap.jl#L273-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AsyncCondition" href="#Base.AsyncCondition"><code>Base.AsyncCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AsyncCondition()</code></pre><p>Create a async condition that wakes up tasks waiting for it (by calling <a href="#Base.wait-Tuple{Base.GenericCondition}"><code>wait</code></a> on the object) when notified from C by a call to <code>uv_async_send</code>. Waiting tasks are woken with an error when the object is closed (by <a href="#Base.close"><code>close</code></a>). Use <a href="#Base.isopen"><code>isopen</code></a> to check whether it is still active.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/asyncevent.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AsyncCondition-Tuple{Function}" href="#Base.AsyncCondition-Tuple{Function}"><code>Base.AsyncCondition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AsyncCondition(callback::Function)</code></pre><p>Create a async condition that calls the given <code>callback</code> function. The <code>callback</code> is passed one argument, the async condition object itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/asyncevent.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AsyncGenerator" href="#Base.AsyncGenerator"><code>Base.AsyncGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AsyncGenerator(f, c...; ntasks=0, batch_size=nothing) -&gt; iterator</code></pre><p>Apply <code>f</code> to each element of <code>c</code> using at most <code>ntasks</code> asynchronous tasks.</p><p>Keyword args <code>ntasks</code> and <code>batch_size</code> have the same behavior as in <a href="#Base.asyncmap-Tuple{Any, Vararg{Any, N} where N}"><code>asyncmap</code></a>. If <code>batch_size</code> is specified, <code>f</code> must be a function which operates on an array of argument tuples.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>collect(AsyncGenerator(f, c...; ntasks=1))</code> is equivalent to <code>map(f, c...)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/asyncmap.jl#L353-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.BitArray" href="#Base.BitArray"><code>Base.BitArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BitArray{N} &lt;: AbstractArray{Bool, N}</code></pre><p>Space-efficient <code>N</code>-dimensional boolean array, using just one bit for each boolean value.</p><p><code>BitArray</code>s pack up to 64 values into every 8 bytes, resulting in an 8x space efficiency over <code>Array{Bool, N}</code> and allowing some operations to work on 64 values at once.</p><p>By default, Julia returns <code>BitArrays</code> from <a href="@ref Broadcasting">broadcasting</a> operations that generate boolean elements (including dotted-comparisons like <code>.==</code>) as well as from the functions <a href="#Base.trues-Tuple{Vararg{Union{Integer, AbstractUnitRange}, N} where N}"><code>trues</code></a> and <a href="#Base.falses-Tuple{Vararg{Union{Integer, AbstractUnitRange}, N} where N}"><code>falses</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Due to its packed storage format, concurrent access to the elements of a <code>BitArray</code> where at least one of them is a write is not thread safe.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bitarray.jl#L7-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.BitArray-Tuple{Any}" href="#Base.BitArray-Tuple{Any}"><code>Base.BitArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BitArray(itr)</code></pre><p>Construct a <a href="#Base.BitArray"><code>BitArray</code></a> generated by the given iterable object. The shape is inferred from the <code>itr</code> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BitArray([1 0; 0 1])
2×2 BitMatrix:
 1  0
 0  1

julia&gt; BitArray(x+y == 3 for x = 1:2, y = 1:3)
2×3 BitMatrix:
 0  1  0
 1  0  0

julia&gt; BitArray(x+y == 3 for x = 1:2 for y = 1:3)
6-element BitVector:
 0
 1
 0
 1
 0
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bitarray.jl#L546-L573">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.BitArray-Tuple{UndefInitializer, Vararg{Integer, N} where N}" href="#Base.BitArray-Tuple{UndefInitializer, Vararg{Integer, N} where N}"><code>Base.BitArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BitArray(undef, dims::Integer...)
BitArray{N}(undef, dims::NTuple{N,Int})</code></pre><p>Construct an undef <a href="#Base.BitArray"><code>BitArray</code></a> with the given dimensions. Behaves identically to the <a href="#Core.Array"><code>Array</code></a> constructor. See <a href="@ref"><code>undef</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; BitArray(undef, 2, 2)
2×2 BitMatrix:
 0  0
 0  0

julia&gt; BitArray(undef, (3, 1))
3×1 BitMatrix:
 0
 0
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bitarray.jl#L48-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.BitSet-Tuple{Any}" href="#Base.BitSet-Tuple{Any}"><code>Base.BitSet</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BitSet([itr])</code></pre><p>Construct a sorted set of <code>Int</code>s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use <a href="#Base.Set-Tuple{Any}"><code>Set</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bitset.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.BitVector-Tuple{Tuple{Vararg{Bool, N} where N}}" href="#Base.BitVector-Tuple{Tuple{Vararg{Bool, N} where N}}"><code>Base.BitVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BitVector(nt::Tuple{Vararg{Bool}})</code></pre><p>Construct a <code>BitVector</code> from a tuple of <code>Bool</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nt = (true, false, true, false)
(true, false, true, false)

julia&gt; BitVector(nt)
4-element BitVector:
 1
 0
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bitarray.jl#L79-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.BottomRF" href="#Base.BottomRF"><code>Base.BottomRF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BottomRF(rf) -&gt; rf′</code></pre><p>&quot;Bottom&quot; reducing function.  This is a thin wrapper around the <code>op</code> argument passed to <code>foldl</code>-like functions for handling the initial invocation to call <a href="#Base.reduce_first-Tuple{Any, Any}"><code>reduce_first</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.CFunction" href="#Base.CFunction"><code>Base.CFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CFunction struct</code></pre><p>Garbage-collection handle for the return value from <code>@cfunction</code> when the first argument is annotated with &#39;<span>$</span>&#39;. Like all <code>cfunction</code> handles, it should be passed to <code>ccall</code> as a <code>Ptr{Cvoid}</code>, and will be converted automatically at the call site to the appropriate type.</p><p>See <a href="#Base.@cfunction-Tuple{Any, Any, Any}"><code>@cfunction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cchar" href="#Base.Cchar"><code>Base.Cchar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cchar</code></pre><p>Equivalent to the native <code>char</code> c-type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cdouble" href="#Base.Cdouble"><code>Base.Cdouble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cdouble</code></pre><p>Equivalent to the native <code>double</code> c-type (<a href="@ref"><code>Float64</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cfloat" href="#Base.Cfloat"><code>Base.Cfloat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cfloat</code></pre><p>Equivalent to the native <code>float</code> c-type (<a href="@ref"><code>Float32</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Channel" href="#Base.Channel"><code>Base.Channel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Channel{T=Any}(size::Int=0)</code></pre><p>Constructs a <code>Channel</code> with an internal buffer that can hold a maximum of <code>size</code> objects of type <code>T</code>. <a href="#Base.put!-Union{Tuple{T}, Tuple{Channel{T}, Any}} where T"><code>put!</code></a> calls on a full channel block until an object is removed with <a href="#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a>.</p><p><code>Channel(0)</code> constructs an unbuffered channel. <code>put!</code> blocks until a matching <code>take!</code> is called. And vice-versa.</p><p>Other constructors:</p><ul><li><code>Channel()</code>: default constructor, equivalent to <code>Channel{Any}(0)</code></li><li><code>Channel(Inf)</code>: equivalent to <code>Channel{Any}(typemax(Int))</code></li><li><code>Channel(sz)</code>: equivalent to <code>Channel{Any}(sz)</code></li></ul><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>The default constructor <code>Channel()</code> and default <code>size=0</code> were added in Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/channels.jl#L13-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Channel-Union{Tuple{Function}, Tuple{T}, Tuple{Function, Any}} where T" href="#Base.Channel-Union{Tuple{Function}, Tuple{T}, Tuple{Function, Any}} where T"><code>Base.Channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Channel{T=Any}(func::Function, size=0; taskref=nothing, spawn=false)</code></pre><p>Create a new task from <code>func</code>, bind it to a new channel of type <code>T</code> and size <code>size</code>, and schedule the task, all in a single call.</p><p><code>func</code> must accept the bound channel as its only argument.</p><p>If you need a reference to the created task, pass a <code>Ref{Task}</code> object via the keyword argument <code>taskref</code>.</p><p>If <code>spawn = true</code>, the Task created for <code>func</code> may be scheduled on another thread in parallel, equivalent to creating a task via <a href="@ref"><code>Threads.@spawn</code></a>.</p><p>Return a <code>Channel</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chnl = Channel() do ch
           foreach(i -&gt; put!(ch, i), 1:4)
       end;

julia&gt; typeof(chnl)
Channel{Any}

julia&gt; for i in chnl
           @show i
       end;
i = 1
i = 2
i = 3
i = 4</code></pre><p>Referencing the created task:</p><pre><code class="language-julia-repl hljs">julia&gt; taskref = Ref{Task}();

julia&gt; chnl = Channel(taskref=taskref) do ch
           println(take!(ch))
       end;

julia&gt; istaskdone(taskref[])
false

julia&gt; put!(chnl, &quot;Hello&quot;);
Hello

julia&gt; istaskdone(taskref[])
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>The <code>spawn=</code> parameter was added in Julia 1.3. This constructor was added in Julia 1.3. In earlier versions of Julia, Channel used keyword arguments to set <code>size</code> and <code>T</code>, but those constructors are deprecated.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; chnl = Channel{Char}(1, spawn=true) do ch
           for c in &quot;hello world&quot;
               put!(ch, c)
           end
       end
Channel{Char}(1) (1 item available)

julia&gt; String(collect(chnl))
&quot;hello world&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/channels.jl#L60-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cint" href="#Base.Cint"><code>Base.Cint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cint</code></pre><p>Equivalent to the native <code>signed int</code> c-type (<a href="@ref"><code>Int32</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cintmax_t" href="#Base.Cintmax_t"><code>Base.Cintmax_t</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cintmax_t</code></pre><p>Equivalent to the native <code>intmax_t</code> c-type (<a href="@ref"><code>Int64</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Clong" href="#Base.Clong"><code>Base.Clong</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Clong</code></pre><p>Equivalent to the native <code>signed long</code> c-type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Clonglong" href="#Base.Clonglong"><code>Base.Clonglong</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Clonglong</code></pre><p>Equivalent to the native <code>signed long long</code> c-type (<a href="@ref"><code>Int64</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cmd" href="#Base.Cmd"><code>Base.Cmd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)</code></pre><p>Construct a new <code>Cmd</code> object, representing an external program and arguments, from <code>cmd</code>, while changing the settings of the optional keyword arguments:</p><ul><li><code>ignorestatus::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then the <code>Cmd</code> will not throw an error if the return code is nonzero.</li><li><code>detach::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then the <code>Cmd</code> will be run in a new process group, allowing it to outlive the <code>julia</code> process and not have Ctrl-C passed to it.</li><li><code>windows_verbatim::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then on Windows the <code>Cmd</code> will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single &quot;command-line&quot; string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes <code>&quot;</code> in the command line, and <code>\</code> or <code>&quot;</code> are preceded by backslashes. <code>windows_verbatim=true</code> is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.</li><li><code>windows_hide::Bool</code>: If <code>true</code> (defaults to <code>false</code>), then on Windows no new console window is displayed when the <code>Cmd</code> is executed. This has no effect if a console is already open or on non-Windows systems.</li><li><code>env</code>: Set environment variables to use when running the <code>Cmd</code>. <code>env</code> is either a dictionary mapping strings to strings, an array of strings of the form <code>&quot;var=val&quot;</code>, an array or tuple of <code>&quot;var&quot;=&gt;val</code> pairs. In order to modify (rather than replace) the existing environment, initialize <code>env</code> with <code>copy(ENV)</code> and then set <code>env[&quot;var&quot;]=val</code> as desired.  To add to an environment block within a <code>Cmd</code> object without replacing all elements, use <code>addenv()</code> which will return a <code>Cmd</code> object with the updated environment.</li><li><code>dir::AbstractString</code>: Specify a working directory for the command (instead of the current directory).</li></ul><p>For any keywords that are not specified, the current settings from <code>cmd</code> are used. Normally, to create a <code>Cmd</code> object in the first place, one uses backticks, e.g.</p><pre><code class="nohighlight hljs">Cmd(`echo &quot;Hello world&quot;`, ignorestatus=true, detach=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/cmd.jl#L39-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.CodeUnits" href="#Base.CodeUnits"><code>Base.CodeUnits</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CodeUnits(s::AbstractString)</code></pre><p>Wrap a string (without copying) in an immutable vector-like object that accesses the code units of the string&#39;s representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L726-L731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Colon" href="#Base.Colon"><code>Base.Colon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Colon()</code></pre><p>Colons (:) are used to signify indexing entire objects or dimensions at once.</p><p>Very few operations are defined on Colons directly; instead they are converted by <a href="#Base.to_indices-Tuple{Any, Tuple}"><code>to_indices</code></a> to an internal vector type (<code>Base.Slice</code>) to represent the collection of indices they span before being used.</p><p>The singleton instance of <code>Colon</code> is also a function used to construct ranges; see <a href="#Base.::-Union{Tuple{T}, Tuple{T, Any, T}} where T"><code>:</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L654-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Complex" href="#Base.Complex"><code>Base.Complex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Complex{T&lt;:Real} &lt;: Number</code></pre><p>Complex number type with real and imaginary part of type <code>T</code>.</p><p><code>ComplexF16</code>, <code>ComplexF32</code> and <code>ComplexF64</code> are aliases for <code>Complex{Float16}</code>, <code>Complex{Float32}</code> and <code>Complex{Float64}</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ComposedFunction" href="#Base.ComposedFunction"><code>Base.ComposedFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComposedFunction{Outer,Inner} &lt;: Function</code></pre><p>Represents the composition of two callable objects <code>outer::Outer</code> and <code>inner::Inner</code>. That is</p><pre><code class="language-julia hljs">ComposedFunction(outer, inner)(args...; kw...) === outer(inner(args...; kw...))</code></pre><p>The preferred way to construct instance of <code>ComposedFunction</code> is to use the composition operator <a href="#Base.:∘"><code>∘</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; sin ∘ cos === ComposedFunction(sin, cos)
true

julia&gt; typeof(sin∘cos)
ComposedFunction{typeof(sin), typeof(cos)}</code></pre><p>The composed pieces are stored in the fields of <code>ComposedFunction</code> and can be retrieved as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; composition = sin ∘ cos
sin ∘ cos

julia&gt; composition.outer === sin
true

julia&gt; composition.inner === cos
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>ComposedFunction requires at least Julia 1.6. In earlier versions <code>∘</code> returns an anonymous function instead.</p></div></div><p>See also <a href="#Base.:∘"><code>∘</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L900-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.CompositeException" href="#Base.CompositeException"><code>Base.CompositeException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeException</code></pre><p>Wrap a <code>Vector</code> of exceptions thrown by a <a href="@ref"><code>Task</code></a> (e.g. generated from a remote worker over a channel or an asynchronously executing local I/O write or a remote worker under <code>pmap</code>) with information about the series of exceptions. For example, if a group of workers are executing several tasks, and multiple workers fail, the resulting <code>CompositeException</code> will contain a &quot;bundle&quot; of information from each worker indicating where and why the exception(s) occurred.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Condition" href="#Base.Condition"><code>Base.Condition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Condition()</code></pre><p>Create an edge-triggered event source that tasks can wait for. Tasks that call <a href="#Base.wait-Tuple{Base.GenericCondition}"><code>wait</code></a> on a <code>Condition</code> are suspended and queued. Tasks are woken up when <a href="#Base.notify-Tuple{Base.GenericCondition, Any}"><code>notify</code></a> is later called on the <code>Condition</code>. Edge triggering means that only tasks waiting at the time <a href="#Base.notify-Tuple{Base.GenericCondition, Any}"><code>notify</code></a> is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The <a href="#Base.Channel"><code>Channel</code></a> and <a href="#Base.Event"><code>Threads.Event</code></a> types do this, and can be used for level-triggered events.</p><p>This object is NOT thread-safe. See <a href="@ref"><code>Threads.Condition</code></a> for a thread-safe version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/condition.jl#L151-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cptrdiff_t" href="#Base.Cptrdiff_t"><code>Base.Cptrdiff_t</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cptrdiff_t</code></pre><p>Equivalent to the native <code>ptrdiff_t</code> c-type (<code>Int</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cshort" href="#Base.Cshort"><code>Base.Cshort</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cshort</code></pre><p>Equivalent to the native <code>signed short</code> c-type (<a href="@ref"><code>Int16</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Csize_t" href="#Base.Csize_t"><code>Base.Csize_t</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Csize_t</code></pre><p>Equivalent to the native <code>size_t</code> c-type (<code>UInt</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cssize_t" href="#Base.Cssize_t"><code>Base.Cssize_t</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cssize_t</code></pre><p>Equivalent to the native <code>ssize_t</code> c-type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cstring" href="#Base.Cstring"><code>Base.Cstring</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cstring</code></pre><p>A C-style string composed of the native character type <a href="#Base.Cchar"><code>Cchar</code></a>s. <code>Cstring</code>s are NUL-terminated. For C-style strings composed of the native wide character type, see <a href="#Base.Cwstring"><code>Cwstring</code></a>. For more information about string interopability with C, see the <a href="@ref man-bits-types">manual</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L138-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cuchar" href="#Base.Cuchar"><code>Base.Cuchar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cuchar</code></pre><p>Equivalent to the native <code>unsigned char</code> c-type (<a href="@ref"><code>UInt8</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cuint" href="#Base.Cuint"><code>Base.Cuint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cuint</code></pre><p>Equivalent to the native <code>unsigned int</code> c-type (<a href="@ref"><code>UInt32</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cuintmax_t" href="#Base.Cuintmax_t"><code>Base.Cuintmax_t</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cuintmax_t</code></pre><p>Equivalent to the native <code>uintmax_t</code> c-type (<a href="@ref"><code>UInt64</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Culong" href="#Base.Culong"><code>Base.Culong</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Culong</code></pre><p>Equivalent to the native <code>unsigned long</code> c-type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Culonglong" href="#Base.Culonglong"><code>Base.Culonglong</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Culonglong</code></pre><p>Equivalent to the native <code>unsigned long long</code> c-type (<a href="@ref"><code>UInt64</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cushort" href="#Base.Cushort"><code>Base.Cushort</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cushort</code></pre><p>Equivalent to the native <code>unsigned short</code> c-type (<a href="@ref"><code>UInt16</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ctypes.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cwchar_t" href="#Base.Cwchar_t"><code>Base.Cwchar_t</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cwchar_t</code></pre><p>Equivalent to the native <code>wchar_t</code> c-type (<a href="@ref"><code>Int32</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cwstring" href="#Base.Cwstring"><code>Base.Cwstring</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cwstring</code></pre><p>A C-style string composed of the native wide character type <a href="#Base.Cwchar_t"><code>Cwchar_t</code></a>s. <code>Cwstring</code>s are NUL-terminated. For C-style strings composed of the native character type, see <a href="#Base.Cstring"><code>Cstring</code></a>. For more information about string interopability with C, see the <a href="@ref man-bits-types">manual</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L125-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.CyclePadding" href="#Base.CyclePadding"><code>Base.CyclePadding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CyclePadding(padding, total_size)</code></pre><p>Cylces an iterator of <code>Padding</code> structs, restarting the padding at <code>total_size</code>. E.g. if <code>padding</code> is all the padding in a struct and <code>total_size</code> is the total aligned size of that array, <code>CyclePadding</code> will correspond to the padding in an infinite vector of such structs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reinterpretarray.jl#L596-L603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.DenseMatrix" href="#Base.DenseMatrix"><code>Base.DenseMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DenseMatrix{T}</code></pre><p>Two-dimensional <a href="#Core.DenseArray"><code>DenseArray</code></a> with elements of type <code>T</code>. Alias for <code>DenseArray{T,2}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.DenseVector" href="#Base.DenseVector"><code>Base.DenseVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DenseVector{T}</code></pre><p>One-dimensional <a href="#Core.DenseArray"><code>DenseArray</code></a> with elements of type <code>T</code>. Alias for <code>DenseArray{T,1}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Dict" href="#Base.Dict"><code>Base.Dict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dict([itr])</code></pre><p><code>Dict{K,V}()</code> constructs a hash table with keys of type <code>K</code> and values of type <code>V</code>. Keys are compared with <a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a> and hashed with <a href="#Base.hash-Tuple{Any}"><code>hash</code></a>.</p><p>Given a single iterable argument, constructs a <a href="#Base.Dict"><code>Dict</code></a> whose key-value pairs are taken from 2-tuples <code>(key,value)</code> generated by the argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Dict([(&quot;A&quot;, 1), (&quot;B&quot;, 2)])
Dict{String, Int64} with 2 entries:
  &quot;B&quot; =&gt; 2
  &quot;A&quot; =&gt; 1</code></pre><p>Alternatively, a sequence of pair arguments may be passed.</p><pre><code class="language-julia-repl hljs">julia&gt; Dict(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)
Dict{String, Int64} with 2 entries:
  &quot;B&quot; =&gt; 2
  &quot;A&quot; =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L52-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.DimensionMismatch" href="#Base.DimensionMismatch"><code>Base.DimensionMismatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DimensionMismatch([msg])</code></pre><p>The objects called do not have matching dimensionality. Optional argument <code>msg</code> is a descriptive error string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Dims" href="#Base.Dims"><code>Base.Dims</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dims{N}</code></pre><p>An <code>NTuple</code> of <code>N</code> <code>Int</code>s used to represent the dimensions of an <a href="#Core.AbstractArray"><code>AbstractArray</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.EOFError" href="#Base.EOFError"><code>Base.EOFError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EOFError()</code></pre><p>No more data was available to read from a file or stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.EnvDict" href="#Base.EnvDict"><code>Base.EnvDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EnvDict() -&gt; EnvDict</code></pre><p>A singleton of this type provides a hash table interface to environment variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/env.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Event" href="#Base.Event"><code>Base.Event</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Event()</code></pre><p>Create a level-triggered event source. Tasks that call <a href="#Base.wait-Tuple{Base.GenericCondition}"><code>wait</code></a> on an <code>Event</code> are suspended and queued until <code>notify</code> is called on the <code>Event</code>. After <code>notify</code> is called, the <code>Event</code> remains in a signaled state and tasks will no longer block when waiting for it.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This functionality requires at least Julia 1.1.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/lock.jl#L318-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ExponentialBackOff-Tuple{}" href="#Base.ExponentialBackOff-Tuple{}"><code>Base.ExponentialBackOff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)</code></pre><p>A <a href="@ref"><code>Float64</code></a> iterator of length <code>n</code> whose elements exponentially increase at a rate in the interval <code>factor</code> * (1 ± <code>jitter</code>).  The first element is <code>first_delay</code> and all elements are clamped to <code>max_delay</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L243-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.FilteringRF" href="#Base.FilteringRF"><code>Base.FilteringRF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FilteringRF(f, rf) -&gt; rf′</code></pre><p>Create a filtering reducing function <code>rf′(acc, x) = f(x) ? rf(acc, x) : acc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Fix1" href="#Base.Fix1"><code>Base.Fix1</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Fix1(f, x)</code></pre><p>A type representing a partially-applied version of the two-argument function <code>f</code>, with the first argument fixed to the value &quot;x&quot;. In other words, <code>Fix1(f, x)</code> behaves similarly to <code>y-&gt;f(x, y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L970-L976">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Fix2" href="#Base.Fix2"><code>Base.Fix2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Fix2(f, x)</code></pre><p>A type representing a partially-applied version of the two-argument function <code>f</code>, with the second argument fixed to the value &quot;x&quot;. In other words, <code>Fix2(f, x)</code> behaves similarly to <code>y-&gt;f(y, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L987-L993">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.FlatteningRF" href="#Base.FlatteningRF"><code>Base.FlatteningRF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FlatteningRF(rf) -&gt; rf′</code></pre><p>Create a flattening reducing function that is roughly equivalent to <code>rf′(acc, x) = foldl(rf, x; init=acc)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Generator" href="#Base.Generator"><code>Base.Generator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Generator(f, iter)</code></pre><p>Given a function <code>f</code> and an iterator <code>iter</code>, construct an iterator that yields the values of <code>f</code> applied to the elements of <code>iter</code>. The syntax for constructing an instance of this type is <code>f(x) for x in iter [if cond(x)::Bool]</code>. The <code>[if cond(x)::Bool]</code> expression is optional and acts as a &quot;guard&quot;, effectively filtering out values where the condition is false.</p><pre><code class="language-julia-repl hljs">julia&gt; g = (abs2(x) for x in 1:5 if x != 3);

julia&gt; for x in g
           println(x)
       end
1
4
16
25

julia&gt; collect(g)
4-element Vector{Int64}:
  1
  4
 16
 25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/generator.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.GenericCondition" href="#Base.GenericCondition"><code>Base.GenericCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GenericCondition</code></pre><p>Abstract implementation of a condition object for synchronizing tasks objects with a given lock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/condition.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IOBuffer-Tuple{AbstractVector{UInt8}}" href="#Base.IOBuffer-Tuple{AbstractVector{UInt8}}"><code>Base.IOBuffer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IOBuffer([data::AbstractVector{UInt8}]; keywords...) -&gt; IOBuffer</code></pre><p>Create an in-memory I/O stream, which may optionally operate on a pre-existing array.</p><p>It may take optional keyword arguments:</p><ul><li><code>read</code>, <code>write</code>, <code>append</code>: restricts operations to the buffer; see <code>open</code> for details.</li><li><code>truncate</code>: truncates the buffer size to zero length.</li><li><code>maxsize</code>: specifies a size beyond which the buffer may not be grown.</li><li><code>sizehint</code>: suggests a capacity of the buffer (<code>data</code> must implement <code>sizehint!(data, size)</code>).</li></ul><p>When <code>data</code> is not given, the buffer will be both readable and writable by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer();

julia&gt; write(io, &quot;JuliaLang is a GitHub organization.&quot;, &quot; It has many members.&quot;)
56

julia&gt; String(take!(io))
&quot;JuliaLang is a GitHub organization. It has many members.&quot;

julia&gt; io = IOBuffer(b&quot;JuliaLang is a GitHub organization.&quot;)
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=35, maxsize=Inf, ptr=1, mark=-1)

julia&gt; read(io, String)
&quot;JuliaLang is a GitHub organization.&quot;

julia&gt; write(io, &quot;This isn&#39;t writable.&quot;)
ERROR: ArgumentError: ensureroom failed, IOBuffer is not writeable

julia&gt; io = IOBuffer(UInt8[], read=true, write=true, maxsize=34)
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=34, ptr=1, mark=-1)

julia&gt; write(io, &quot;JuliaLang is a GitHub organization.&quot;)
34

julia&gt; String(take!(io))
&quot;JuliaLang is a GitHub organization&quot;

julia&gt; length(read(IOBuffer(b&quot;data&quot;, read=true, truncate=false)))
4

julia&gt; length(read(IOBuffer(b&quot;data&quot;, read=true, truncate=true)))
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iobuffer.jl#L35-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IOBuffer-Tuple{String}" href="#Base.IOBuffer-Tuple{String}"><code>Base.IOBuffer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IOBuffer(string::String)</code></pre><p>Create a read-only <code>IOBuffer</code> on the data underlying the given string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer(&quot;Haho&quot;);

julia&gt; String(take!(io))
&quot;Haho&quot;

julia&gt; String(take!(io))
&quot;Haho&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L225-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IOContext" href="#Base.IOContext"><code>Base.IOContext</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IOContext</code></pre><p><code>IOContext</code> provides a mechanism for passing output configuration settings among <a href="#Base.show-Tuple{IO, Any}"><code>show</code></a> methods.</p><p>In short, it is an immutable dictionary that is a subclass of <code>IO</code>. It supports standard dictionary operations such as <a href="#Base.getindex"><code>getindex</code></a>, and can also be used as an I/O stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L216-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IOContext-Tuple{IO, IO}" href="#Base.IOContext-Tuple{IO, IO}"><code>Base.IOContext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IOContext(io::IO, context::IOContext)</code></pre><p>Create an <code>IOContext</code> that wraps an alternate <code>IO</code> but inherits the properties of <code>context</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IOContext-Tuple{IO, Pair, Vararg{Pair, N} where N}" href="#Base.IOContext-Tuple{IO, Pair, Vararg{Pair, N} where N}"><code>Base.IOContext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IOContext(io::IO, KV::Pair...)</code></pre><p>Create an <code>IOContext</code> that wraps a given stream, adding the specified <code>key=&gt;value</code> pairs to the properties of that stream (note that <code>io</code> can itself be an <code>IOContext</code>).</p><ul><li>use <code>(key =&gt; value) in io</code> to see if this particular combination is in the properties set</li><li>use <code>get(io, key, default)</code> to retrieve the most recent value for a particular key</li></ul><p>The following properties are in common use:</p><ul><li><code>:compact</code>: Boolean specifying that values should be printed more compactly, e.g. that numbers should be printed with fewer digits. This is set when printing array elements. <code>:compact</code> output should not contain line breaks.</li><li><code>:limit</code>: Boolean specifying that containers should be truncated, e.g. showing <code>…</code> in place of most elements.</li><li><code>:displaysize</code>: A <code>Tuple{Int,Int}</code> giving the size in rows and columns to use for text output. This can be used to override the display size for called functions, but to get the size of the screen use the <code>displaysize</code> function.</li><li><code>:typeinfo</code>: a <code>Type</code> characterizing the information already printed concerning the type of the object about to be displayed. This is mainly useful when displaying a collection of objects of the same type, so that redundant type information can be avoided (e.g. <code>[Float16(0)]</code> can be shown as &quot;Float16[0.0]&quot; instead of &quot;Float16[Float16(0.0)]&quot; : while displaying the elements of the array, the <code>:typeinfo</code> property will be set to <code>Float16</code>).</li><li><code>:color</code>: Boolean specifying whether ANSI color/escape codes are supported/expected. By default, this is determined by whether <code>io</code> is a compatible terminal and by any <code>--color</code> command-line flag when <code>julia</code> was launched.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer();

julia&gt; printstyled(IOContext(io, :color =&gt; true), &quot;string&quot;, color=:red)

julia&gt; String(take!(io))
&quot;\e[31mstring\e[39m&quot;

julia&gt; printstyled(io, &quot;string&quot;, color=:red)

julia&gt; String(take!(io))
&quot;string&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; print(IOContext(stdout, :compact =&gt; false), 1.12341234)
1.12341234
julia&gt; print(IOContext(stdout, :compact =&gt; true), 1.12341234)
1.12341</code></pre><pre><code class="language-julia-repl hljs">julia&gt; function f(io::IO)
           if get(io, :short, false)
               print(io, &quot;short&quot;)
           else
               print(io, &quot;loooooong&quot;)
           end
       end
f (generic function with 1 method)

julia&gt; f(stdout)
loooooong
julia&gt; f(IOContext(stdout, :short =&gt; true))
short</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L259-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IOStream" href="#Base.IOStream"><code>Base.IOStream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IOStream</code></pre><p>A buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by <a href="#Base.open"><code>open</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IdDict" href="#Base.IdDict"><code>Base.IdDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdDict([itr])</code></pre><p><code>IdDict{K,V}()</code> constructs a hash table using object-id as hash and <code>===</code> as equality with keys of type <code>K</code> and values of type <code>V</code>.</p><p>See <a href="#Base.Dict"><code>Dict</code></a> for further help.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iddict.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IdentityUnitRange" href="#Base.IdentityUnitRange"><code>Base.IdentityUnitRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdentityUnitRange(range::AbstractUnitRange)</code></pre><p>Represent an AbstractUnitRange <code>range</code> as an offset vector such that <code>range[i] == i</code>.</p><p><code>IdentityUnitRange</code>s are frequently used as axes for offset arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L373-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ImmutableDict" href="#Base.ImmutableDict"><code>Base.ImmutableDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImmutableDict</code></pre><p><code>ImmutableDict</code> is a dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions. Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key.</p><pre><code class="nohighlight hljs">ImmutableDict(KV::Pair)</code></pre><p>Create a new entry in the <code>ImmutableDict</code> for a <code>key =&gt; value</code> pair</p><ul><li>use <code>(key =&gt; value) in dict</code> to see if this particular combination is in the properties set</li><li>use <code>get(dict, key, default)</code> to retrieve the most recent value for a particular key</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L738-L753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IndexCartesian" href="#Base.IndexCartesian"><code>Base.IndexCartesian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexCartesian()</code></pre><p>Subtype of <a href="#Base.IndexStyle-Tuple{AbstractArray}"><code>IndexStyle</code></a> used to describe arrays which are optimally indexed by a Cartesian index. This is the default for new custom <a href="#Core.AbstractArray"><code>AbstractArray</code></a> subtypes.</p><p>A Cartesian indexing style uses multiple integer indices to describe the position in a multidimensional array, with exactly one index per dimension. This means that requesting <a href="#Base.eachindex-Tuple{AbstractArray}"><code>eachindex</code></a> from an array that is <code>IndexCartesian</code> will return a range of <a href="@ref"><code>CartesianIndices</code></a>.</p><p>A <code>N</code>-dimensional custom array that reports its <code>IndexStyle</code> as <code>IndexCartesian</code> needs to implement indexing (and indexed assignment) with exactly <code>N</code> <code>Int</code> indices; all other indexing expressions — including linear indexing — will be recomputed to the equivalent Cartesian location.  For example, if <code>A</code> were a <code>2×3</code> custom matrix with cartesian indexing, and we referenced <code>A[5]</code>, this would be recomputed to the equivalent Cartesian index and call <code>A[1, 3]</code> since <code>5 = 2*1 + 3</code>.</p><p>It is significantly more expensive to compute Cartesian indices from a linear index than it is to go the other way.  The former operation requires division — a very costly operation — whereas the latter only uses multiplication and addition and is essentially free. This asymmetry means it is far more costly to use linear indexing with an <code>IndexCartesian</code> array than it is to use Cartesian indexing with an <code>IndexLinear</code> array.</p><p>See also <a href="#Base.IndexLinear"><code>IndexLinear</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L39-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IndexLinear" href="#Base.IndexLinear"><code>Base.IndexLinear</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IndexLinear()</code></pre><p>Subtype of <a href="#Base.IndexStyle-Tuple{AbstractArray}"><code>IndexStyle</code></a> used to describe arrays which are optimally indexed by one linear index.</p><p>A linear indexing style uses one integer index to describe the position in the array (even if it&#39;s a multidimensional array) and column-major ordering is used to efficiently access the elements. This means that requesting <a href="#Base.eachindex-Tuple{AbstractArray}"><code>eachindex</code></a> from an array that is <code>IndexLinear</code> will return a simple one-dimensional range, even if it is multidimensional.</p><p>A custom array that reports its <code>IndexStyle</code> as <code>IndexLinear</code> only needs to implement indexing (and indexed assignment) with a single <code>Int</code> index; all other indexing expressions — including multidimensional accesses — will be recomputed to the linear index.  For example, if <code>A</code> were a <code>2×3</code> custom matrix with linear indexing, and we referenced <code>A[1, 3]</code>, this would be recomputed to the equivalent linear index and call <code>A[5]</code> since <code>2*1 + 3 = 5</code>.</p><p>See also <a href="#Base.IndexCartesian"><code>IndexCartesian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L16-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IndexStyle-Tuple{AbstractArray}" href="#Base.IndexStyle-Tuple{AbstractArray}"><code>Base.IndexStyle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IndexStyle(A)
IndexStyle(typeof(A))</code></pre><p><code>IndexStyle</code> specifies the &quot;native indexing style&quot; for array <code>A</code>. When you define a new <a href="#Core.AbstractArray"><code>AbstractArray</code></a> type, you can choose to implement either linear indexing (with <a href="#Base.IndexLinear"><code>IndexLinear</code></a>) or cartesian indexing. If you decide to only implement linear indexing, then you must set this trait for your array type:</p><pre><code class="nohighlight hljs">Base.IndexStyle(::Type{&lt;:MyArray}) = IndexLinear()</code></pre><p>The default is <a href="#Base.IndexCartesian"><code>IndexCartesian()</code></a>.</p><p>Julia&#39;s internal indexing machinery will automatically (and invisibly) recompute all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</p><p>If you define both styles of indexing for your <code>AbstractArray</code>, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, <a href="#Base.eachindex-Tuple{AbstractArray}"><code>eachindex</code></a> creates an iterator whose type depends on the setting of this trait.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L68-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Irrational" href="#Base.Irrational"><code>Base.Irrational</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Irrational{sym} &lt;: AbstractIrrational</code></pre><p>Number type representing an exact irrational value denoted by the symbol <code>sym</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/irrationals.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IteratorEltype-Tuple{Any}" href="#Base.IteratorEltype-Tuple{Any}"><code>Base.IteratorEltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IteratorEltype(itertype::Type) -&gt; IteratorEltype</code></pre><p>Given the type of an iterator, return one of the following values:</p><ul><li><code>EltypeUnknown()</code> if the type of elements yielded by the iterator is not known in advance.</li><li><code>HasEltype()</code> if the element type is known, and <a href="#Base.eltype-Tuple{Type}"><code>eltype</code></a> would return a meaningful value.</li></ul><p><code>HasEltype()</code> is the default, since iterators are assumed to implement <a href="#Base.eltype-Tuple{Type}"><code>eltype</code></a>.</p><p>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</p><pre><code class="language-julia-repl hljs">julia&gt; Base.IteratorEltype(1:5)
Base.HasEltype()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/generator.jl#L105-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IteratorSize-Tuple{Any}" href="#Base.IteratorSize-Tuple{Any}"><code>Base.IteratorSize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IteratorSize(itertype::Type) -&gt; IteratorSize</code></pre><p>Given the type of an iterator, return one of the following values:</p><ul><li><code>SizeUnknown()</code> if the length (number of elements) cannot be determined in advance.</li><li><code>HasLength()</code> if there is a fixed, finite length.</li><li><code>HasShape{N}()</code> if there is a known length plus a notion of multidimensional shape (as for an array).  In this case <code>N</code> should give the number of dimensions, and the <a href="#Base.axes-Tuple{Any}"><code>axes</code></a> function is valid  for the iterator.</li><li><code>IsInfinite()</code> if the iterator yields values forever.</li></ul><p>The default value (for iterators that do not define this function) is <code>HasLength()</code>. This means that most iterators are assumed to implement <a href="#Base.length"><code>length</code></a>.</p><p>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</p><pre><code class="language-julia-repl hljs">julia&gt; Base.IteratorSize(1:5)
Base.HasShape{1}()

julia&gt; Base.IteratorSize((2,3))
Base.HasLength()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/generator.jl#L64-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.KeyError" href="#Base.KeyError"><code>Base.KeyError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KeyError(key)</code></pre><p>An indexing operation into an <code>AbstractDict</code> (<code>Dict</code>) or <code>Set</code> like object tried to access or delete a non-existent element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.LibuvServer" href="#Base.LibuvServer"><code>Base.LibuvServer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LibuvServer</code></pre><p>An abstract type for IOServers handled by libuv.</p><p>If <code>server isa LibuvServer</code>, it must obey the following interface:</p><ul><li><code>server.handle</code> must be a <code>Ptr{Cvoid}</code></li><li><code>server.status</code> must be an <code>Int</code></li><li><code>server.cond</code> must be a <code>GenericCondition</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L16-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.LibuvStream" href="#Base.LibuvStream"><code>Base.LibuvStream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LibuvStream</code></pre><p>An abstract type for IO streams handled by libuv.</p><p>If<code>stream isa LibuvStream</code>, it must obey the following interface:</p><ul><li><code>stream.handle</code>, if present, must be a <code>Ptr{Cvoid}</code></li><li><code>stream.status</code>, if present, must be an <code>Int</code></li><li><code>stream.buffer</code>, if present, must be an <code>IOBuffer</code></li><li><code>stream.sendbuf</code>, if present, must be a <code>Union{Nothing,IOBuffer}</code></li><li><code>stream.cond</code>, if present, must be a <code>GenericCondition</code></li><li><code>stream.lock</code>, if present, must be an <code>AbstractLock</code></li><li><code>stream.throttle</code>, if present, must be an <code>Int</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L41-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.LinRange" href="#Base.LinRange"><code>Base.LinRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinRange{T}</code></pre><p>A range with <code>len</code> linearly spaced elements between its <code>start</code> and <code>stop</code>. The size of the spacing is controlled by <code>len</code>, which must be an <code>Int</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LinRange(1.5, 5.5, 9)
9-element LinRange{Float64}:
 1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5</code></pre><p>Compared to using <a href="#Base.range-Tuple{Any}"><code>range</code></a>, directly constructing a <code>LinRange</code> should have less overhead but won&#39;t try to correct for floating point errors:</p><pre><code class="language-julia hljs">julia&gt; collect(range(-0.1, 0.3, length=5))
5-element Array{Float64,1}:
 -0.1
  0.0
  0.1
  0.2
  0.3

julia&gt; collect(LinRange(-0.1, 0.3, 5))
5-element Array{Float64,1}:
 -0.1
 -1.3877787807814457e-17
  0.09999999999999999
  0.19999999999999998
  0.3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L376-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.LinearIndices" href="#Base.LinearIndices"><code>Base.LinearIndices</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearIndices(A::AbstractArray)</code></pre><p>Return a <code>LinearIndices</code> array with the same shape and <a href="#Base.axes-Tuple{Any}"><code>axes</code></a> as <code>A</code>, holding the linear index of each entry in <code>A</code>. Indexing this array with cartesian indices allows mapping them to linear indices.</p><p>For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to <code>length(A)</code>. However, for <code>AbstractVector</code>s linear indices are <code>axes(A, 1)</code>, and therefore do not start at 1 for vectors with unconventional indexing.</p><p>Calling this function is the &quot;safe&quot; way to write algorithms that exploit linear indexing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (5,6,7));

julia&gt; b = LinearIndices(A);

julia&gt; extrema(b)
(1, 210)</code></pre><pre><code class="nohighlight hljs">LinearIndices(inds::CartesianIndices) -&gt; R
LinearIndices(sz::Dims) -&gt; R
LinearIndices((istart:istop, jstart:jstop, ...)) -&gt; R</code></pre><p>Return a <code>LinearIndices</code> array with the specified shape or <a href="#Base.axes-Tuple{Any}"><code>axes</code></a>.</p><p><strong>Example</strong></p><p>The main purpose of this constructor is intuitive conversion from cartesian to linear indexing:</p><pre><code class="language-julia-repl hljs">julia&gt; linear = LinearIndices((1:3, 1:2))
3×2 LinearIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:
 1  4
 2  5
 3  6

julia&gt; linear[1,2]
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L403-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.LogicalIndex" href="#Base.LogicalIndex"><code>Base.LogicalIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogicalIndex(mask)</code></pre><p>The <code>LogicalIndex</code> type is a special vector that simply contains all indices I where <code>mask[I]</code> is true. This specialized type does not support indexing directly as doing so would require O(n) lookup time. <code>AbstractArray{Bool}</code> are wrapped with <code>LogicalIndex</code> upon calling <a href="#Base.to_indices-Tuple{Any, Tuple}"><code>to_indices</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/multidimensional.jl#L715-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.MappingRF" href="#Base.MappingRF"><code>Base.MappingRF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MappingRF(f, rf) -&gt; rf′</code></pre><p>Create a mapping reducing function <code>rf′(acc, x) = rf(acc, f(x))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Matrix" href="#Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matrix{T} &lt;: AbstractMatrix{T}</code></pre><p>Two-dimensional dense array with elements of type <code>T</code>, often used to represent a mathematical matrix. Alias for <a href="#Core.Array"><code>Array{T,2}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Missing" href="#Base.Missing"><code>Base.Missing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Missing</code></pre><p>A type with no fields whose singleton instance <a href="#Base.missing"><code>missing</code></a> is used to represent missing values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L794-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.MissingException" href="#Base.MissingException"><code>Base.MissingException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MissingException(msg)</code></pre><p>Exception thrown when a <a href="#Base.missing"><code>missing</code></a> value is encountered in a situation where it is not supported. The error message, in the <code>msg</code> field may provide more specific details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/missing.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.OneTo" href="#Base.OneTo"><code>Base.OneTo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Base.OneTo(n)</code></pre><p>Define an <code>AbstractUnitRange</code> that behaves like <code>1:n</code>, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L317-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.OrdinalRange" href="#Base.OrdinalRange"><code>Base.OrdinalRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrdinalRange{T, S} &lt;: AbstractRange{T}</code></pre><p>Supertype for ordinal ranges with elements of type <code>T</code> with spacing(s) of type <code>S</code>. The steps should be always-exact multiples of <a href="#Base.oneunit-Tuple{T} where T"><code>oneunit</code></a>, and <code>T</code> should be a &quot;discrete&quot; type, which cannot have values smaller than <code>oneunit</code>. For example, <code>Integer</code> or <code>Date</code> types would qualify, whereas <code>Float64</code> would not (since this type can represent values smaller than <code>oneunit(Float64)</code>. <a href="#Base.UnitRange"><code>UnitRange</code></a>, <a href="#Base.StepRange"><code>StepRange</code></a>, and other types are subtypes of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L152-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Pair" href="#Base.Pair"><code>Base.Pair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pair(x, y)
x =&gt; y</code></pre><p>Construct a <code>Pair</code> object with type <code>Pair{typeof(x), typeof(y)}</code>. The elements are stored in the fields <code>first</code> and <code>second</code>. They can also be accessed via iteration (but a <code>Pair</code> is treated as a single &quot;scalar&quot; for broadcasting operations).</p><p>See also: <a href="#Base.Dict"><code>Dict</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p = &quot;foo&quot; =&gt; 7
&quot;foo&quot; =&gt; 7

julia&gt; typeof(p)
Pair{String, Int64}

julia&gt; p.first
&quot;foo&quot;

julia&gt; for x in p
           println(x)
       end
foo
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/pair.jl#L18-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Pipe-Tuple{}" href="#Base.Pipe-Tuple{}"><code>Base.Pipe</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct an uninitialized Pipe object.</p><p>The appropriate end of the pipe will be automatically initialized if the object is used in process spawning. This can be useful to easily obtain references in process pipelines, e.g.:</p><pre><code class="nohighlight hljs">julia&gt; err = Pipe()

# After this `err` will be initialized and you may read `foo`&#39;s
# stderr from the `err` pipe.
julia&gt; run(pipeline(pipeline(`foo`, stderr=err), `cat`), wait=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L689-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ProcessFailedException" href="#Base.ProcessFailedException"><code>Base.ProcessFailedException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProcessFailedException</code></pre><p>Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L499-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.RangeStepStyle" href="#Base.RangeStepStyle"><code>Base.RangeStepStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RangeStepStyle(instance)
RangeStepStyle(T::Type)</code></pre><p>Indicate whether an instance or a type supports constructing a range with a perfectly regular step or not. A regular step means that <a href="#Base.step-Tuple{StepRange}"><code>step</code></a> will always be exactly equal to the difference between two subsequent elements in a range, i.e. for a range <code>r::AbstractRange{T}</code>:</p><pre><code class="language-julia hljs">all(diff(r) .== step(r))</code></pre><p>When a type <code>T</code> always leads to ranges with regular steps, it should define the following method:</p><pre><code class="language-julia hljs">Base.RangeStepStyle(::Type{&lt;:AbstractRange{&lt;:T}}) = Base.RangeStepRegular()</code></pre><p>This will allow <a href="#Base.hash-Tuple{Any}"><code>hash</code></a> to use an O(1) algorithm for <code>AbstractRange{T}</code> objects instead of the default O(N) algorithm (with N the length of the range).</p><p>In some cases, whether the step will be regular depends not only on the element type <code>T</code>, but also on the type of the step <code>S</code>. In that case, more specific methods should be defined:</p><pre><code class="language-julia hljs">Base.RangeStepStyle(::Type{&lt;:OrdinalRange{&lt;:T, &lt;:S}}) = Base.RangeStepRegular()</code></pre><p>By default, all range types are assumed to be <code>RangeStepIrregular</code>, except ranges with an element type which is a subtype of <code>Integer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/traits.jl#L28-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Rational" href="#Base.Rational"><code>Base.Rational</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rational{T&lt;:Integer} &lt;: Real</code></pre><p>Rational number type, with numerator and denominator of type <code>T</code>. Rationals are checked for overflow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/rational.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ReentrantLock" href="#Base.ReentrantLock"><code>Base.ReentrantLock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReentrantLock()</code></pre><p>Creates a re-entrant lock for synchronizing <a href="@ref"><code>Task</code></a>s. The same task can acquire the lock as many times as required. Each <a href="#Base.lock-Tuple{Any, Base.AbstractLock}"><code>lock</code></a> must be matched with an <a href="#Base.unlock-Tuple{ReentrantLock}"><code>unlock</code></a>.</p><p>Calling &#39;lock&#39; will also inhibit running of finalizers on that thread until the corresponding &#39;unlock&#39;. Use of the standard lock pattern illustrated below should naturally be supported, but beware of inverting the try/lock order or missing the try block entirely (e.g. attempting to return with the lock still held):</p><pre><code class="nohighlight hljs">lock(l)
try
    &lt;atomic work&gt;
finally
    unlock(l)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/lock.jl#L6-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Regex" href="#Base.Regex"><code>Base.Regex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Regex(pattern[, flags])</code></pre><p>A type representing a regular expression. <code>Regex</code> objects can be used to match strings with <a href="#Base.match"><code>match</code></a>.</p><p><code>Regex</code> objects can be created using the <a href="#Base.@r_str-Tuple{Any, Vararg{Any, N} where N}"><code>@r_str</code></a> string macro. The <code>Regex(pattern[, flags])</code> constructor is usually used if the <code>pattern</code> string needs to be interpolated. See the documentation of the string macro for details on flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ReinterpretArray" href="#Base.ReinterpretArray"><code>Base.ReinterpretArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gives a reinterpreted view (of element type T) of the underlying array (of element type S). If the size of <code>T</code> differs from the size of <code>S</code>, the array will be compressed/expanded in the first dimension. The variant <code>reinterpret(reshape, T, a)</code> instead adds or consumes the first dimension depending on the ratio of element sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reinterpretarray.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.SecretBuffer" href="#Base.SecretBuffer"><code>Base.SecretBuffer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Base.SecretBuffer()</code></pre><p>An <a href="#Base.IOBuffer-Tuple{AbstractVector{UInt8}}"><code>IOBuffer</code></a>-like object where the contents will be securely wiped when garbage collected.</p><p>It is considered best practice to wipe the buffer using <code>Base.shred!(::SecretBuffer)</code> as soon as the secure data are no longer required. When initializing with existing data, the <code>SecretBuffer!</code> method is highly recommended to securely zero the passed argument. Avoid initializing with and converting to <code>String</code>s as they are unable to be securely zeroed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = Base.SecretBuffer()
SecretBuffer(&quot;*******&quot;)

julia&gt; write(s, &#39;s&#39;, &#39;e&#39;, &#39;c&#39;, &#39;r&#39;, &#39;e&#39;, &#39;t&#39;)
6

julia&gt; seek(s, 0); Char(read(s, UInt8))
&#39;s&#39;: ASCII/Unicode U+0073 (category Ll: Letter, lowercase)

julia&gt; Base.shred!(s)
SecretBuffer(&quot;*******&quot;)

julia&gt; eof(s)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/secretbuffer.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.SecretBuffer-Tuple{AbstractString}" href="#Base.SecretBuffer-Tuple{AbstractString}"><code>Base.SecretBuffer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SecretBuffer(str::AbstractString)</code></pre><p>A convenience constructor to initialize a <code>SecretBuffer</code> from a non-secret string.</p><p>Strings are bad at keeping secrets because they are unable to be securely zeroed or destroyed. Therefore, avoid using this constructor with secret data. Instead of starting with a string, either construct the <code>SecretBuffer</code> incrementally with <code>SecretBuffer()</code> and <a href="#Base.write"><code>write</code></a>, or use a <code>Vector{UInt8}</code> with the <code>Base.SecretBuffer!(::Vector{UInt8})</code> constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/secretbuffer.jl#L43-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Semaphore" href="#Base.Semaphore"><code>Base.Semaphore</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Semaphore(sem_size)</code></pre><p>Create a counting semaphore that allows at most <code>sem_size</code> acquires to be in use at any time. Each acquire must be matched with a release.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/lock.jl#L265-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Set-Tuple{Any}" href="#Base.Set-Tuple{Any}"><code>Base.Set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Set([itr])</code></pre><p>Construct a <a href="#Base.Set-Tuple{Any}"><code>Set</code></a> of the values generated by the given iterable object, or an empty set. Should be used instead of <a href="#Base.BitSet-Tuple{Any}"><code>BitSet</code></a> for sparse integer sets, or for sets of arbitrary objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/set.jl#L14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Slice" href="#Base.Slice"><code>Base.Slice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Slice(indices)</code></pre><p>Represent an AbstractUnitRange of indices as a vector of the indices themselves, with special handling to signal they represent a complete slice of a dimension (:).</p><p>Upon calling <code>to_indices</code>, Colons are converted to Slice objects to represent the indices over which the Colon spans. Slice objects are themselves unit ranges with the same indices as those they wrap. This means that indexing into Slice objects with an integer always returns that exact integer, and they iterate over all the wrapped indices, even supporting offset indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L338-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Some" href="#Base.Some"><code>Base.Some</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Some{T}</code></pre><p>A wrapper type used in <code>Union{Some{T}, Nothing}</code> to distinguish between the absence of a value (<a href="@ref"><code>nothing</code></a>) and the presence of a <code>nothing</code> value (i.e. <code>Some(nothing)</code>).</p><p>Use <a href="#Base.something"><code>something</code></a> to access the value wrapped by a <code>Some</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/some.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.StepRange" href="#Base.StepRange"><code>Base.StepRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StepRange{T, S} &lt;: OrdinalRange{T, S}</code></pre><p>Ranges with elements of type <code>T</code> with spacing of type <code>S</code>. The step between each element is constant, and the range is defined in terms of a <code>start</code> and <code>stop</code> of type <code>T</code> and a <code>step</code> of type <code>S</code>. Neither <code>T</code> nor <code>S</code> should be floating point types. The syntax <code>a:b:c</code> with <code>b &gt; 1</code> and <code>a</code>, <code>b</code>, and <code>c</code> all integers creates a <code>StepRange</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(StepRange(1, Int8(2), 10))
5-element Vector{Int64}:
 1
 3
 5
 7
 9

julia&gt; typeof(StepRange(1, Int8(2), 10))
StepRange{Int64, Int8}

julia&gt; typeof(1:3:6)
StepRange{Int64, Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L173-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.StepRangeLen" href="#Base.StepRangeLen"><code>Base.StepRangeLen</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1]) where {T,R,S}
StepRangeLen(       ref::R, step::S, len, [offset=1]) where {  R,S}</code></pre><p>A range <code>r</code> where <code>r[i]</code> produces values of type <code>T</code> (in the second form, <code>T</code> is deduced automatically), parameterized by a <code>ref</code>erence value, a <code>step</code>, and the <code>len</code>gth. By default <code>ref</code> is the starting value <code>r[1]</code>, but alternatively you can supply it as the value of <code>r[offset]</code> for some other index <code>1 &lt;= offset &lt;= len</code>. In conjunction with <code>TwicePrecision</code> this can be used to implement ranges that are free of roundoff error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L341-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.StringIndexError" href="#Base.StringIndexError"><code>Base.StringIndexError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StringIndexError(str, i)</code></pre><p>An error occurred when trying to access <code>str</code> at index <code>i</code> that is not valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/string.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.SubArray" href="#Base.SubArray"><code>Base.SubArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubArray{T,N,P,I,L} &lt;: AbstractArray{T,N}</code></pre><p><code>N</code>-dimensional view into a parent array (of type <code>P</code>) with an element type <code>T</code>, restricted by a tuple of indices (of type <code>I</code>). <code>L</code> is true for types that support fast linear indexing, and <code>false</code> otherwise.</p><p>Construct <code>SubArray</code>s using the <a href="#Base.view-Union{Tuple{N}, Tuple{AbstractArray, Vararg{Any, N}}} where N"><code>view</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/subarray.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.SubString" href="#Base.SubString"><code>Base.SubString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))
SubString(s::AbstractString, r::UnitRange{&lt;:Integer})</code></pre><p>Like <a href="#Base.getindex"><code>getindex</code></a>, but returns a view into the parent string <code>s</code> within range <code>i:j</code> or <code>r</code> respectively instead of making a copy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SubString(&quot;abc&quot;, 1, 2)
&quot;ab&quot;

julia&gt; SubString(&quot;abc&quot;, 1:2)
&quot;ab&quot;

julia&gt; SubString(&quot;abc&quot;, 2)
&quot;bc&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/substring.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.SubstitutionString" href="#Base.SubstitutionString"><code>Base.SubstitutionString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubstitutionString(substr)</code></pre><p>Stores the given string <code>substr</code> as a <code>SubstitutionString</code>, for use in regular expression substitutions. Most commonly constructed using the <a href="#Base.@s_str-Tuple{Any}"><code>@s_str</code></a> macro.</p><pre><code class="language-julia-repl hljs">julia&gt; SubstitutionString(&quot;Hello \\g&lt;name&gt;, it&#39;s \\1&quot;)
s&quot;Hello \g&lt;name&gt;, it&#39;s \1&quot;

julia&gt; subst = s&quot;Hello \g&lt;name&gt;, it&#39;s \1&quot;
s&quot;Hello \g&lt;name&gt;, it&#39;s \1&quot;

julia&gt; typeof(subst)
SubstitutionString{String}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L430-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.SystemError" href="#Base.SystemError"><code>Base.SystemError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SystemError(prefix::AbstractString, [errno::Int32])</code></pre><p>A system call failed with an error code (in the <code>errno</code> global variable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.TaskFailedException" href="#Base.TaskFailedException"><code>Base.TaskFailedException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TaskFailedException</code></pre><p>This exception is thrown by a <code>wait(t)</code> call when task <code>t</code> fails. <code>TaskFailedException</code> wraps the failed task <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Timer" href="#Base.Timer"><code>Base.Timer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Timer(delay; interval = 0)</code></pre><p>Create a timer that wakes up tasks waiting for it (by calling <a href="#Base.wait-Tuple{Base.GenericCondition}"><code>wait</code></a> on the timer object).</p><p>Waiting tasks are woken after an initial delay of <code>delay</code> seconds, and then repeating with the given <code>interval</code> in seconds. If <code>interval</code> is equal to <code>0</code>, the timer is only triggered once. When the timer is closed (by <a href="#Base.close"><code>close</code></a>) waiting tasks are woken with an error. Use <a href="#Base.isopen"><code>isopen</code></a> to check whether a timer is still active.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/asyncevent.jl#L55-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Timer-Tuple{Function, Real}" href="#Base.Timer-Tuple{Function, Real}"><code>Base.Timer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Timer(callback::Function, delay; interval = 0)</code></pre><p>Create a timer that wakes up tasks waiting for it (by calling <a href="#Base.wait-Tuple{Base.GenericCondition}"><code>wait</code></a> on the timer object) and calls the function <code>callback</code>.</p><p>Waiting tasks are woken and the function <code>callback</code> is called after an initial delay of <code>delay</code> seconds, and then repeating with the given <code>interval</code> in seconds. If <code>interval</code> is equal to <code>0</code>, the timer is only triggered once. The function <code>callback</code> is called with a single argument, the timer itself. When the timer is closed (by <a href="#Base.close"><code>close</code></a>) waiting tasks are woken with an error. Use <a href="#Base.isopen"><code>isopen</code></a> to check whether a timer is still active.</p><p><strong>Examples</strong></p><p>Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.</p><pre><code class="language-julia-repl hljs">julia&gt; begin
           i = 0
           cb(timer) = (global i += 1; println(i))
           t = Timer(cb, 2, interval=0.2)
           wait(t)
           sleep(0.5)
           close(t)
       end
1
2
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/asyncevent.jl#L219-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.TwicePrecision" href="#Base.TwicePrecision"><code>Base.TwicePrecision</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TwicePrecision{T}(hi::T, lo::T)
TwicePrecision{T}((num, denom))</code></pre><p>A number with twice the precision of <code>T</code>, e.g., quad-precision if <code>T = Float64</code>. <code>hi</code> represents the high bits (most significant bits) and <code>lo</code> the low bits (least significant bits). Rational values <code>num//denom</code> can be approximated conveniently using the syntax <code>TwicePrecision{T}((num, denom))</code>.</p><p>When used with <code>T&lt;:Union{Float16,Float32,Float64}</code> to construct an &quot;exact&quot; <code>StepRangeLen</code>, <code>ref</code> should be the range element with smallest magnitude and <code>offset</code> set to the corresponding index.  For efficiency, multiplication of <code>step</code> by the index is not performed at twice precision: <code>step.hi</code> should have enough trailing zeros in its <code>bits</code> representation that <code>(0:len-1)*step.hi</code> is exact (has no roundoff error).  If <code>step</code> has an exact rational representation <code>num//denom</code>, then you can construct <code>step</code> using</p><pre><code class="nohighlight hljs">step = TwicePrecision{T}((num, denom), nb)</code></pre><p>where <code>nb</code> is the number of trailing zero bits of <code>step.hi</code>.  For ranges, you can set <code>nb = ceil(Int, log2(len-1))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/twiceprecision.jl#L160-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.UUID" href="#Base.UUID"><code>Base.UUID</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Represents a Universally Unique Identifier (UUID).
Can be built from one `UInt128` (all byte values), two `UInt64`, or four `UInt32`.
Conversion from a string will check the UUID validity.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/uuid.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.UnitRange" href="#Base.UnitRange"><code>Base.UnitRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnitRange{T&lt;:Real}</code></pre><p>A range parameterized by a <code>start</code> and <code>stop</code> of type <code>T</code>, filled with elements spaced by <code>1</code> from <code>start</code> until <code>stop</code> is exceeded. The syntax <code>a:b</code> with <code>a</code> and <code>b</code> both <code>Integer</code>s creates a <code>UnitRange</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(UnitRange(2.3, 5.2))
3-element Vector{Float64}:
 2.3
 3.3
 4.3

julia&gt; typeof(1:10)
UnitRange{Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L265-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Val" href="#Base.Val"><code>Base.Val</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Val(c)</code></pre><p>Return <code>Val{c}()</code>, which contains no run-time data. Types like this can be used to pass the information between functions through the value <code>c</code>, which must be an <code>isbits</code> value or a <code>Symbol</code>. The intent of this construct is to be able to dispatch on constants directly (at compile time) without having to test the value of the constant at run time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f(::Val{true}) = &quot;Good&quot;
f (generic function with 1 method)

julia&gt; f(::Val{false}) = &quot;Bad&quot;
f (generic function with 2 methods)

julia&gt; f(Val(true))
&quot;Good&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L670-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Vector" href="#Base.Vector"><code>Base.Vector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Vector{T} &lt;: AbstractVector{T}</code></pre><p>One-dimensional dense array with elements of type <code>T</code>, often used to represent a mathematical vector. Alias for <a href="#Core.Array"><code>Array{T,1}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.VersionNumber" href="#Base.VersionNumber"><code>Base.VersionNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VersionNumber</code></pre><p>Version number type which follow the specifications of <a href="https://semver.org/">semantic versioning</a>, composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. See also <a href="#Base.@v_str-Tuple{Any}"><code>@v_str</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; VersionNumber(&quot;1.2.3&quot;)
v&quot;1.2.3&quot;

julia&gt; VersionNumber(&quot;2.0.1-rc1&quot;)
v&quot;2.0.1-rc1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/version.jl#L8-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.WeakKeyDict" href="#Base.WeakKeyDict"><code>Base.WeakKeyDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeakKeyDict([itr])</code></pre><p><code>WeakKeyDict()</code> constructs a hash table where the keys are weak references to objects which may be garbage collected even when referenced in a hash table.</p><p>See <a href="#Base.Dict"><code>Dict</code></a> for further help.  Note, unlike <a href="#Base.Dict"><code>Dict</code></a>, <code>WeakKeyDict</code> does not convert keys on insertion, as this would imply the key object was unreferenced anywhere before insertion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/weakkeydict.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.AbstractArray" href="#Core.AbstractArray"><code>Core.AbstractArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractArray{T,N}</code></pre><p>Supertype for <code>N</code>-dimensional arrays (or array-like types) with elements of type <code>T</code>. <a href="#Core.Array"><code>Array</code></a> and other types are subtypes of this. See the manual section on the <a href="@ref man-interface-array"><code>AbstractArray</code> interface</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.AbstractChar" href="#Core.AbstractChar"><code>Core.AbstractChar</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>AbstractChar</code> type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the <a href="#Base.codepoint"><code>codepoint</code></a> function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with <code>&lt;</code> and <code>==</code>, for example.  New <code>T &lt;: AbstractChar</code> types should define a <code>codepoint(::T)</code> method and a <code>T(::UInt32)</code> constructor, at minimum.</p><p>A given <code>AbstractChar</code> subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported <code>UInt32</code> value may throw an error. Conversely, the built-in <a href="#Core.Char"><code>Char</code></a> type represents a <em>superset</em> of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value <em>to</em> <code>UInt32</code> throws an error. The <a href="#Base.isvalid-Tuple{AbstractString, Integer}"><code>isvalid</code></a> function can be used to check which codepoints are representable in a given <code>AbstractChar</code> type.</p><p>Internally, an <code>AbstractChar</code> type may use a variety of encodings.  Conversion via <code>codepoint(char)</code> will not reveal this encoding because it always returns the Unicode value of the character. <code>print(io, c)</code> of any <code>c::AbstractChar</code> produces an encoding determined by <code>io</code> (UTF-8 for all built-in <code>IO</code> types), via conversion to <code>Char</code> if necessary.</p><p><code>write(io, c)</code>, in contrast, may emit an encoding depending on <code>typeof(c)</code>, and <code>read(io, typeof(c))</code> should read the same encoding as <code>write</code>. New <code>AbstractChar</code> types must provide their own implementations of <code>write</code> and <code>read</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/char.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.AbstractString" href="#Core.AbstractString"><code>Core.AbstractString</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>AbstractString</code> type is the supertype of all string implementations in Julia. Strings are encodings of sequences of <a href="https://unicode.org/">Unicode</a> code points as represented by the <code>AbstractChar</code> type. Julia makes a few assumptions about strings:</p><ul><li>Strings are encoded in terms of fixed-size &quot;code units&quot;<ul><li>Code units can be extracted with <code>codeunit(s, i)</code></li><li>The first code unit has index <code>1</code></li><li>The last code unit has index <code>ncodeunits(s)</code></li><li>Any index <code>i</code> such that <code>1 ≤ i ≤ ncodeunits(s)</code> is in bounds</li></ul></li><li>String indexing is done in terms of these code units:<ul><li>Characters are extracted by <code>s[i]</code> with a valid string index <code>i</code></li><li>Each <code>AbstractChar</code> in a string is encoded by one or more code units</li><li>Only the index of the first code unit of an <code>AbstractChar</code> is a valid index</li><li>The encoding of an <code>AbstractChar</code> is independent of what precedes or follows it</li><li>String encodings are [self-synchronizing] – i.e. <code>isvalid(s, i)</code> is O(1)</li></ul></li></ul><p>[self-synchronizing]: https://en.wikipedia.org/wiki/Self-synchronizing_code</p><p>Some string functions that extract code units, characters or substrings from strings error if you pass them out-of-bounds or invalid string indices. This includes <code>codeunit(s, i)</code> and <code>s[i]</code>. Functions that do string index arithmetic take a more relaxed approach to indexing and give you the closest valid string index when in-bounds, or when out-of-bounds, behave as if there were an infinite number of characters padding each side of the string. Usually these imaginary padding characters have code unit length <code>1</code> but string types may choose different &quot;imaginary&quot; character sizes as makes sense for their implementations (e.g. substrings may pass index arithmetic through to the underlying string they provide a view into). Relaxed indexing functions include those intended for index arithmetic: <code>thisind</code>, <code>nextind</code> and <code>prevind</code>. This model allows index arithmetic to work with out-of- bounds indices as intermediate values so long as one never uses them to retrieve a character, which often helps avoid needing to code around edge cases.</p><p>See also: <a href="#Base.codeunit-Tuple{AbstractString, Integer}"><code>codeunit</code></a>, <a href="#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a>, <a href="#Base.thisind-Tuple{AbstractString, Integer}"><code>thisind</code></a>, <a href="#Base.nextind-Tuple{AbstractString, Integer, Integer}"><code>nextind</code></a>, <a href="#Base.prevind-Tuple{AbstractString, Integer, Integer}"><code>prevind</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L3-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Array" href="#Core.Array"><code>Core.Array</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Array{T,N} &lt;: AbstractArray{T,N}</code></pre><p><code>N</code>-dimensional dense array with elements of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Char" href="#Core.Char"><code>Core.Char</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Char(c::Union{Number,AbstractChar})</code></pre><p><code>Char</code> is a 32-bit <a href="#Core.AbstractChar"><code>AbstractChar</code></a> type that is the default representation of characters in Julia. <code>Char</code> is the type used for character literals like <code>&#39;x&#39;</code> and it is also the element type of <a href="#Core.String-Tuple{AbstractString}"><code>String</code></a>.</p><p>In order to losslessly represent arbitrary byte streams stored in a <code>String</code>, a <code>Char</code> value may store information that cannot be converted to a Unicode codepoint — converting such a <code>Char</code> to <code>UInt32</code> will throw an error. The <a href="#Base.isvalid-Tuple{AbstractString, Integer}"><code>isvalid(c::Char)</code></a> function can be used to query whether <code>c</code> represents a valid Unicode character.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/char.jl#L33-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.DenseArray" href="#Core.DenseArray"><code>Core.DenseArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DenseArray{T, N} &lt;: AbstractArray{T,N}</code></pre><p><code>N</code>-dimensional dense array with elements of type <code>T</code>. The elements of a dense array are stored contiguously in memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.LLVMPtr" href="#Core.LLVMPtr"><code>Core.LLVMPtr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LLVMPtr{T, AS}</code></pre><p>A pointer type that more closely resembles LLVM semantics: It includes the pointer address space, and will be passed as an actual pointer instead of an integer.</p><p>This type is mainly used to interface with code that has strict requirements about pointers, e.g., intrinsics that are selected based on the address space, or back-ends that require pointers to be identifiable by their types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/refpointer.jl#L186-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.NTuple" href="#Core.NTuple"><code>Core.NTuple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NTuple{N, T}</code></pre><p>A compact way of representing the type for a tuple of length <code>N</code> where all elements are of type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isa((1, 2, 3, 4, 5, 6), NTuple{6, Int})
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/tuple.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.NamedTuple" href="#Core.NamedTuple"><code>Core.NamedTuple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NamedTuple</code></pre><p><code>NamedTuple</code>s are, as their name suggests, named <a href="@ref"><code>Tuple</code></a>s. That is, they&#39;re a tuple-like collection of values, where each entry has a unique name, represented as a <a href="@ref"><code>Symbol</code></a>. Like <code>Tuple</code>s, <code>NamedTuple</code>s are immutable; neither the names nor the values can be modified in place after construction.</p><p>Accessing the value associated with a name in a named tuple can be done using field access syntax, e.g. <code>x.a</code>, or using <a href="#Base.getindex"><code>getindex</code></a>, e.g. <code>x[:a]</code>. A tuple of the names can be obtained using <a href="#Base.keys"><code>keys</code></a>, and a tuple of the values can be obtained using <a href="#Base.values-Tuple{AbstractDict}"><code>values</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Iteration over <code>NamedTuple</code>s produces the <em>values</em> without the names. (See example below.) To iterate over the name-value pairs, use the <a href="#Base.pairs-Tuple{Any}"><code>pairs</code></a> function.</p></div></div><p>The <a href="#Base.@NamedTuple-Tuple{Any}"><code>@NamedTuple</code></a> macro can be used for conveniently declaring <code>NamedTuple</code> types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = (a=1, b=2)
(a = 1, b = 2)

julia&gt; x.a
1

julia&gt; x[:a]
1

julia&gt; keys(x)
(:a, :b)

julia&gt; values(x)
(1, 2)

julia&gt; collect(x)
2-element Vector{Int64}:
 1
 2

julia&gt; collect(pairs(x))
2-element Vector{Pair{Symbol, Int64}}:
 :a =&gt; 1
 :b =&gt; 2</code></pre><p>In a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair <code>name::Symbol =&gt; value</code> or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:</p><pre><code class="language-julia-repl hljs">julia&gt; (; :a =&gt; 1)
(a = 1,)

julia&gt; keys = (:a, :b, :c); values = (1, 2, 3);

julia&gt; (; zip(keys, values)...)
(a = 1, b = 2, c = 3)</code></pre><p>As in keyword arguments, identifiers and dot expressions imply names:</p><pre><code class="language-julia-repl hljs">julia&gt; x = 0
0

julia&gt; t = (; x)
(x = 0,)

julia&gt; (; t.x)
(x = 0,)</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Implicit names from identifiers and dot expressions are available as of Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/namedtuple.jl#L3-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Ptr" href="#Core.Ptr"><code>Core.Ptr</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ptr{T}</code></pre><p>A memory address referring to data of type <code>T</code>.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/pointer.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Ref" href="#Core.Ref"><code>Core.Ref</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ref{T}</code></pre><p>An object that safely references data of type <code>T</code>. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the <code>Ref</code> itself is referenced.</p><p>In Julia, <code>Ref</code> objects are dereferenced (loaded or stored) with <code>[]</code>.</p><p>Creation of a <code>Ref</code> to a value <code>x</code> of type <code>T</code> is usually written <code>Ref(x)</code>. Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written <code>Ref(a, i)</code> for creating a reference to the <code>i</code>-th element of <code>a</code>.</p><p><code>Ref{T}()</code> creates a reference to a value of type <code>T</code> without initialization. For a bitstype <code>T</code>, the value will be whatever currently resides in the memory allocated. For a non-bitstype <code>T</code>, the reference will be undefined and attempting to dereference it will result in an error, &quot;UndefRefError: access to undefined reference&quot;.</p><p>To check if a <code>Ref</code> is an undefined reference, use <a href="#Base.isassigned-Tuple{Base.RefValue}"><code>isassigned(ref::RefValue)</code></a>. For example, <code>isassigned(Ref{T}())</code> is <code>false</code> if <code>T</code> is not a bitstype. If <code>T</code> is a bitstype, <code>isassigned(Ref{T}())</code> will always be true.</p><p>When passed as a <code>ccall</code> argument (either as a <code>Ptr</code> or <code>Ref</code> type), a <code>Ref</code> object will be converted to a native pointer to the data it references. For most <code>T</code>, or when converted to a <code>Ptr{Cvoid}</code>, this is a pointer to the object data. When <code>T</code> is an <code>isbits</code> type, this value may be safely mutated, otherwise mutation is strictly undefined behavior.</p><p>As a special case, setting <code>T = Any</code> will instead cause the creation of a pointer to the reference itself when converted to a <code>Ptr{Any}</code> (a <code>jl_value_t const* const*</code> if T is immutable, else a <code>jl_value_t *const *</code>). When converted to a <code>Ptr{Cvoid}</code>, it will still return a pointer to the data region as for any other <code>T</code>.</p><p>A <code>C_NULL</code> instance of <code>Ptr</code> can be passed to a <code>ccall</code> <code>Ref</code> argument to initialize it.</p><p><strong>Use in broadcasting</strong></p><p><code>Ref</code> is sometimes used in broadcasting in order to treat the referenced values as a scalar.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Ref(5)
Base.RefValue{Int64}(5)

julia&gt; isa.(Ref([1,2,3]), [Array, Dict, Int]) # Treat reference values as scalar during broadcasting
3-element BitVector:
 1
 0
 0

julia&gt; Ref{Function}()  # Undefined reference to a non-bitstype, Function
Base.RefValue{Function}(#undef)

julia&gt; try
           Ref{Function}()[] # Dereferencing an undefined reference will result in an error
       catch e
           println(e)
       end
UndefRefError()

julia&gt; Ref{Int64}()[]; # A reference to a bitstype refers to an undetermined value if not given

julia&gt; isassigned(Ref{Int64}()) # A reference to a bitstype is always assigned
true

julia&gt; Ref{Int64}(0)[] == 0 # Explicitly give a value for a bitstype reference
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/refpointer.jl#L3-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.String-Tuple{AbstractString}" href="#Core.String-Tuple{AbstractString}"><code>Core.String</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">String(s::AbstractString)</code></pre><p>Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/string.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.String-Tuple{AbstractVector{UInt8}}" href="#Core.String-Tuple{AbstractVector{UInt8}}"><code>Core.String</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">String(v::AbstractVector{UInt8})</code></pre><p>Create a new <code>String</code> object from a byte vector <code>v</code> containing UTF-8 encoded characters. If <code>v</code> is <code>Vector{UInt8}</code> it will be truncated to zero length and future modification of <code>v</code> cannot affect the contents of the resulting string. To avoid truncation of <code>Vector{UInt8}</code> data, use <code>String(copy(v))</code>; for other <code>AbstractVector</code> types, <code>String(v)</code> already makes a copy.</p><p>When possible, the memory of <code>v</code> will be used without copying when the <code>String</code> object is created. This is guaranteed to be the case for byte vectors returned by <a href="#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a> on a writable <a href="#Base.IOBuffer-Tuple{AbstractVector{UInt8}}"><code>IOBuffer</code></a> and by calls to <a href="#Base.read-Tuple{Any, Any}"><code>read(io, nb)</code></a>. This allows zero-copy conversion of I/O data to strings. In other cases, <code>Vector{UInt8}</code> data may be copied, but <code>v</code> is truncated anyway to guarantee consistent behavior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/string.jl#L36-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:!-Tuple{Bool}" href="#Base.:!-Tuple{Bool}"><code>Base.:!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">!(x)</code></pre><p>Boolean not. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="#Base.missing"><code>missing</code></a> if <code>x</code> is <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; !true
false

julia&gt; !false
true

julia&gt; !missing
missing

julia&gt; .![true false true]
1×3 BitMatrix:
 0  1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bool.jl#L11-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:!-Tuple{Function}" href="#Base.:!-Tuple{Function}"><code>Base.:!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">!f::Function</code></pre><p>Predicate function negation: when the argument of <code>!</code> is a function, it returns a function which computes the boolean negation of <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; str = &quot;∀ ε &gt; 0, ∃ δ &gt; 0: |x-y| &lt; δ ⇒ |f(x)-f(y)| &lt; ε&quot;
&quot;∀ ε &gt; 0, ∃ δ &gt; 0: |x-y| &lt; δ ⇒ |f(x)-f(y)| &lt; ε&quot;

julia&gt; filter(isletter, str)
&quot;εδxyδfxfyε&quot;

julia&gt; filter(!isletter, str)
&quot;∀  &gt; 0, ∃  &gt; 0: |-| &lt;  ⇒ |()-()| &lt; &quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L950-L967">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:!=-Tuple{Any, Any}" href="#Base.:!=-Tuple{Any, Any}"><code>Base.:!=</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">!=(x, y)
≠(x,y)</code></pre><p>Not-equals comparison operator. Always gives the opposite answer as <a href="#Base.:=="><code>==</code></a>.</p><p><strong>Implementation</strong></p><p>New types should generally not implement this, and rely on the fallback definition <code>!=(x,y) = !(x==y)</code> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 3 != 2
true

julia&gt; &quot;foo&quot; ≠ &quot;foo&quot;
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L185-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:!=-Tuple{Any}" href="#Base.:!=-Tuple{Any}"><code>Base.:!=</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">!=(x)</code></pre><p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:!=-Tuple{Any, Any}"><code>!=</code></a>, i.e. a function equivalent to <code>y -&gt; y != x</code>. The returned function is of type <code>Base.Fix2{typeof(!=)}</code>, which can be used to implement specialized methods.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1026-L1036">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:!==-Tuple{Any, Any}" href="#Base.:!==-Tuple{Any, Any}"><code>Base.:!==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">!==(x, y)
≢(x,y)</code></pre><p>Always gives the opposite answer as <a href="#Core.:==="><code>===</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1, 2]; b = [1, 2];

julia&gt; a ≢ b
true

julia&gt; a ≢ a
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L234-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&amp;-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}" href="#Base.:&amp;-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}"><code>Base.:&amp;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x &amp; y</code></pre><p>Bitwise and. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="#Base.missing"><code>missing</code></a> if one operand is <code>missing</code> and the other is <code>true</code>. Add parentheses for function application form: <code>(&amp;)(x, y)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 4 &amp; 10
0

julia&gt; 4 &amp; 12
4

julia&gt; true &amp; missing
missing

julia&gt; false &amp; missing
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L287-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Union{AbstractChar, AbstractString}, Vararg{Union{AbstractChar, AbstractString}, N} where N}" href="#Base.:*-Tuple{Union{AbstractChar, AbstractString}, Vararg{Union{AbstractChar, AbstractString}, N} where N}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -&gt; AbstractString</code></pre><p>Concatenate strings and/or characters, producing a <a href="#Core.String-Tuple{AbstractString}"><code>String</code></a>. This is equivalent to calling the <a href="#Base.string-Tuple"><code>string</code></a> function on the arguments. Concatenation of built-in string types always produces a value of type <code>String</code> but other string types may choose to return a string of a different type as appropriate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; &quot;Hello &quot; * &quot;world&quot;
&quot;Hello world&quot;

julia&gt; &#39;j&#39; * &quot;ulia&quot;
&quot;julia&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L243-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Union{Regex, AbstractChar, AbstractString}, Vararg{Union{Regex, AbstractChar, AbstractString}, N} where N}" href="#Base.:*-Tuple{Union{Regex, AbstractChar, AbstractString}, Vararg{Union{Regex, AbstractChar, AbstractString}, N} where N}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(s::Regex, t::Union{Regex,AbstractString,AbstractChar}) -&gt; Regex
*(s::Union{Regex,AbstractString,AbstractChar}, t::Regex) -&gt; Regex</code></pre><p>Concatenate regexes, strings and/or characters, producing a <a href="#Base.Regex"><code>Regex</code></a>. String and character arguments must be matched exactly in the resulting regex, meaning that the contained characters are devoid of any special meaning (they are quoted with &quot;\Q&quot; and &quot;\E&quot;).</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; match(r&quot;Hello|Good bye&quot; * &#39; &#39; * &quot;world&quot;, &quot;Hello world&quot;)
RegexMatch(&quot;Hello world&quot;)

julia&gt; r = r&quot;a|b&quot; * &quot;c|d&quot;
r&quot;(?:a|b)\Qc|d\E&quot;

julia&gt; match(r, &quot;ac&quot;) == nothing
true

julia&gt; match(r, &quot;ac|d&quot;)
RegexMatch(&quot;ac|d&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L658-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.://-Tuple{Integer, Integer}" href="#Base.://-Tuple{Integer, Integer}"><code>Base.://</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">//(num, den)</code></pre><p>Divide two integers or rational numbers, giving a <a href="#Base.Rational"><code>Rational</code></a> result.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 3 // 5
3//5

julia&gt; (3 // 5) // (2 // 1)
3//10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/rational.jl#L48-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.::-Union{Tuple{T}, Tuple{T, Any, T}} where T" href="#Base.::-Union{Tuple{T}, Tuple{T, Any, T}} where T"><code>Base.::</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(:)(start, [step], stop)</code></pre><p>Range operator. <code>a:b</code> constructs a range from <code>a</code> to <code>b</code> with a step size of 1 (a <a href="#Base.UnitRange"><code>UnitRange</code></a>) , and <code>a:s:b</code> is similar but uses a step size of <code>s</code> (a <a href="#Base.StepRange"><code>StepRange</code></a>).</p><p><code>:</code> is also used in indexing to select whole dimensions  and for <a href="@ref"><code>Symbol</code></a> literals, as in e.g. <code>:hello</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L31-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;-Tuple{Any, Any}" href="#Base.:&lt;-Tuple{Any, Any}"><code>Base.:&lt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&lt;(x, y)</code></pre><p>Less-than comparison operator. Falls back to <a href="#Base.isless"><code>isless</code></a>. Because of the behavior of floating-point NaN values, this operator implements a partial order.</p><p><strong>Implementation</strong></p><p>New numeric types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement <a href="#Base.isless"><code>isless</code></a> instead. (x &lt; y) | (x == y)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; &#39;a&#39; &lt; &#39;b&#39;
true

julia&gt; &quot;abc&quot; &lt; &quot;abd&quot;
true

julia&gt; 5 &lt; 3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L254-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;-Tuple{Any}" href="#Base.:&lt;-Tuple{Any}"><code>Base.:&lt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&lt;(x)</code></pre><p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:&lt;-Tuple{Any, Any}"><code>&lt;</code></a>, i.e. a function equivalent to <code>y -&gt; y &lt; x</code>. The returned function is of type <code>Base.Fix2{typeof(&lt;)}</code>, which can be used to implement specialized methods.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1078-L1088">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;&lt;-Tuple{BitVector, Int64}" href="#Base.:&lt;&lt;-Tuple{BitVector, Int64}"><code>Base.:&lt;&lt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&lt;&lt;(B::BitVector, n) -&gt; BitVector</code></pre><p>Left bit shift operator, <code>B &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>B</code> with elements shifted <code>n</code> positions backwards, filling with <code>false</code> values. If <code>n &lt; 0</code>, elements are shifted forwards. Equivalent to <code>B &gt;&gt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = BitVector([true, false, true, false, false])
5-element BitVector:
 1
 0
 1
 0
 0

julia&gt; B &lt;&lt; 1
5-element BitVector:
 0
 1
 0
 0
 0

julia&gt; B &lt;&lt; -1
5-element BitVector:
 0
 1
 0
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bitarray.jl#L1321-L1355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;&lt;-Tuple{Integer, Integer}" href="#Base.:&lt;&lt;-Tuple{Integer, Integer}"><code>Base.:&lt;&lt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&lt;&lt;(x, n)</code></pre><p>Left bit shift operator, <code>x &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted left by <code>n</code> bits, filling with <code>0</code>s. This is equivalent to <code>x * 2^n</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &gt;&gt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Int8(3) &lt;&lt; 2
12

julia&gt; bitstring(Int8(3))
&quot;00000011&quot;

julia&gt; bitstring(Int8(12))
&quot;00001100&quot;</code></pre><p>See also <a href="#Base.:&gt;&gt;-Tuple{BitVector, Union{Int64, UInt64}}"><code>&gt;&gt;</code></a>, <a href="#Base.:&gt;&gt;&gt;-Tuple{BitVector, Int64}"><code>&gt;&gt;&gt;</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L604-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;=-Tuple{Any, Any}" href="#Base.:&lt;=-Tuple{Any, Any}"><code>Base.:&lt;=</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&lt;=(x, y)
≤(x,y)</code></pre><p>Less-than-or-equals comparison operator. Falls back to <code>(x &lt; y) | (x == y)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; &#39;a&#39; &lt;= &#39;b&#39;
true

julia&gt; 7 ≤ 7 ≤ 9
true

julia&gt; &quot;abc&quot; ≤ &quot;abc&quot;
true

julia&gt; 5 &lt;= 3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L307-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;=-Tuple{Any}" href="#Base.:&lt;=-Tuple{Any}"><code>Base.:&lt;=</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&lt;=(x)</code></pre><p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:&lt;=-Tuple{Any, Any}"><code>&lt;=</code></a>, i.e. a function equivalent to <code>y -&gt; y &lt;= x</code>. The returned function is of type <code>Base.Fix2{typeof(&lt;=)}</code>, which can be used to implement specialized methods.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1052-L1062">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==" href="#Base.:=="><code>Base.:==</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">==(x, y)</code></pre><p>Generic equality operator. Falls back to <a href="#Core.:==="><code>===</code></a>. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, <code>==</code> is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.</p><p>This operator follows IEEE semantics for floating-point numbers: <code>0.0 == -0.0</code> and <code>NaN != NaN</code>.</p><p>The result is of type <code>Bool</code>, except when one of the operands is <a href="#Base.missing"><code>missing</code></a>, in which case <code>missing</code> is returned (<a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>). For collections, <code>missing</code> is returned if at least one of the operands contains a <code>missing</code> value and all non-missing values are equal. Use <a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a> or <a href="#Core.:==="><code>===</code></a> to always get a <code>Bool</code> result.</p><p><strong>Implementation</strong></p><p>New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.</p><p><a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a> falls back to <code>==</code>, so new methods of <code>==</code> will be used by the <a href="#Base.Dict"><code>Dict</code></a> type to compare keys. If your type will be used as a dictionary key, it should therefore also implement <a href="#Base.hash-Tuple{Any}"><code>hash</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L55-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{AbstractString, AbstractString}" href="#Base.:==-Tuple{AbstractString, AbstractString}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(a::AbstractString, b::AbstractString) -&gt; Bool</code></pre><p>Test whether two strings are equal character by character (technically, Unicode code point by code point).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; &quot;abc&quot; == &quot;abc&quot;
true

julia&gt; &quot;abc&quot; == &quot;αβγ&quot;
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L309-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Any}" href="#Base.:==-Tuple{Any}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(x)</code></pre><p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:=="><code>==</code></a>, i.e. a function equivalent to <code>y -&gt; y == x</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(==)}</code>, which can be used to implement specialized methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1015-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;-Tuple{Any, Any}" href="#Base.:&gt;-Tuple{Any, Any}"><code>Base.:&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&gt;(x, y)</code></pre><p>Greater-than comparison operator. Falls back to <code>y &lt; x</code>.</p><p><strong>Implementation</strong></p><p>Generally, new types should implement <a href="#Base.:&lt;-Tuple{Any, Any}"><code>&lt;</code></a> instead of this function, and rely on the fallback definition <code>&gt;(x, y) = y &lt; x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; &#39;a&#39; &gt; &#39;b&#39;
false

julia&gt; 7 &gt; 3 &gt; 1
true

julia&gt; &quot;abc&quot; &gt; &quot;abd&quot;
false

julia&gt; 5 &gt; 3
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L281-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;-Tuple{Any}" href="#Base.:&gt;-Tuple{Any}"><code>Base.:&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&gt;(x)</code></pre><p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:&gt;-Tuple{Any, Any}"><code>&gt;</code></a>, i.e. a function equivalent to <code>y -&gt; y &gt; x</code>. The returned function is of type <code>Base.Fix2{typeof(&gt;)}</code>, which can be used to implement specialized methods.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1065-L1075">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;:-Tuple{Any, Any}" href="#Base.:&gt;:-Tuple{Any, Any}"><code>Base.:&gt;:</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&gt;:(T1, T2)</code></pre><p>Supertype operator, equivalent to <code>T2 &lt;: T1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;=-Tuple{Any, Any}" href="#Base.:&gt;=-Tuple{Any, Any}"><code>Base.:&gt;=</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&gt;=(x, y)
≥(x,y)</code></pre><p>Greater-than-or-equals comparison operator. Falls back to <code>y &lt;= x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; &#39;a&#39; &gt;= &#39;b&#39;
false

julia&gt; 7 ≥ 7 ≥ 3
true

julia&gt; &quot;abc&quot; ≥ &quot;abc&quot;
true

julia&gt; 5 &gt;= 3
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L331-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;=-Tuple{Any}" href="#Base.:&gt;=-Tuple{Any}"><code>Base.:&gt;=</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&gt;=(x)</code></pre><p>Create a function that compares its argument to <code>x</code> using <a href="#Base.:&gt;=-Tuple{Any, Any}"><code>&gt;=</code></a>, i.e. a function equivalent to <code>y -&gt; y &gt;= x</code>. The returned function is of type <code>Base.Fix2{typeof(&gt;=)}</code>, which can be used to implement specialized methods.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This functionality requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1039-L1049">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;&gt;-Tuple{BitVector, Union{Int64, UInt64}}" href="#Base.:&gt;&gt;-Tuple{BitVector, Union{Int64, UInt64}}"><code>Base.:&gt;&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&gt;&gt;(B::BitVector, n) -&gt; BitVector</code></pre><p>Right bit shift operator, <code>B &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>B</code> with elements shifted <code>n</code> positions forward, filling with <code>false</code> values. If <code>n &lt; 0</code>, elements are shifted backwards. Equivalent to <code>B &lt;&lt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; B = BitVector([true, false, true, false, false])
5-element BitVector:
 1
 0
 1
 0
 0

julia&gt; B &gt;&gt; 1
5-element BitVector:
 0
 1
 0
 1
 0

julia&gt; B &gt;&gt; -1
5-element BitVector:
 0
 1
 0
 0
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bitarray.jl#L1283-L1317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;&gt;-Tuple{Integer, Integer}" href="#Base.:&gt;&gt;-Tuple{Integer, Integer}"><code>Base.:&gt;&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&gt;&gt;(x, n)</code></pre><p>Right bit shift operator, <code>x &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s if <code>x &gt;= 0</code>, <code>1</code>s if <code>x &lt; 0</code>, preserving the sign of <code>x</code>. This is equivalent to <code>fld(x, 2^n)</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Int8(13) &gt;&gt; 2
3

julia&gt; bitstring(Int8(13))
&quot;00001101&quot;

julia&gt; bitstring(Int8(3))
&quot;00000011&quot;

julia&gt; Int8(-14) &gt;&gt; 2
-4

julia&gt; bitstring(Int8(-14))
&quot;11110010&quot;

julia&gt; bitstring(Int8(-4))
&quot;11111100&quot;</code></pre><p>See also <a href="#Base.:&gt;&gt;&gt;-Tuple{BitVector, Int64}"><code>&gt;&gt;&gt;</code></a>, <a href="#Base.:&lt;&lt;-Tuple{BitVector, Int64}"><code>&lt;&lt;</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L639-L668">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;&gt;&gt;-Tuple{BitVector, Int64}" href="#Base.:&gt;&gt;&gt;-Tuple{BitVector, Int64}"><code>Base.:&gt;&gt;&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&gt;&gt;&gt;(B::BitVector, n) -&gt; BitVector</code></pre><p>Unsigned right bitshift operator, <code>B &gt;&gt;&gt; n</code>. Equivalent to <code>B &gt;&gt; n</code>. See <a href="#Base.:&gt;&gt;-Tuple{BitVector, Union{Int64, UInt64}}"><code>&gt;&gt;</code></a> for details and examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bitarray.jl#L1358-L1363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;&gt;&gt;-Tuple{Integer, Integer}" href="#Base.:&gt;&gt;&gt;-Tuple{Integer, Integer}"><code>Base.:&gt;&gt;&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&gt;&gt;&gt;(x, n)</code></pre><p>Unsigned right bit shift operator, <code>x &gt;&gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p><p>For <a href="@ref"><code>Unsigned</code></a> integer types, this is equivalent to <a href="#Base.:&gt;&gt;-Tuple{BitVector, Union{Int64, UInt64}}"><code>&gt;&gt;</code></a>. For <a href="@ref"><code>Signed</code></a> integer types, this is equivalent to <code>signed(unsigned(x) &gt;&gt; n)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Int8(-14) &gt;&gt;&gt; 2
60

julia&gt; bitstring(Int8(-14))
&quot;11110010&quot;

julia&gt; bitstring(Int8(60))
&quot;00111100&quot;</code></pre><p><a href="@ref"><code>BigInt</code></a>s are treated as if having infinite size, so no filling is required and this is equivalent to <a href="#Base.:&gt;&gt;-Tuple{BitVector, Union{Int64, UInt64}}"><code>&gt;&gt;</code></a>.</p><p>See also <a href="#Base.:&gt;&gt;-Tuple{BitVector, Union{Int64, UInt64}}"><code>&gt;&gt;</code></a>, <a href="#Base.:&lt;&lt;-Tuple{BitVector, Int64}"><code>&lt;&lt;</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L680-L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Tuple{Any, Any}" href="#Base.:\\-Tuple{Any, Any}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">\(x, y)</code></pre><p>Left division operator: multiplication of <code>y</code> by the inverse of <code>x</code> on the left. Gives floating-point results for integer arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 3 \ 6
2.0

julia&gt; inv(3) * 6
2.0

julia&gt; A = [4 3; 2 1]; x = [5, 6];

julia&gt; A \ x
2-element Vector{Float64}:
  6.5
 -7.0

julia&gt; inv(A) * x
2-element Vector{Float64}:
  6.5
 -7.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L571-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{Number, Number}" href="#Base.:^-Tuple{Number, Number}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(x, y)</code></pre><p>Exponentiation operator. If <code>x</code> is a matrix, computes matrix exponentiation.</p><p>If <code>y</code> is an <code>Int</code> literal (e.g. <code>2</code> in <code>x^2</code> or <code>-3</code> in <code>x^-3</code>), the Julia code <code>x^y</code> is transformed by the compiler to <code>Base.literal_pow(^, x, Val(y))</code>, to enable compile-time specialization on the value of the exponent. (As a default fallback we have <code>Base.literal_pow(^, x, Val(y)) = ^(x,y)</code>, where usually <code>^ == Base.^</code> unless <code>^</code> has been defined in the calling namespace.) If <code>y</code> is a negative integer literal, then <code>Base.literal_pow</code> transforms the operation to <code>inv(x)^-y</code> by default, where <code>-y</code> is positive.</p><pre><code class="language-julia-repl hljs">julia&gt; 3^5
243

julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; A^3
2×2 Matrix{Int64}:
 37   54
 81  118</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/promotion.jl#L326-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{Regex, Integer}" href="#Base.:^-Tuple{Regex, Integer}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(s::Regex, n::Integer)</code></pre><p>Repeat a regex <code>n</code> times.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r&quot;Test &quot;^2
r&quot;(?:Test ){2}&quot;

julia&gt; match(r&quot;Test &quot;^2, &quot;Test Test &quot;)
RegexMatch(&quot;Test Test &quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L741-L757">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}" href="#Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(s::Union{AbstractString,AbstractChar}, n::Integer)</code></pre><p>Repeat a string or character <code>n</code> times. This can also be written as <code>repeat(s, n)</code>.</p><p>See also: <a href="#Base.repeat-Tuple{AbstractArray, Vararg{Any, N} where N}"><code>repeat</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; &quot;Test &quot;^3
&quot;Test Test Test &quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L705-L717">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:|-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}" href="#Base.:|-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}"><code>Base.:|</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x | y</code></pre><p>Bitwise or. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="#Base.missing"><code>missing</code></a> if one operand is <code>missing</code> and the other is <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 4 | 10
14

julia&gt; 4 | 1
5

julia&gt; true | missing
true

julia&gt; false | missing
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L311-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:|&gt;-Tuple{Any, Any}" href="#Base.:|&gt;-Tuple{Any, Any}"><code>Base.:|&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">|&gt;(x, f)</code></pre><p>Applies a function to the preceding argument. This allows for easy function chaining.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; [1:5;] |&gt; x-&gt;x.^2 |&gt; sum |&gt; inv
0.01818181818181818</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L847-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:~-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}" href="#Base.:~-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}"><code>Base.:~</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">~(x)</code></pre><p>Bitwise not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ~4
-5

julia&gt; ~10
-11

julia&gt; ~true
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L268-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∉" href="#Base.:∉"><code>Base.:∉</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∉(item, collection) -&gt; Bool
∌(collection, item) -&gt; Bool</code></pre><p>Negation of <code>∈</code> and <code>∋</code>, i.e. checks that <code>item</code> is not in <code>collection</code>.</p><p>When broadcasting with <code>items .∉ collection</code>, both <code>item</code> and <code>collection</code> are broadcasted over, which is often not what is intended. For example, if both arguments are vectors (and the dimensions match), the result is a vector indicating whether each value in collection <code>items</code> is not in the value at the corresponding position in <code>collection</code>. To get a vector indicating whether each value in <code>items</code> is not in <code>collection</code>, wrap <code>collection</code> in a tuple or a <code>Ref</code> like this: <code>items .∉ Ref(collection)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 1 ∉ 2:4
true

julia&gt; 1 ∉ 1:3
false

julia&gt; [1, 2] .∉ [2, 3]
2-element BitVector:
 1
 1

julia&gt; [1, 2] .∉ ([2, 3],)
2-element BitVector:
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1239-L1271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∋-Tuple{Any, Any}" href="#Base.:∋-Tuple{Any, Any}"><code>Base.:∋</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∋(collection, item) -&gt; Bool</code></pre><p>Like <a href="#Base.in"><code>in</code></a>, but with arguments in reverse order. Avoid adding methods to this function; define <code>in</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1146-L1151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∋-Tuple{Any}" href="#Base.:∋-Tuple{Any}"><code>Base.:∋</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">∋(item)</code></pre><p>Create a function that checks whether its argument contains the given <code>item</code>, i.e. a function equivalent to <code>y -&gt; item in y</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This method requires Julia 1.6 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1154-L1162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∌" href="#Base.:∌"><code>Base.:∌</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">∉(item, collection) -&gt; Bool
∌(collection, item) -&gt; Bool</code></pre><p>Negation of <code>∈</code> and <code>∋</code>, i.e. checks that <code>item</code> is not in <code>collection</code>.</p><p>When broadcasting with <code>items .∉ collection</code>, both <code>item</code> and <code>collection</code> are broadcasted over, which is often not what is intended. For example, if both arguments are vectors (and the dimensions match), the result is a vector indicating whether each value in collection <code>items</code> is not in the value at the corresponding position in <code>collection</code>. To get a vector indicating whether each value in <code>items</code> is not in <code>collection</code>, wrap <code>collection</code> in a tuple or a <code>Ref</code> like this: <code>items .∉ Ref(collection)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 1 ∉ 2:4
true

julia&gt; 1 ∉ 1:3
false

julia&gt; [1, 2] .∉ [2, 3]
2-element BitVector:
 1
 1

julia&gt; [1, 2] .∉ ([2, 3],)
2-element BitVector:
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1239-L1271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘" href="#Base.:∘"><code>Base.:∘</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">f ∘ g</code></pre><p>Compose functions: i.e. <code>(f ∘ g)(args...)</code> means <code>f(g(args...))</code>. The <code>∘</code> symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing <code>\circ&lt;tab&gt;</code>.</p><p>Function composition also works in prefix form: <code>∘(f, g)</code> is the same as <code>f ∘ g</code>. The prefix form supports composition of multiple functions: <code>∘(f, g, h) = f ∘ g ∘ h</code> and splatting <code>∘(fs...)</code> for composing an iterable collection of functions.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>Multiple function composition requires at least Julia 1.4.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Composition of one function ∘(f)  requires at least Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; map(uppercase∘first, [&quot;apple&quot;, &quot;banana&quot;, &quot;carrot&quot;])
3-element Vector{Char}:
 &#39;A&#39;: ASCII/Unicode U+0041 (category Lu: Letter, uppercase)
 &#39;B&#39;: ASCII/Unicode U+0042 (category Lu: Letter, uppercase)
 &#39;C&#39;: ASCII/Unicode U+0043 (category Lu: Letter, uppercase)

julia&gt; fs = [
           x -&gt; 2x
           x -&gt; x/2
           x -&gt; x-1
           x -&gt; x+1
       ];

julia&gt; ∘(fs...)(3)
3.0</code></pre><p>See also <a href="#Base.ComposedFunction"><code>ComposedFunction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L862-L897">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:≉-Tuple" href="#Base.:≉-Tuple"><code>Base.:≉</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x ≉ y</code></pre><p>This is equivalent to <code>!isapprox(x,y)</code> (see <a href="#Base.isapprox-Tuple{Any}"><code>isapprox</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/floatfuncs.jl#L294-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">issubset(a, b) -&gt; Bool
⊆(a, b) -&gt; Bool
⊇(b, a) -&gt; Bool</code></pre><p>Determine whether every element of <code>a</code> is also in <code>b</code>, using <a href="#Base.in"><code>in</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; issubset([1, 2], [1, 2, 3])
true

julia&gt; [1, 2, 3] ⊆ [1, 2]
false

julia&gt; [1, 2, 3] ⊇ [1, 2]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L246-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊇" href="#Base.:⊇"><code>Base.:⊇</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">issubset(a, b) -&gt; Bool
⊆(a, b) -&gt; Bool
⊇(b, a) -&gt; Bool</code></pre><p>Determine whether every element of <code>a</code> is also in <code>b</code>, using <a href="#Base.in"><code>in</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; issubset([1, 2], [1, 2, 3])
true

julia&gt; [1, 2, 3] ⊆ [1, 2]
false

julia&gt; [1, 2, 3] ⊇ [1, 2]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L246-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊈" href="#Base.:⊈"><code>Base.:⊈</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">⊈(a, b) -&gt; Bool
⊉(b, a) -&gt; Bool</code></pre><p>Negation of <code>⊆</code> and <code>⊇</code>, i.e. checks that <code>a</code> is not a subset of <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (1, 2) ⊈ (2, 3)
true

julia&gt; (1, 2) ⊈ (1, 2, 3)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L330-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊉" href="#Base.:⊉"><code>Base.:⊉</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">⊈(a, b) -&gt; Bool
⊉(b, a) -&gt; Bool</code></pre><p>Negation of <code>⊆</code> and <code>⊇</code>, i.e. checks that <code>a</code> is not a subset of <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (1, 2) ⊈ (2, 3)
true

julia&gt; (1, 2) ⊈ (1, 2, 3)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L330-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊊" href="#Base.:⊊"><code>Base.:⊊</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">⊊(a, b) -&gt; Bool
⊋(b, a) -&gt; Bool</code></pre><p>Determines if <code>a</code> is a subset of, but not equal to, <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (1, 2) ⊊ (1, 2, 3)
true

julia&gt; (1, 2) ⊊ (1, 2)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L307-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊋" href="#Base.:⊋"><code>Base.:⊋</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">⊊(a, b) -&gt; Bool
⊋(b, a) -&gt; Bool</code></pre><p>Determines if <code>a</code> is a subset of, but not equal to, <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; (1, 2) ⊊ (1, 2, 3)
true

julia&gt; (1, 2) ⊊ (1, 2)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L307-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Libc.getpid-Tuple{Base.Process}" href="#Base.Libc.getpid-Tuple{Base.Process}"><code>Base.Libc.getpid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getpid(process) -&gt; Int32</code></pre><p>Get the child process ID, if it still exists.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L564-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.MainInclude.eval" href="#Base.MainInclude.eval"><code>Base.MainInclude.eval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval(expr)</code></pre><p>Evaluate an expression in the global scope of the containing module. Every <code>Module</code> (except those defined with <code>baremodule</code>) has its own 1-argument definition of <code>eval</code>, which evaluates expressions in that module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/client.jl#L449-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.MainInclude.include" href="#Base.MainInclude.include"><code>Base.MainInclude.include</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">include([mapexpr::Function,] path::AbstractString)</code></pre><p>Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with <code>baremodule</code>) has its own definition of <code>include</code>, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to <code>include</code> will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</p><p>The optional first argument <code>mapexpr</code> can be used to transform the included code before it is evaluated: for each parsed expression <code>expr</code> in <code>path</code>, the <code>include</code> function actually evaluates <code>mapexpr(expr)</code>.  If it is omitted, <code>mapexpr</code> defaults to <a href="#Base.identity-Tuple{Any}"><code>identity</code></a>.</p><p>Use <a href="#Base.include"><code>Base.include</code></a> to evaluate a file into another module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/client.jl#L458-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.PipeBuffer" href="#Base.PipeBuffer"><code>Base.PipeBuffer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PipeBuffer(data::Vector{UInt8}=UInt8[]; maxsize::Integer = typemax(Int))</code></pre><p>An <a href="#Base.IOBuffer-Tuple{AbstractVector{UInt8}}"><code>IOBuffer</code></a> that allows reading and performs writes by appending. Seeking and truncating are not supported. See <a href="#Base.IOBuffer-Tuple{AbstractVector{UInt8}}"><code>IOBuffer</code></a> for the available constructors. If <code>data</code> is given, creates a <code>PipeBuffer</code> to operate on a data vector, optionally specifying a size beyond which the underlying <code>Array</code> may not be grown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iobuffer.jl#L127-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.SecretBuffer!-Tuple{Vector{UInt8}}" href="#Base.SecretBuffer!-Tuple{Vector{UInt8}}"><code>Base.SecretBuffer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SecretBuffer!(data::Vector{UInt8})</code></pre><p>Initialize a new <code>SecretBuffer</code> from <code>data</code>, securely zeroing <code>data</code> afterwards.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/secretbuffer.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Threads.foreach-Tuple{Any, Channel}" href="#Base.Threads.foreach-Tuple{Any, Channel}"><code>Base.Threads.foreach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Threads.foreach(f, channel::Channel;
                schedule::Threads.AbstractSchedule=Threads.FairSchedule(),
                ntasks=Threads.nthreads())</code></pre><p>Similar to <code>foreach(f, channel)</code>, but iteration over <code>channel</code> and calls to <code>f</code> are split across <code>ntasks</code> tasks spawned by <code>Threads.@spawn</code>. This function will wait for all internally spawned tasks to complete before returning.</p><p>If <code>schedule isa FairSchedule</code>, <code>Threads.foreach</code> will attempt to spawn tasks in a manner that enables Julia&#39;s scheduler to more freely load-balance work items across threads. This approach generally has higher per-item overhead, but may perform better than <code>StaticSchedule</code> in concurrence with other multithreaded workloads.</p><p>If <code>schedule isa StaticSchedule</code>, <code>Threads.foreach</code> will spawn tasks in a manner that incurs lower per-item overhead than <code>FairSchedule</code>, but is less amenable to load-balancing. This approach thus may be more suitable for fine-grained, uniform workloads, but may perform worse than <code>FairSchedule</code> in concurrence with other multithreaded workloads.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This function requires Julia 1.6 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/threads_overloads.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.__precompile__" href="#Base.__precompile__"><code>Base.__precompile__</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">__precompile__(isprecompilable::Bool)</code></pre><p>Specify whether the file calling this function is precompilable, defaulting to <code>true</code>. If a module or file is <em>not</em> safely precompilable, it should call <code>__precompile__(false)</code> in order to throw an error if Julia attempts to precompile it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L846-L852">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base._show_nonempty-Tuple{IO, AbstractMatrix{T} where T, String}" href="#Base._show_nonempty-Tuple{IO, AbstractMatrix{T} where T, String}"><code>Base._show_nonempty</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_show_nonempty(io, X::AbstractMatrix, prefix)</code> prints matrix X with opening and closing square brackets, preceded by <code>prefix</code>, supposed to encode the type of the elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arrayshow.jl#L378-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base._xfadjoint-Tuple{Any, Any}" href="#Base._xfadjoint-Tuple{Any, Any}"><code>Base._xfadjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_xfadjoint(op, itr) -&gt; op′, itr′</code></pre><p>Given a pair of reducing function <code>op</code> and an iterator <code>itr</code>, return a pair <code>(op′, itr′)</code> of similar types.  If the iterator <code>itr</code> is transformed by an iterator transform <code>ixf</code> whose adjoint transducer <code>xf</code> is known, <code>op′ = xf(op)</code> and <code>itr′ = ixf⁻¹(itr)</code> is returned.  Otherwise, <code>op</code> and <code>itr</code> are returned as-is.  For example, transducer <code>rf -&gt; MappingRF(f, rf)</code> is the adjoint of iterator transform <code>itr -&gt; Generator(f, itr)</code>.</p><p>Nested iterator transforms are converted recursively.  That is to say, given <code>op</code> and</p><pre><code class="nohighlight hljs">itr = (ixf₁ ∘ ixf₂ ∘ ... ∘ ixfₙ)(itr′)</code></pre><p>what is returned is <code>itr′</code> and</p><pre><code class="nohighlight hljs">op′ = (xfₙ ∘ ... ∘ xf₂ ∘ xf₁)(op)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L122-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs" href="#Base.abs"><code>Base.abs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abs(x)</code></pre><p>The absolute value of <code>x</code>.</p><p>When <code>abs</code> is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when <code>abs</code> is applied to the minimum representable value of a signed integer. That is, when <code>x == typemin(typeof(x))</code>, <code>abs(x) == x &lt; 0</code>, not <code>-x</code> as might be expected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; abs(-3)
3

julia&gt; abs(1 + im)
1.4142135623730951

julia&gt; abs(typemin(Int64))
-9223372036854775808</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L144-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.abs2-Tuple{Real}" href="#Base.abs2-Tuple{Real}"><code>Base.abs2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs2(x)</code></pre><p>Squared absolute value of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; abs2(-3)
9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L140-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.accumulate!-Tuple{Any, Any, Any}" href="#Base.accumulate!-Tuple{Any, Any, Any}"><code>Base.accumulate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">accumulate!(op, B, A; [dims], [init])</code></pre><p>Cumulative operation <code>op</code> on <code>A</code> along the dimension <code>dims</code>, storing the result in <code>B</code>. Providing <code>dims</code> is optional for vectors.  If the keyword argument <code>init</code> is given, its value is used to instantiate the accumulation. See also <a href="#Base.accumulate-Tuple{Any, Any}"><code>accumulate</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1, 0, 2, 0, 3];

julia&gt; y = [0, 0, 0, 0, 0];

julia&gt; accumulate!(+, y, x);

julia&gt; y
5-element Vector{Int64}:
 1
 1
 3
 3
 6

julia&gt; A = [1 2; 3 4];

julia&gt; B = [0 0; 0 0];

julia&gt; accumulate!(-, B, A, dims=1);

julia&gt; B
2×2 Matrix{Int64}:
  1   2
 -2  -2

julia&gt; accumulate!(-, B, A, dims=2);

julia&gt; B
2×2 Matrix{Int64}:
 1  -1
 3  -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/accumulate.jl#L314-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.accumulate-Tuple{Any, Any}" href="#Base.accumulate-Tuple{Any, Any}"><code>Base.accumulate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">accumulate(op, A; dims::Integer, [init])</code></pre><p>Cumulative operation <code>op</code> along the dimension <code>dims</code> of <code>A</code> (providing <code>dims</code> is optional for vectors). An initial value <code>init</code> may optionally be provided by a keyword argument. See also <a href="#Base.accumulate!-Tuple{Any, Any, Any}"><code>accumulate!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of <code>accumulate</code>, see: <a href="#Base.cumsum-Tuple{AbstractVector{T} where T}"><code>cumsum</code></a>, <a href="#Base.cumprod-Tuple{AbstractArray}"><code>cumprod</code></a></p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>accumulate</code> on a non-array iterator requires at least Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; accumulate(+, [1,2,3])
3-element Vector{Int64}:
 1
 3
 6

julia&gt; accumulate(*, [1,2,3])
3-element Vector{Int64}:
 1
 2
 6

julia&gt; accumulate(+, [1,2,3]; init=100)
3-element Vector{Int64}:
 101
 103
 106

julia&gt; accumulate(min, [1,2,-1]; init=0)
3-element Vector{Int64}:
  0
  0
 -1

julia&gt; accumulate(+, fill(1, 3, 3), dims=1)
3×3 Matrix{Int64}:
 1  1  1
 2  2  2
 3  3  3

julia&gt; accumulate(+, fill(1, 3, 3), dims=2)
3×3 Matrix{Int64}:
 1  2  3
 1  2  3
 1  2  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/accumulate.jl#L238-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.acquire-Tuple{Base.Semaphore}" href="#Base.acquire-Tuple{Base.Semaphore}"><code>Base.acquire</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acquire(s::Semaphore)</code></pre><p>Wait for one of the <code>sem_size</code> permits to be available, blocking until one can be acquired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/lock.jl#L279-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.active_project" href="#Base.active_project"><code>Base.active_project</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">active_project()</code></pre><p>Return the path of the active <code>Project.toml</code> file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/initdefs.jl#L281-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.add12-Union{Tuple{T}, Tuple{T, T}} where T" href="#Base.add12-Union{Tuple{T}, Tuple{T, T}} where T"><code>Base.add12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zhi, zlo = add12(x, y)</code></pre><p>A high-precision representation of <code>x + y</code> for floating-point numbers. Mathematically, <code>zhi + zlo = x + y</code>, where <code>zhi</code> contains the most significant bits and <code>zlo</code> the least significant.</p><p>Because of the way floating-point numbers are printed, <code>lo</code> may not look the way you might expect from the standpoint of decimal representation, even though it is exact from the standpoint of binary representation.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; 1.0 + 1.0001e-15
1.000000000000001

julia&gt; big(1.0) + big(1.0001e-15)
1.000000000000001000100000000000020165767380775934141445417482375879192346701529

julia&gt; hi, lo = Base.add12(1.0, 1.0001e-15)
(1.000000000000001, -1.1012302462515652e-16)

julia&gt; big(hi) + big(lo)
1.000000000000001000100000000000020165767380775934141445417482375879192346701529</code></pre><p><code>lo</code> differs from 1.0e-19 because <code>hi</code> is not exactly equal to the first 16 decimal digits of the answer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/twiceprecision.jl#L53-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.add_sum-Tuple{Any, Any}" href="#Base.add_sum-Tuple{Any, Any}"><code>Base.add_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.add_sum(x, y)</code></pre><p>The reduction operator used in <code>sum</code>. The main difference from <a href="@ref"><code>+</code></a> is that small integers are promoted to <code>Int</code>/<code>UInt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.addenv-Tuple{Cmd, Dict}" href="#Base.addenv-Tuple{Cmd, Dict}"><code>Base.addenv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addenv(command::Cmd, env...; inherit::Bool = true)</code></pre><p>Merge new environment mappings into the given <code>Cmd</code> object, returning a new <code>Cmd</code> object. Duplicate keys are replaced.  If <code>command</code> does not contain any environment values set already, it inherits the current environment at time of <code>addenv()</code> call if <code>inherit</code> is <code>true</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This function requires Julia 1.6 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/cmd.jl#L248-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.alignment-Tuple{IO, Any}" href="#Base.alignment-Tuple{IO, Any}"><code>Base.alignment</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>alignment(io, X)</code> returns a tuple (left,right) showing how many characters are needed on either side of an alignment feature such as a decimal point.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.alignment(stdout, 42)
(2, 0)

julia&gt; Base.alignment(stdout, 4.23)
(1, 3)

julia&gt; Base.alignment(stdout, 1 + 10im)
(3, 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L2562-L2577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.alignment-Union{Tuple{V}, Tuple{T}, Tuple{IO, AbstractVecOrMat{T} where T, AbstractVector{T}, AbstractVector{V}, Integer, Integer, Integer}} where {T, V}" href="#Base.alignment-Union{Tuple{V}, Tuple{T}, Tuple{IO, AbstractVecOrMat{T} where T, AbstractVector{T}, AbstractVector{V}, Integer, Integer, Integer}} where {T, V}"><code>Base.alignment</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>alignment(io, X, rows, cols, cols_if_complete, cols_otherwise, sep)</code> returns the alignment for specified parts of array <code>X</code>, returning the (left,right) info. It will look in X&#39;s <code>rows</code>, <code>cols</code> (both lists of indices) and figure out what&#39;s needed to be fully aligned, for example looking all the way down a column and finding out the maximum size of each element. Parameter <code>sep::Integer</code> is number of spaces to put between elements. <code>cols_if_complete</code> and <code>cols_otherwise</code> indicate screen width to use. Alignment is reported as a vector of (left,right) tuples, one for each column going across the screen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arrayshow.jl#L49-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.all!-Tuple{Any, Any}" href="#Base.all!-Tuple{Any, Any}"><code>Base.all!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all!(r, A)</code></pre><p>Test whether all values in <code>A</code> along the singleton dimensions of <code>r</code> are <code>true</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true false; true false]
2×2 Matrix{Bool}:
 1  0
 1  0

julia&gt; all!([1; 1], A)
2-element Vector{Int64}:
 0
 0

julia&gt; all!([1 1], A)
1×2 Matrix{Int64}:
 1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L772-L793">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.all-Tuple{AbstractArray}" href="#Base.all-Tuple{AbstractArray}"><code>Base.all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all(A; dims)</code></pre><p>Test whether all values along the given dimensions of an array are <code>true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true false; true true]
2×2 Matrix{Bool}:
 1  0
 1  1

julia&gt; all(A, dims=1)
1×2 Matrix{Bool}:
 1  0

julia&gt; all(A, dims=2)
2×1 Matrix{Bool}:
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L724-L745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.all-Tuple{Any, Any}" href="#Base.all-Tuple{Any, Any}"><code>Base.all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all(p, itr) -&gt; Bool</code></pre><p>Determine whether predicate <code>p</code> returns <code>true</code> for all elements of <code>itr</code>, returning <code>false</code> as soon as the first item in <code>itr</code> for which <code>p</code> returns <code>false</code> is encountered (short-circuiting).</p><p>If the input contains <a href="#Base.missing"><code>missing</code></a> values, return <code>missing</code> if all non-missing values are <code>true</code> (or equivalently, if the input contains no <code>false</code> value), following <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; all(i-&gt;(4&lt;=i&lt;=6), [4,5,6])
true

julia&gt; all(i -&gt; (println(i); i &lt; 3), 1:10)
1
2
3
false

julia&gt; all(i -&gt; i &gt; 0, [1, missing])
missing

julia&gt; all(i -&gt; i &gt; 0, [-1, missing])
false

julia&gt; all(i -&gt; i &gt; 0, [1, 2])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L886-L917">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.all-Tuple{Any}" href="#Base.all-Tuple{Any}"><code>Base.all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all(itr) -&gt; Bool</code></pre><p>Test whether all elements of a boolean collection are <code>true</code>, returning <code>false</code> as soon as the first <code>false</code> value in <code>itr</code> is encountered (short-circuiting).</p><p>If the input contains <a href="#Base.missing"><code>missing</code></a> values, return <code>missing</code> if all non-missing values are <code>true</code> (or equivalently, if the input contains no <code>false</code> value), following <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [true,false,false,true]
4-element Vector{Bool}:
 1
 0
 0
 1

julia&gt; all(a)
false

julia&gt; all((println(i); v) for (i, v) in enumerate(a))
1
2
false

julia&gt; all([missing, false])
false

julia&gt; all([true, missing])
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L802-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.all-Tuple{Function, AbstractArray}" href="#Base.all-Tuple{Function, AbstractArray}"><code>Base.all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all(p, A; dims)</code></pre><p>Determine whether predicate p returns true for all elements along the given dimensions of an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 -1; 2 2]
2×2 Matrix{Int64}:
 1  -1
 2   2

julia&gt; all(i -&gt; i &gt; 0, A, dims=1)
1×2 Matrix{Bool}:
 1  0

julia&gt; all(i -&gt; i &gt; 0, A, dims=2)
2×1 Matrix{Bool}:
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L748-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.allunique-Tuple{Any}" href="#Base.allunique-Tuple{Any}"><code>Base.allunique</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allunique(itr) -&gt; Bool</code></pre><p>Return <code>true</code> if all values from <code>itr</code> are distinct when compared with <a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1; 2; 3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; allunique([a, a])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/set.jl#L367-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Tuple{Complex}" href="#Base.angle-Tuple{Complex}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angle(z)</code></pre><p>Compute the phase angle in radians of a complex number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rad2deg(angle(1 + im))
45.0

julia&gt; rad2deg(angle(1 - im))
-45.0

julia&gt; rad2deg(angle(-1 - im))
-135.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L568-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.any!-Tuple{Any, Any}" href="#Base.any!-Tuple{Any, Any}"><code>Base.any!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">any!(r, A)</code></pre><p>Test whether any values in <code>A</code> along the singleton dimensions of <code>r</code> are <code>true</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true false; true false]
2×2 Matrix{Bool}:
 1  0
 1  0

julia&gt; any!([1; 1], A)
2-element Vector{Int64}:
 1
 1

julia&gt; any!([1 1], A)
1×2 Matrix{Int64}:
 1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L844-L866">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.any-Tuple{AbstractArray}" href="#Base.any-Tuple{AbstractArray}"><code>Base.any</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">any(A; dims)</code></pre><p>Test whether any values along the given dimensions of an array are <code>true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true false; true false]
2×2 Matrix{Bool}:
 1  0
 1  0

julia&gt; any(A, dims=1)
1×2 Matrix{Bool}:
 1  0

julia&gt; any(A, dims=2)
2×1 Matrix{Bool}:
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L796-L817">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.any-Tuple{Any, Any}" href="#Base.any-Tuple{Any, Any}"><code>Base.any</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">any(p, itr) -&gt; Bool</code></pre><p>Determine whether predicate <code>p</code> returns <code>true</code> for any elements of <code>itr</code>, returning <code>true</code> as soon as the first item in <code>itr</code> for which <code>p</code> returns <code>true</code> is encountered (short-circuiting).</p><p>If the input contains <a href="#Base.missing"><code>missing</code></a> values, return <code>missing</code> if all non-missing values are <code>false</code> (or equivalently, if the input contains no <code>true</code> value), following <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; any(i-&gt;(4&lt;=i&lt;=6), [3,5,7])
true

julia&gt; any(i -&gt; (println(i); i &gt; 3), 1:10)
1
2
3
4
true

julia&gt; any(i -&gt; i &gt; 0, [1, missing])
true

julia&gt; any(i -&gt; i &gt; 0, [-1, missing])
missing

julia&gt; any(i -&gt; i &gt; 0, [-1, 0])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L838-L870">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.any-Tuple{Any}" href="#Base.any-Tuple{Any}"><code>Base.any</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">any(itr) -&gt; Bool</code></pre><p>Test whether any elements of a boolean collection are <code>true</code>, returning <code>true</code> as soon as the first <code>true</code> value in <code>itr</code> is encountered (short-circuiting).</p><p>If the input contains <a href="#Base.missing"><code>missing</code></a> values, return <code>missing</code> if all non-missing values are <code>false</code> (or equivalently, if the input contains no <code>true</code> value), following <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [true,false,false,true]
4-element Vector{Bool}:
 1
 0
 0
 1

julia&gt; any(a)
true

julia&gt; any((println(i); v) for (i, v) in enumerate(a))
1
true

julia&gt; any([missing, true])
true

julia&gt; any([false, missing])
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L767-L799">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.any-Tuple{Function, AbstractArray}" href="#Base.any-Tuple{Function, AbstractArray}"><code>Base.any</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">any(p, A; dims)</code></pre><p>Determine whether predicate p returns true for any elements along the given dimensions of an array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 -1; 2 -2]
2×2 Matrix{Int64}:
 1  -1
 2  -2

julia&gt; any(i -&gt; i &gt; 0, A, dims=1)
1×2 Matrix{Bool}:
 1  0

julia&gt; any(i -&gt; i &gt; 0, A, dims=2)
2×1 Matrix{Bool}:
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L820-L841">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.append!-Tuple{Vector{T} where T, AbstractVector{T} where T}" href="#Base.append!-Tuple{Vector{T} where T, AbstractVector{T} where T}"><code>Base.append!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append!(collection, collections...) -&gt; collection.</code></pre><p>For an ordered container <code>collection</code>, add the elements of each <code>collections</code> to the end of it.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Specifying multiple collections to be appended requires at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; append!([1], [2, 3])
3-element Vector{Int64}:
 1
 2
 3

julia&gt; append!([1, 2, 3], [4, 5], [6])
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre><p>Use <a href="#Base.push!"><code>push!</code></a> to add individual items to <code>collection</code> which are not already themselves in another collection. The result of the preceding example is equivalent to <code>push!([1, 2, 3], 4, 5, 6)</code>.</p><p>See <a href="#Base.sizehint!"><code>sizehint!</code></a> for notes about the performance model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L940-L972">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.argmax-Tuple{AbstractArray}" href="#Base.argmax-Tuple{AbstractArray}"><code>Base.argmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">argmax(A; dims) -&gt; indices</code></pre><p>For an array input, return the indices of the maximum elements over the given dimensions. <code>NaN</code> is treated as greater than all other values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2; 3 4]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; argmax(A, dims=1)
1×2 Matrix{CartesianIndex{2}}:
 CartesianIndex(2, 1)  CartesianIndex(2, 2)

julia&gt; argmax(A, dims=2)
2×1 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L1080-L1102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.argmax-Tuple{AbstractRange}" href="#Base.argmax-Tuple{AbstractRange}"><code>Base.argmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">argmax(r::AbstractRange)</code></pre><p>Ranges can have multiple maximal elements. In that case <code>argmax</code> will return a maximal index, but not necessarily the first one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L639-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.argmax-Tuple{Any}" href="#Base.argmax-Tuple{Any}"><code>Base.argmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">argmax(itr)</code></pre><p>Return the index or key of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned.</p><p>The collection must not be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; argmax([8,0.1,-9,pi])
1

julia&gt; argmax([1,7,7,6])
2

julia&gt; argmax([1,7,7,NaN])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2304-L2323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.argmin-Tuple{AbstractArray}" href="#Base.argmin-Tuple{AbstractArray}"><code>Base.argmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">argmin(A; dims) -&gt; indices</code></pre><p>For an array input, return the indices of the minimum elements over the given dimensions. <code>NaN</code> is treated as less than all other values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2; 3 4]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; argmin(A, dims=1)
1×2 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)

julia&gt; argmin(A, dims=2)
2×1 Matrix{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L1055-L1077">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.argmin-Tuple{AbstractRange}" href="#Base.argmin-Tuple{AbstractRange}"><code>Base.argmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">argmin(r::AbstractRange)</code></pre><p>Ranges can have multiple minimal elements. In that case <code>argmin</code> will return a minimal index, but not necessarily the first one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L622-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.argmin-Tuple{Any}" href="#Base.argmin-Tuple{Any}"><code>Base.argmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">argmin(itr)</code></pre><p>Return the index or key of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned.</p><p>The collection must not be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; argmin([8,0.1,-9,pi])
3

julia&gt; argmin([7,1,1,6])
2

julia&gt; argmin([7,1,1,NaN])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2326-L2345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ascii-Tuple{AbstractString}" href="#Base.ascii-Tuple{AbstractString}"><code>Base.ascii</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ascii(s::AbstractString)</code></pre><p>Convert a string to <code>String</code> type and check that it contains only ASCII data, otherwise throwing an <code>ArgumentError</code> indicating the position of the first non-ASCII byte.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ascii(&quot;abcdeγfgh&quot;)
ERROR: ArgumentError: invalid ASCII at index 6 in &quot;abcdeγfgh&quot;
Stacktrace:
[...]

julia&gt; ascii(&quot;abcdefgh&quot;)
&quot;abcdefgh&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L716-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.asyncmap!-Tuple{Any, Any, Any, Vararg{Any, N} where N}" href="#Base.asyncmap!-Tuple{Any, Any, Any, Vararg{Any, N} where N}"><code>Base.asyncmap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)</code></pre><p>Like <a href="#Base.asyncmap-Tuple{Any, Vararg{Any, N} where N}"><code>asyncmap</code></a>, but stores output in <code>results</code> rather than returning a collection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/asyncmap.jl#L411-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.asyncmap-Tuple{Any, Vararg{Any, N} where N}" href="#Base.asyncmap-Tuple{Any, Vararg{Any, N} where N}"><code>Base.asyncmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">asyncmap(f, c...; ntasks=0, batch_size=nothing)</code></pre><p>Uses multiple concurrent tasks to map <code>f</code> over a collection (or multiple equal length collections). For multiple collection arguments, <code>f</code> is applied elementwise.</p><p><code>ntasks</code> specifies the number of tasks to run concurrently. Depending on the length of the collections, if <code>ntasks</code> is unspecified, up to 100 tasks will be used for concurrent mapping.</p><p><code>ntasks</code> can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of <code>ntasks_func</code> is less than the current number of tasks.</p><p>If <code>batch_size</code> is specified, the collection is processed in batch mode. <code>f</code> must then be a function that must accept a <code>Vector</code> of argument tuples and must return a vector of results. The input vector will have a length of <code>batch_size</code> or less.</p><p>The following examples highlight execution in different tasks by returning the <code>objectid</code> of the tasks in which the mapping function is executed.</p><p>First, with <code>ntasks</code> undefined, each element is processed in a different task.</p><pre><code class="nohighlight hljs">julia&gt; tskoid() = objectid(current_task());

julia&gt; asyncmap(x-&gt;tskoid(), 1:5)
5-element Array{UInt64,1}:
 0x6e15e66c75c75853
 0x440f8819a1baa682
 0x9fb3eeadd0c83985
 0xebd3e35fe90d4050
 0x29efc93edce2b961

julia&gt; length(unique(asyncmap(x-&gt;tskoid(), 1:5)))
5</code></pre><p>With <code>ntasks=2</code> all elements are processed in 2 tasks.</p><pre><code class="nohighlight hljs">julia&gt; asyncmap(x-&gt;tskoid(), 1:5; ntasks=2)
5-element Array{UInt64,1}:
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94

julia&gt; length(unique(asyncmap(x-&gt;tskoid(), 1:5; ntasks=2)))
2</code></pre><p>With <code>batch_size</code> defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. <code>map</code> is used in the modified mapping function to achieve this.</p><pre><code class="nohighlight hljs">julia&gt; batch_func(input) = map(x-&gt;string(&quot;args_tuple: &quot;, x, &quot;, element_val: &quot;, x[1], &quot;, task: &quot;, tskoid()), input)
batch_func (generic function with 1 method)

julia&gt; asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)
5-element Array{String,1}:
 &quot;args_tuple: (1,), element_val: 1, task: 9118321258196414413&quot;
 &quot;args_tuple: (2,), element_val: 2, task: 4904288162898683522&quot;
 &quot;args_tuple: (3,), element_val: 3, task: 9118321258196414413&quot;
 &quot;args_tuple: (4,), element_val: 4, task: 4904288162898683522&quot;
 &quot;args_tuple: (5,), element_val: 5, task: 9118321258196414413&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, <code>asyncmap</code> is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/asyncmap.jl#L5-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.atexit-Tuple{Function}" href="#Base.atexit-Tuple{Function}"><code>Base.atexit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atexit(f)</code></pre><p>Register a zero-argument function <code>f()</code> to be called at process exit. <code>atexit()</code> hooks are called in last in first out (LIFO) order and run before object finalizers.</p><p>Exit hooks are allowed to call <code>exit(n)</code>, in which case Julia will exit with exit code <code>n</code> (instead of the original exit code). If more than one exit hook calls <code>exit(n)</code>, then Julia will exit with the exit code corresponding to the last called exit hook that calls <code>exit(n)</code>. (Because exit hooks are called in LIFO order, &quot;last called&quot; is equivalent to &quot;first registered&quot;.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/initdefs.jl#L325-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.atreplinit-Tuple{Function}" href="#Base.atreplinit-Tuple{Function}"><code>Base.atreplinit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">atreplinit(f)</code></pre><p>Register a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of <code>f</code> is the REPL object. This function should be called from within the <code>.julia/config/startup.jl</code> initialization file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/client.jl#L323-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.axes-Tuple{Any}" href="#Base.axes-Tuple{Any}"><code>Base.axes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">axes(A)</code></pre><p>Return the tuple of valid indices for array <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (5,6,7));

julia&gt; axes(A)
(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L73-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.axes-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}" href="#Base.axes-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}"><code>Base.axes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">axes(A, d)</code></pre><p>Return the valid range of indices for array <code>A</code> along dimension <code>d</code>.</p><p>See also <a href="#Base.size-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}"><code>size</code></a>, and the manual chapter on <a href="@ref man-custom-indices">arrays with custom indices</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (5,6,7));

julia&gt; axes(A, 2)
Base.OneTo(6)</code></pre><p><strong>Usage note</strong></p><p>Each of the indices has to be an <code>AbstractUnitRange{&lt;:Integer}</code>, but at the same time can be a type that uses custom indices. So, for example, if you need a subset, use generalized indexing constructs like <code>begin</code>/<code>end</code> or <a href="#Base.firstindex-Tuple{AbstractArray}"><code>firstindex</code></a>/<a href="#Base.lastindex-Tuple{AbstractArray}"><code>lastindex</code></a>:</p><pre><code class="language-julia hljs">ix = axes(v, 1)
ix[2:end]          # will work for eg Vector, but may fail in general
ix[(begin+1):end]  # works for generalized indexes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L40-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.backtrace-Tuple{}" href="#Base.backtrace-Tuple{}"><code>Base.backtrace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">backtrace()</code></pre><p>Get a backtrace object for the current program point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.big-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Number" href="#Base.big-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Number"><code>Base.big</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">big(T::Type)</code></pre><p>Compute the type that represents the numeric type <code>T</code> with arbitrary precision. Equivalent to <code>typeof(big(zero(T)))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; big(Rational)
Rational{BigInt}

julia&gt; big(Float64)
BigFloat

julia&gt; big(Complex{Int})
Complex{BigInt}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L321-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.bind-Tuple{Channel, Task}" href="#Base.bind-Tuple{Channel, Task}"><code>Base.bind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bind(chnl::Channel, task::Task)</code></pre><p>Associate the lifetime of <code>chnl</code> with a task. <code>Channel</code> <code>chnl</code> is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on <code>chnl</code>.</p><p>The <code>chnl</code> object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed <code>Channel</code> objects.</p><p>When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Channel(0);

julia&gt; task = @async foreach(i-&gt;put!(c, i), 1:4);

julia&gt; bind(c,task);

julia&gt; for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia&gt; isopen(c)
false</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = Channel(0);

julia&gt; task = @async (put!(c, 1); error(&quot;foo&quot;));

julia&gt; bind(c, task);

julia&gt; take!(c)
1

julia&gt; put!(c, 1);
ERROR: TaskFailedException
Stacktrace:
[...]
    nested task error: foo
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/channels.jl#L197-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.binomial-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer" href="#Base.binomial-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>Base.binomial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">binomial(n::Integer, k::Integer)</code></pre><p>The <em>binomial coefficient</em> <span>$\binom{n}{k}$</span>, being the coefficient of the <span>$k$</span>th term in the polynomial expansion of <span>$(1+x)^n$</span>.</p><p>If <span>$n$</span> is non-negative, then it is the number of ways to choose <code>k</code> out of <code>n</code> items:</p><p class="math-container">\[\binom{n}{k} = \frac{n!}{k! (n-k)!}\]</p><p>where <span>$n!$</span> is the <a href="#Base.factorial-Tuple{Integer}"><code>factorial</code></a> function.</p><p>If <span>$n$</span> is negative, then it is defined in terms of the identity</p><p class="math-container">\[\binom{n}{k} = (-1)^k \binom{k-n-1}{k}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; binomial(5, 3)
10

julia&gt; factorial(5) ÷ (factorial(5-3) * factorial(3))
10

julia&gt; binomial(-5, 3)
-35</code></pre><p><strong>See also</strong></p><ul><li><a href="#Base.factorial-Tuple{Integer}"><code>factorial</code></a></li></ul><p><strong>External links</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Binomial_coefficient">Binomial coefficient</a> on Wikipedia.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L967-L1001">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.bitreverse-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}" href="#Base.bitreverse-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}"><code>Base.bitreverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bitreverse(x)</code></pre><p>Reverse the order of bits in integer <code>x</code>. <code>x</code> must have a fixed bit width, e.g. be an <code>Int16</code> or <code>Int32</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires Julia 1.5 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bitreverse(0x8080808080808080)
0x0101010101010101

julia&gt; reverse(bitstring(0xa06e)) == bitstring(bitreverse(0xa06e))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L931-L948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.bitrotate-Union{Tuple{T}, Tuple{T, Integer}} where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}" href="#Base.bitrotate-Union{Tuple{T}, Tuple{T, Integer}} where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}"><code>Base.bitrotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bitrotate(x::Base.BitInteger, k::Integer)</code></pre><p><code>bitrotate(x, k)</code> implements bitwise rotation. It returns the value of <code>x</code> with its bits rotated left <code>k</code> times. A negative value of <code>k</code> will rotate to the right instead.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires Julia 1.5 or later.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; bitrotate(UInt8(114), 2)
0xc9

julia&gt; bitstring(bitrotate(0b01110010, 2))
&quot;11001001&quot;

julia&gt; bitstring(bitrotate(0b01110010, -2))
&quot;10011100&quot;

julia&gt; bitstring(bitrotate(0b01110010, 8))
&quot;01110010&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L489-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.bitstring" href="#Base.bitstring"><code>Base.bitstring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bitstring(n)</code></pre><p>A string giving the literal bit representation of a number.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bitstring(4)
&quot;0000000000000000000000000000000000000000000000000000000000000100&quot;

julia&gt; bitstring(2.2)
&quot;0100000000000001100110011001100110011001100110011001100110011010&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L782-L795">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.bitsunionsize-Tuple{Union}" href="#Base.bitsunionsize-Tuple{Union}"><code>Base.bitsunionsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.bitsunionsize(U::Union)</code></pre><p>For a <code>Union</code> of <a href="#Base.isbitstype-Tuple{Type}"><code>isbitstype</code></a> types, return the size of the largest type; assumes <code>Base.isbitsunion(U) == true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.bitsunionsize(Union{Float64, UInt8})
0x0000000000000008

julia&gt; Base.bitsunionsize(Union{Float64, UInt8, Int128})
0x0000000000000010</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L177-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.bodyfunction-Tuple{Method}" href="#Base.bodyfunction-Tuple{Method}"><code>Base.bodyfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fbody = bodyfunction(basemethod::Method)</code></pre><p>Find the keyword &quot;body function&quot; (the function that contains the body of the method as written, called after all missing keyword-arguments have been assigned default values). <code>basemethod</code> is the method you obtain via <a href="#Base.which-Tuple{Any, Any}"><code>which</code></a> or <a href="#Base.methods"><code>methods</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1365-L1371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.bswap-Tuple{Union{Int8, UInt8}}" href="#Base.bswap-Tuple{Union{Int8, UInt8}}"><code>Base.bswap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bswap(n)</code></pre><p>Reverse the byte order of <code>n</code>.</p><p>(See also <a href="#Base.ntoh-Tuple{Any}"><code>ntoh</code></a> and <a href="#Base.hton-Tuple{Any}"><code>hton</code></a> to convert between the current native byte order and big-endian order.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = bswap(0x10203040)
0x40302010

julia&gt; bswap(a)
0x10203040

julia&gt; string(1, base = 2)
&quot;1&quot;

julia&gt; string(bswap(1), base = 2)
&quot;100000000000000000000000000000000000000000000000000000000&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L335-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.bytes2hex" href="#Base.bytes2hex"><code>Base.bytes2hex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bytes2hex(a::AbstractArray{UInt8}) -&gt; String
bytes2hex(io::IO, a::AbstractArray{UInt8})</code></pre><p>Convert an array <code>a</code> of bytes to its hexadecimal string representation, either returning a <code>String</code> via <code>bytes2hex(a)</code> or writing the string to an <code>io</code> stream via <code>bytes2hex(io, a)</code>.  The hexadecimal characters are all lowercase.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = string(12345, base = 16)
&quot;3039&quot;

julia&gt; b = hex2bytes(a)
2-element Vector{UInt8}:
 0x30
 0x39

julia&gt; bytes2hex(b)
&quot;3039&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L668-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.bytesavailable-Tuple{Base.AbstractPipe}" href="#Base.bytesavailable-Tuple{Base.AbstractPipe}"><code>Base.bytesavailable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bytesavailable(io)</code></pre><p>Return the number of bytes available for reading before a read from this stream or buffer will block.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization&quot;);

julia&gt; bytesavailable(io)
34</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L390-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.canonicalize2-Tuple{Any, Any}" href="#Base.canonicalize2-Tuple{Any, Any}"><code>Base.canonicalize2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hi, lo = canonicalize2(big, little)</code></pre><p>Generate a representation where all the nonzero bits in <code>hi</code> are more significant than any of the nonzero bits in <code>lo</code>. <code>big</code> must be larger in absolute value than <code>little</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/twiceprecision.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cat-Tuple" href="#Base.cat-Tuple"><code>Base.cat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cat(A...; dims=dims)</code></pre><p>Concatenate the input arrays along the specified dimensions in the iterable <code>dims</code>. For dimensions not in <code>dims</code>, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in <code>dims</code>, the size of the output array is the sum of the sizes of the input arrays along that dimension. If <code>dims</code> is a single number, the different arrays are tightly stacked along that dimension. If <code>dims</code> is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, <code>cat(matrices...; dims=(1,2))</code> builds a block diagonal matrix, i.e. a block matrix with <code>matrices[1]</code>, <code>matrices[2]</code>, ... as diagonal blocks and matching zero blocks away from the diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1766-L1780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.catch_backtrace-Tuple{}" href="#Base.catch_backtrace-Tuple{}"><code>Base.catch_backtrace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">catch_backtrace()</code></pre><p>Get the backtrace of the current exception, for use within <code>catch</code> blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.catch_stack" href="#Base.catch_stack"><code>Base.catch_stack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">catch_stack(task=current_task(); [inclue_bt=true])</code></pre><p>Get the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of <code>(exception,backtrace)</code> pairs, or a Vector of exceptions if <code>include_bt</code> is false.</p><p>Explicitly passing <code>task</code> will return the current exception stack on an arbitrary task. This is useful for inspecting tasks which have failed due to uncaught exceptions.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L126-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ccall_macro_parse-Tuple{Expr}" href="#Base.ccall_macro_parse-Tuple{Expr}"><code>Base.ccall_macro_parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ccall_macro_parse(expression)</code></pre><p><code>ccall_macro_parse</code> is an implementation detail of `@ccall</p><p>it takes an expression like <code>:(printf(&quot;%d&quot;::Cstring, value::Cuint)::Cvoid)</code> returns: a tuple of <code>(function_name, return_type, arg_types, args)</code></p><p>The above input outputs this:</p><pre><code class="nohighlight hljs">(:printf, :Cvoid, [:Cstring, :Cuint], [&quot;%d&quot;, :value])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L544-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cconvert" href="#Base.cconvert"><code>Base.cconvert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cconvert(T,x)</code></pre><p>Convert <code>x</code> to a value to be passed to C code as type <code>T</code>, typically by calling <code>convert(T, x)</code>.</p><p>In cases where <code>x</code> cannot be safely converted to <code>T</code>, unlike <a href="#Base.convert"><code>convert</code></a>, <code>cconvert</code> may return an object of a type different from <code>T</code>, which however is suitable for <a href="#Base.unsafe_convert"><code>unsafe_convert</code></a> to handle. The result of this function should be kept valid (for the GC) until the result of <a href="#Base.unsafe_convert"><code>unsafe_convert</code></a> is not needed anymore. This can be used to allocate memory that will be accessed by the <code>ccall</code>. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</p><p>Neither <code>convert</code> nor <code>cconvert</code> should take a Julia object and turn it into a <code>Ptr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L380-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ceil" href="#Base.ceil"><code>Base.ceil</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ceil([T,] x)
ceil(x; digits::Integer= [, base = 10])
ceil(x; sigdigits::Integer= [, base = 10])</code></pre><p><code>ceil(x)</code> returns the nearest integral value of the same type as <code>x</code> that is greater than or equal to <code>x</code>.</p><p><code>ceil(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p><p><code>digits</code>, <code>sigdigits</code> and <code>base</code> work as for <a href="#Base.round"><code>round</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L579-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.channeled_tasks-Tuple{Int64, Vararg{Any, N} where N}" href="#Base.channeled_tasks-Tuple{Int64, Vararg{Any, N} where N}"><code>Base.channeled_tasks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">channeled_tasks(n::Int, funcs...; ctypes=fill(Any,n), csizes=fill(0,n))</code></pre><p>A convenience method to create <code>n</code> channels and bind them to tasks started from the provided functions in a single call. Each <code>func</code> must accept <code>n</code> arguments which are the created channels. Channel types and sizes may be specified via keyword arguments <code>ctypes</code> and <code>csizes</code> respectively. If unspecified, all channels are of type <code>Channel{Any}(0)</code>.</p><p>Returns a tuple, <code>(Array{Channel}, Array{Task})</code>, of the created channels and tasks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/channels.jl#L255-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.checkbounds-Tuple{AbstractArray, Vararg{Any, N} where N}" href="#Base.checkbounds-Tuple{AbstractArray, Vararg{Any, N} where N}"><code>Base.checkbounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checkbounds(A, I...)</code></pre><p>Throw an error if the specified indices <code>I</code> are not in bounds for the given array <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L609-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.checkbounds-Tuple{Type{Bool}, AbstractArray, Vararg{Any, N} where N}" href="#Base.checkbounds-Tuple{Type{Bool}, AbstractArray, Vararg{Any, N} where N}"><code>Base.checkbounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checkbounds(Bool, A, I...)</code></pre><p>Return <code>true</code> if the specified indices <code>I</code> are in bounds for the given array <code>A</code>. Subtypes of <code>AbstractArray</code> should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on <code>A</code>&#39;s indices and <a href="#Base.checkindex-Tuple{Type{Bool}, AbstractUnitRange, Any}"><code>checkindex</code></a>.</p><p>See also <a href="#Base.checkindex-Tuple{Type{Bool}, AbstractUnitRange, Any}"><code>checkindex</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = rand(3, 3);

julia&gt; checkbounds(Bool, A, 2)
true

julia&gt; checkbounds(Bool, A, 3, 4)
false

julia&gt; checkbounds(Bool, A, 1:3)
true

julia&gt; checkbounds(Bool, A, 1:3, 2:4)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L566-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.checkbounds_indices-Tuple{Type{Bool}, Tuple, Tuple}" href="#Base.checkbounds_indices-Tuple{Type{Bool}, Tuple, Tuple}"><code>Base.checkbounds_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checkbounds_indices(Bool, IA, I)</code></pre><p>Return <code>true</code> if the &quot;requested&quot; indices in the tuple <code>I</code> fall within the bounds of the &quot;permitted&quot; indices specified by the tuple <code>IA</code>. This function recursively consumes elements of these tuples, usually in a 1-for-1 fashion,</p><pre><code class="nohighlight hljs">checkbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &amp;
                                                      checkbounds_indices(Bool, IA, I)</code></pre><p>Note that <a href="#Base.checkindex-Tuple{Type{Bool}, AbstractUnitRange, Any}"><code>checkindex</code></a> is being used to perform the actual bounds-check for a single dimension of the array.</p><p>There are two important exceptions to the 1-1 rule: linear indexing and CartesianIndex{N}, both of which may &quot;consume&quot; more than one element of <code>IA</code>.</p><p>See also <a href="#Base.checkbounds-Tuple{AbstractArray, Vararg{Any, N} where N}"><code>checkbounds</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L620-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.checkindex-Tuple{Type{Bool}, AbstractUnitRange, Any}" href="#Base.checkindex-Tuple{Type{Bool}, AbstractUnitRange, Any}"><code>Base.checkindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">checkindex(Bool, inds::AbstractUnitRange, index)</code></pre><p>Return <code>true</code> if the given <code>index</code> is within the bounds of <code>inds</code>. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; checkindex(Bool, 1:20, 8)
true

julia&gt; checkindex(Bool, 1:20, 21)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L654-L670">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.chomp-Tuple{AbstractString}" href="#Base.chomp-Tuple{AbstractString}"><code>Base.chomp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chomp(s::AbstractString) -&gt; SubString</code></pre><p>Remove a single trailing newline from a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chomp(&quot;Hello\n&quot;)
&quot;Hello&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L194-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.chop-Tuple{AbstractString}" href="#Base.chop-Tuple{AbstractString}"><code>Base.chop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)</code></pre><p>Remove the first <code>head</code> and the last <code>tail</code> characters from <code>s</code>. The call <code>chop(s)</code> removes the last character from <code>s</code>. If it is requested to remove more characters than <code>length(s)</code> then an empty string is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = &quot;March&quot;
&quot;March&quot;

julia&gt; chop(a)
&quot;Marc&quot;

julia&gt; chop(a, head = 1, tail = 2)
&quot;ar&quot;

julia&gt; chop(a, head = 5, tail = 5)
&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L161-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.circcopy!-Tuple{Any, Any}" href="#Base.circcopy!-Tuple{Any, Any}"><code>Base.circcopy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circcopy!(dest, src)</code></pre><p>Copy <code>src</code> to <code>dest</code>, indexing each dimension modulo its length. <code>src</code> and <code>dest</code> must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap <code>dest</code> agrees with <code>src</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; src = reshape(Vector(1:16), (4,4))
4×4 Array{Int64,2}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; dest = OffsetArray{Int}(undef, (0:3,2:5))

julia&gt; circcopy!(dest, src)
OffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:
 8  12  16  4
 5   9  13  1
 6  10  14  2
 7  11  15  3

julia&gt; dest[1:3,2:4] == src[1:3,2:4]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/multidimensional.jl#L1153-L1183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.circshift!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, Tuple{Vararg{Integer, N}} where N}} where {T, N}" href="#Base.circshift!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, Tuple{Vararg{Integer, N}} where N}} where {T, N}"><code>Base.circshift!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circshift!(dest, src, shifts)</code></pre><p>Circularly shift, i.e. rotate, the data in <code>src</code>, storing the result in <code>dest</code>. <code>shifts</code> specifies the amount to shift in each dimension.</p><p>The <code>dest</code> array must be distinct from the <code>src</code> array (they cannot alias each other).</p><p>See also <a href="#Base.circshift-Tuple{AbstractArray, Any}"><code>circshift</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/multidimensional.jl#L1098-L1108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.circshift-Tuple{AbstractArray, Any}" href="#Base.circshift-Tuple{AbstractArray, Any}"><code>Base.circshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circshift(A, shifts)</code></pre><p>Circularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; b = reshape(Vector(1:16), (4,4))
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; circshift(b, (0,2))
4×4 Matrix{Int64}:
  9  13  1  5
 10  14  2  6
 11  15  3  7
 12  16  4  8

julia&gt; circshift(b, (-1,0))
4×4 Matrix{Int64}:
 2  6  10  14
 3  7  11  15
 4  8  12  16
 1  5   9  13

julia&gt; a = BitArray([true, true, false, false, true])
5-element BitVector:
 1
 1
 0
 0
 1

julia&gt; circshift(a, 1)
5-element BitVector:
 1
 1
 1
 0
 0

julia&gt; circshift(a, -1)
5-element BitVector:
 1
 0
 0
 1
 1</code></pre><p>See also <a href="#Base.circshift!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, Tuple{Vararg{Integer, N}} where N}} where {T, N}"><code>circshift!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarraymath.jl#L134-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cis-Tuple{Complex}" href="#Base.cis-Tuple{Complex}"><code>Base.cis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cis(z)</code></pre><p>Return <span>$\exp(iz)$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cis(π) ≈ -1
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L527-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cispi-Tuple{Complex}" href="#Base.cispi-Tuple{Complex}"><code>Base.cispi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cispi(z)</code></pre><p>Compute <span>$\exp(i\pi x)$</span> more accurately than <code>cis(pi*x)</code>, especially for large <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cispi(1)
-1.0 + 0.0im

julia&gt; cispi(0.25 + 1im)
0.030556854645952924 + 0.030556854645952924im</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This function requires Julia 1.6 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L546-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cld-Tuple{Any, Any}" href="#Base.cld-Tuple{Any, Any}"><code>Base.cld</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cld(x, y)</code></pre><p>Smallest integer larger than or equal to <code>x/y</code>. Equivalent to <code>div(x, y, RoundUp)</code>.</p><p>See also: <a href="#Base.div"><code>div</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cld(5.5,2.2)
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/div.jl#L88-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.close" href="#Base.close"><code>Base.close</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">close(stream)</code></pre><p>Close an I/O stream. Performs a <a href="#Base.flush-Tuple{IO}"><code>flush</code></a> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.close" href="#Base.close"><code>Base.close</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">close(c::Channel[, excp::Exception])</code></pre><p>Close a channel. An exception (optionally given by <code>excp</code>), is thrown by:</p><ul><li><a href="#Base.put!-Union{Tuple{T}, Tuple{Channel{T}, Any}} where T"><code>put!</code></a> on a closed channel.</li><li><a href="#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a> and <a href="#Base.fetch-Tuple{Channel}"><code>fetch</code></a> on an empty, closed channel.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/channels.jl#L174-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cmp-Tuple{AbstractString, AbstractString}" href="#Base.cmp-Tuple{AbstractString, AbstractString}"><code>Base.cmp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cmp(a::AbstractString, b::AbstractString) -&gt; Int</code></pre><p>Compare two strings. Return <code>0</code> if both strings have the same length and the character at each index is the same in both strings. Return <code>-1</code> if <code>a</code> is a prefix of <code>b</code>, or if <code>a</code> comes before <code>b</code> in alphabetical order. Return <code>1</code> if <code>b</code> is a prefix of <code>a</code>, or if <code>b</code> comes before <code>a</code> in alphabetical order (technically, lexicographical order by Unicode code points).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cmp(&quot;abc&quot;, &quot;abc&quot;)
0

julia&gt; cmp(&quot;ab&quot;, &quot;abc&quot;)
-1

julia&gt; cmp(&quot;abc&quot;, &quot;ab&quot;)
1

julia&gt; cmp(&quot;ab&quot;, &quot;ac&quot;)
-1

julia&gt; cmp(&quot;ac&quot;, &quot;ab&quot;)
1

julia&gt; cmp(&quot;α&quot;, &quot;a&quot;)
1

julia&gt; cmp(&quot;b&quot;, &quot;β&quot;)
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L266-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cmp-Tuple{Any, Any, Any}" href="#Base.cmp-Tuple{Any, Any, Any}"><code>Base.cmp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cmp(&lt;, x, y)</code></pre><p>Return -1, 0, or 1 depending on whether <code>x</code> is less than, equal to, or greater than <code>y</code>, respectively. The first argument specifies a less-than comparison function to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L396-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cmp-Tuple{Any, Any}" href="#Base.cmp-Tuple{Any, Any}"><code>Base.cmp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cmp(x,y)</code></pre><p>Return -1, 0, or 1 depending on whether <code>x</code> is less than, equal to, or greater than <code>y</code>, respectively. Uses the total order implemented by <code>isless</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cmp(1, 2)
-1

julia&gt; cmp(2, 1)
1

julia&gt; cmp(2+im, 3-im)
ERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L375-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.coalesce" href="#Base.coalesce"><code>Base.coalesce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coalesce(x, y...)</code></pre><p>Return the first value in the arguments which is not equal to <a href="#Base.missing"><code>missing</code></a>, if any. Otherwise return <code>missing</code>.</p><p>See also <a href="#Base.something"><code>something</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; coalesce(missing, 1)
1

julia&gt; coalesce(1, missing)
1

julia&gt; coalesce(nothing, 1)  # returns `nothing`

julia&gt; coalesce(missing, missing)
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/missing.jl#L391-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.code_lowered-Tuple{Any, Any}" href="#Base.code_lowered-Tuple{Any, Any}"><code>Base.code_lowered</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">code_lowered(f, types; generated=true, debuginfo=:default)</code></pre><p>Return an array of the lowered forms (IR) for the methods matching the given generic function and type signature.</p><p>If <code>generated</code> is <code>false</code>, the returned <code>CodeInfo</code> instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If <code>generated</code> is <code>true</code>, these <code>CodeInfo</code> instances will correspond to the method bodies yielded by expanding the generators.</p><p>The keyword <code>debuginfo</code> controls the amount of code metadata present in the output.</p><p>Note that an error will be thrown if <code>types</code> are not leaf types when <code>generated</code> is <code>true</code> and any of the corresponding methods are an <code>@generated</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L802-L817">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.code_typed-Tuple{Any, Any}" href="#Base.code_typed-Tuple{Any, Any}"><code>Base.code_typed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">code_typed(f, types; optimize=true, debuginfo=:default)</code></pre><p>Returns an array of type-inferred lowered form (IR) for the methods matching the given generic function and type signature. The keyword argument <code>optimize</code> controls whether additional optimizations, such as inlining, are also applied. The keyword <code>debuginfo</code> controls the amount of code metadata present in the output, possible options are <code>:source</code> or <code>:none</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1106-L1114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.code_typed_by_type-Tuple{Type}" href="#Base.code_typed_by_type-Tuple{Type}"><code>Base.code_typed_by_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">code_typed_by_type(types::Type{&lt;:Tuple}; ...)</code></pre><p>Similar to <a href="#Base.code_typed-Tuple{Any, Any}"><code>code_typed</code></a>, except the argument is a tuple type describing a full signature to query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1133-L1138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.codepoint" href="#Base.codepoint"><code>Base.codepoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">codepoint(c::AbstractChar) -&gt; Integer</code></pre><p>Return the Unicode codepoint (an unsigned integer) corresponding to the character <code>c</code> (or throw an exception if <code>c</code> does not represent a valid character). For <code>Char</code>, this is a <code>UInt32</code> value, but <code>AbstractChar</code> types that represent only a subset of Unicode may return a different-sized integer (e.g. <code>UInt8</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/char.jl#L66-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.codeunit-Tuple{AbstractString, Integer}" href="#Base.codeunit-Tuple{AbstractString, Integer}"><code>Base.codeunit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">codeunit(s::AbstractString, i::Integer) -&gt; Union{UInt8, UInt16, UInt32}</code></pre><p>Return the code unit value in the string <code>s</code> at index <code>i</code>. Note that</p><pre><code class="nohighlight hljs">codeunit(s, i) :: codeunit(s)</code></pre><p>I.e. the value returned by <code>codeunit(s, i)</code> is of the type returned by <code>codeunit(s)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = codeunit(&quot;Hello&quot;, 2)
0x65

julia&gt; typeof(a)
UInt8</code></pre><p>See also: <a href="#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a>, <a href="#Base.checkbounds-Tuple{AbstractArray, Vararg{Any, N} where N}"><code>checkbounds</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L86-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.codeunit-Tuple{AbstractString}" href="#Base.codeunit-Tuple{AbstractString}"><code>Base.codeunit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">codeunit(s::AbstractString) -&gt; Type{&lt;:Union{UInt8, UInt16, UInt32}}</code></pre><p>Return the code unit type of the given string object. For ASCII, Latin-1, or UTF-8 encoded strings, this would be <code>UInt8</code>; for UCS-2 and UTF-16 it would be <code>UInt16</code>; for UTF-32 it would be <code>UInt32</code>. The code unit type need not be limited to these three types, but it&#39;s hard to think of widely used string encodings that don&#39;t use one of these units. <code>codeunit(s)</code> is the same as <code>typeof(codeunit(s,1))</code> when <code>s</code> is a non-empty string.</p><p>See also: <a href="#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L70-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.codeunits-Tuple{AbstractString}" href="#Base.codeunits-Tuple{AbstractString}"><code>Base.codeunits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">codeunits(s::AbstractString)</code></pre><p>Obtain a vector-like object containing the code units of a string. Returns a <code>CodeUnits</code> wrapper by default, but <code>codeunits</code> may optionally be defined for new string types if necessary.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; codeunits(&quot;Juλia&quot;)
6-element Base.CodeUnits{UInt8, String}:
 0x4a
 0x75
 0xce
 0xbb
 0x69
 0x61</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L751-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.collect-Tuple{Any}" href="#Base.collect-Tuple{Any}"><code>Base.collect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collect(collection)</code></pre><p>Return an <code>Array</code> of all items in a collection or iterator. For dictionaries, returns <code>Pair{KeyType, ValType}</code>. If the argument is array-like or is an iterator with the <a href="#Base.IteratorSize-Tuple{Any}"><code>HasShape</code></a> trait, the result will have the same shape and number of dimensions as the argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(1:2:13)
7-element Vector{Int64}:
  1
  3
  5
  7
  9
 11
 13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L581-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.collect-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#Base.collect-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>Base.collect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collect(element_type, collection)</code></pre><p>Return an <code>Array</code> with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; collect(Float64, 1:2:5)
3-element Vector{Float64}:
 1.0
 3.0
 5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L546-L560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.compilecache" href="#Base.compilecache"><code>Base.compilecache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.compilecache(module::PkgId)</code></pre><p>Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in <code>DEPOT_PATH[1]/compiled</code>. See <a href="@ref">Module initialization and precompilation</a> for important notes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L1310-L1317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.complex-Tuple{Complex}" href="#Base.complex-Tuple{Complex}"><code>Base.complex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complex(r, [i])</code></pre><p>Convert real numbers or arrays to complex. <code>i</code> defaults to zero.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; complex(7)
7 + 0im

julia&gt; complex([1, 2, 3])
3-element Vector{Complex{Int64}}:
 1 + 0im
 2 + 0im
 3 + 0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L141-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.complex-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real" href="#Base.complex-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Real"><code>Base.complex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">complex(T::Type)</code></pre><p>Return an appropriate type which can represent a value of type <code>T</code> as a complex number. Equivalent to <code>typeof(complex(zero(T)))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; complex(Complex{Int})
Complex{Int64}

julia&gt; complex(Int)
Complex{Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L162-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.conj!-Tuple{AbstractArray{var&quot;#s832&quot;, N} where {var&quot;#s832&quot;&lt;:Number, N}}" href="#Base.conj!-Tuple{AbstractArray{var&quot;#s832&quot;, N} where {var&quot;#s832&quot;&lt;:Number, N}}"><code>Base.conj!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conj!(A)</code></pre><p>Transform an array to its complex conjugate in-place.</p><p>See also <a href="#Base.conj-Tuple{Complex}"><code>conj</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1+im 2-im; 2+2im 3+im]
2×2 Matrix{Complex{Int64}}:
 1+1im  2-1im
 2+2im  3+1im

julia&gt; conj!(A);

julia&gt; A
2×2 Matrix{Complex{Int64}}:
 1-1im  2+1im
 2-2im  3-1im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arraymath.jl#L5-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{Complex}" href="#Base.conj-Tuple{Complex}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conj(z)</code></pre><p>Compute the complex conjugate of a complex number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; conj(1 + 3im)
1 - 3im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L252-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{AbstractString, Any}" href="#Base.contains-Tuple{AbstractString, Any}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contains(haystack::AbstractString, needle)</code></pre><p>Return <code>true</code> if <code>haystack</code> contains <code>needle</code>. This is the same as <code>occursin(needle, haystack)</code>, but is provided for consistency with <code>startswith(haystack, needle)</code> and <code>endswith(haystack, needle)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; contains(&quot;JuliaLang is pretty cool!&quot;, &quot;Julia&quot;)
true

julia&gt; contains(&quot;JuliaLang is pretty cool!&quot;, &#39;a&#39;)
true

julia&gt; contains(&quot;aba&quot;, r&quot;a.a&quot;)
true

julia&gt; contains(&quot;abba&quot;, r&quot;a.a&quot;)
false</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The <code>contains</code> function requires at least Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L73-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{Any}" href="#Base.contains-Tuple{Any}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contains(needle)</code></pre><p>Create a function that checks whether its argument contains <code>needle</code>, i.e. a function equivalent to <code>haystack -&gt; contains(haystack, needle)</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(contains)}</code>, which can be used to implement specialized methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L150-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convert(T, x)</code></pre><p>Convert <code>x</code> to a value of type <code>T</code>.</p><p>If <code>T</code> is an <a href="@ref"><code>Integer</code></a> type, an <a href="@ref"><code>InexactError</code></a> will be raised if <code>x</code> is not representable by <code>T</code>, for example if <code>x</code> is not integer-valued, or is outside the range supported by <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; convert(Int, 3.0)
3

julia&gt; convert(Int, 3.5)
ERROR: InexactError: Int64(3.5)
Stacktrace:
[...]</code></pre><p>If <code>T</code> is a <a href="@ref"><code>AbstractFloat</code></a> or <a href="#Base.Rational"><code>Rational</code></a> type, then it will return the closest value to <code>x</code> representable by <code>T</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; x = 1/3
0.3333333333333333

julia&gt; convert(Float32, x)
0.33333334f0

julia&gt; convert(Rational{Int32}, x)
1//3

julia&gt; convert(Rational{Int64}, x)
6004799503160661//18014398509481984</code></pre><p>If <code>T</code> is a collection type and <code>x</code> a collection, the result of <code>convert(T, x)</code> may alias all or part of <code>x</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; x = Int[1, 2, 3];

julia&gt; y = convert(Vector{Int}, x);

julia&gt; y === x
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L153-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copy(x)</code></pre><p>Create a shallow copy of <code>x</code>: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L340-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}" href="#Base.copy!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>Base.copy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy!(dst, src) -&gt; dst</code></pre><p>In-place <a href="#Base.copy"><code>copy</code></a> of <code>src</code> into <code>dst</code>, discarding any pre-existing elements in <code>dst</code>. If <code>dst</code> and <code>src</code> are of the same type, <code>dst == src</code> should hold after the call. If <code>dst</code> and <code>src</code> are multidimensional arrays, they must have equal <a href="#Base.axes-Tuple{Any}"><code>axes</code></a>. See also <a href="#Base.copyto!-Tuple{AbstractArray, AbstractArray}"><code>copyto!</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This method requires at least Julia 1.1. In Julia 1.0 this method is available from the <code>Future</code> standard library as <code>Future.copy!</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L808-L821">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyfirst!-Tuple{AbstractArray, AbstractArray}" href="#Base.copyfirst!-Tuple{AbstractArray, AbstractArray}"><code>Base.copyfirst!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Extract first entry of slices of array A into existing array R.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L219-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copymutable-Tuple{AbstractArray}" href="#Base.copymutable-Tuple{AbstractArray}"><code>Base.copymutable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copymutable(a)</code></pre><p>Make a mutable copy of an array or iterable <code>a</code>.  For <code>a::Array</code>, this is equivalent to <code>copy(a)</code>, but for other array types it may differ depending on the type of <code>similar(a)</code>.  For generic iterables this is equivalent to <code>collect(a)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; tup = (1, 2, 3)
(1, 2, 3)

julia&gt; Base.copymutable(tup)
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1059-L1078">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copysign-Tuple{Real, Real}" href="#Base.copysign-Tuple{Real, Real}"><code>Base.copysign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copysign(x, y) -&gt; z</code></pre><p>Return <code>z</code> which has the magnitude of <code>x</code> and the same sign as <code>y</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; copysign(1, -2)
-1

julia&gt; copysign(-1, 2)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L169-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractArray, AbstractArray}" href="#Base.copyto!-Tuple{AbstractArray, AbstractArray}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(dest::AbstractArray, src) -&gt; dest</code></pre><p>Copy all elements from collection <code>src</code> to array <code>dest</code>, whose length must be greater than or equal to the length <code>n</code> of <code>src</code>. The first <code>n</code> elements of <code>dest</code> are overwritten, the other elements are left untouched.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1., 0., 3., 0., 5.];

julia&gt; y = zeros(7);

julia&gt; copyto!(y, x);

julia&gt; y
7-element Vector{Float64}:
 1.0
 0.0
 3.0
 0.0
 5.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L920-L946">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractArray, CartesianIndices, AbstractArray, CartesianIndices}" href="#Base.copyto!-Tuple{AbstractArray, CartesianIndices, AbstractArray, CartesianIndices}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -&gt; dest</code></pre><p>Copy the block of <code>src</code> in the range of <code>Rsrc</code> to the block of <code>dest</code> in the range of <code>Rdest</code>. The sizes of the two regions must match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/multidimensional.jl#L1088-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{Array, Integer, Array, Integer, Integer}" href="#Base.copyto!-Tuple{Array, Integer, Array, Integer, Integer}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(dest, do, src, so, N)</code></pre><p>Copy <code>N</code> elements from collection <code>src</code> starting at offset <code>so</code>, to array <code>dest</code> starting at offset <code>do</code>. Return <code>dest</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L292-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.count!-Tuple{AbstractArray, Union{Base.AbstractBroadcasted, AbstractArray}}" href="#Base.count!-Tuple{AbstractArray, Union{Base.AbstractBroadcasted, AbstractArray}}"><code>Base.count!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count!([f=identity,] r, A)</code></pre><p>Count the number of elements in <code>A</code> for which <code>f</code> returns <code>true</code> over the singleton dimensions of <code>r</code>, writing the result into <code>r</code> in-place.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>inplace <code>count!</code> was added in Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; count!(&lt;=(2), [1 1], A)
1×2 Matrix{Int64}:
 1  1

julia&gt; count!(&lt;=(2), [1; 1], A)
2-element Vector{Int64}:
 2
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L398-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.count-Tuple{Any}" href="#Base.count-Tuple{Any}"><code>Base.count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count([f=identity,] itr; init=0) -&gt; Integer</code></pre><p>Count the number of elements in <code>itr</code> for which the function <code>f</code> returns <code>true</code>. If <code>f</code> is omitted, count the number of <code>true</code> elements in <code>itr</code> (which should be a collection of boolean values). <code>init</code> optionally specifies the value to start counting from and therefore also determines the output type.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p><code>init</code> keyword was added in Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; count(i-&gt;(4&lt;=i&lt;=6), [2,3,4,5,6])
3

julia&gt; count([true, false, true, true])
3

julia&gt; count(&gt;(3), 1:7, init=0x03)
0x07</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L940-L962">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.count-Tuple{Union{AbstractPattern, AbstractString}, AbstractString}" href="#Base.count-Tuple{Union{AbstractPattern, AbstractString}, AbstractString}"><code>Base.count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count(
    pattern::Union{AbstractString,AbstractPattern},
    string::AbstractString;
    overlap::Bool = false,
)</code></pre><p>Return the number of matches for <code>pattern</code> in <code>string</code>. This is equivalent to calling <code>length(findall(pattern, string))</code> but more efficient.</p><p>If <code>overlap=true</code>, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L400-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.count-Tuple{Union{Base.AbstractBroadcasted, AbstractArray}}" href="#Base.count-Tuple{Union{Base.AbstractBroadcasted, AbstractArray}}"><code>Base.count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count([f=identity,] A::AbstractArray; dims=:)</code></pre><p>Count the number of elements in <code>A</code> for which <code>f</code> returns <code>true</code> over the given dimensions.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>dims</code> keyword was added in Julia 1.5.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p><code>init</code> keyword was added in Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; count(&lt;=(2), A, dims=1)
1×2 Matrix{Int64}:
 1  1

julia&gt; count(&lt;=(2), A, dims=2)
2×1 Matrix{Int64}:
 2
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L363-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.count_ones-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}" href="#Base.count_ones-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}"><code>Base.count_ones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_ones(x::Integer) -&gt; Integer</code></pre><p>Number of ones in the binary representation of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; count_ones(7)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L361-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.count_zeros-Tuple{Integer}" href="#Base.count_zeros-Tuple{Integer}"><code>Base.count_zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_zeros(x::Integer) -&gt; Integer</code></pre><p>Number of zeros in the binary representation of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; count_zeros(Int32(2 ^ 16 - 1))
16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L400-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.countlines-Tuple{IO}" href="#Base.countlines-Tuple{IO}"><code>Base.countlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">countlines(io::IO; eol::AbstractChar = &#39;\n&#39;)</code></pre><p>Read <code>io</code> until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than <code>&#39;\n&#39;</code> are supported by passing them as the second argument.  The last non-empty line of <code>io</code> is counted even if it does not end with the EOL, matching the length returned by <a href="#Base.eachline"><code>eachline</code></a> and <a href="#Base.readlines-Tuple{AbstractString}"><code>readlines</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization.\n&quot;);

julia&gt; countlines(io)
1

julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization.&quot;);

julia&gt; countlines(io)
1

julia&gt; countlines(io, eol = &#39;.&#39;)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L1151-L1174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cumprod!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}" href="#Base.cumprod!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>Base.cumprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cumprod!(y::AbstractVector, x::AbstractVector)</code></pre><p>Cumulative product of a vector <code>x</code>, storing the result in <code>y</code>. See also <a href="#Base.cumprod-Tuple{AbstractArray}"><code>cumprod</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/accumulate.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cumprod!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T" href="#Base.cumprod!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T"><code>Base.cumprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cumprod!(B, A; dims::Integer)</code></pre><p>Cumulative product of <code>A</code> along the dimension <code>dims</code>, storing the result in <code>B</code>. See also <a href="#Base.cumprod-Tuple{AbstractArray}"><code>cumprod</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/accumulate.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cumprod-Tuple{AbstractArray}" href="#Base.cumprod-Tuple{AbstractArray}"><code>Base.cumprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cumprod(A; dims::Integer)</code></pre><p>Cumulative product along the dimension <code>dim</code>. See also <a href="#Base.cumprod!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>cumprod!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2 3; 4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; cumprod(a, dims=1)
2×3 Matrix{Int64}:
 1   2   3
 4  10  18

julia&gt; cumprod(a, dims=2)
2×3 Matrix{Int64}:
 1   2    6
 4  20  120</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/accumulate.jl#L171-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cumprod-Tuple{AbstractVector{T} where T}" href="#Base.cumprod-Tuple{AbstractVector{T} where T}"><code>Base.cumprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cumprod(itr)</code></pre><p>Cumulative product of an iterator. See also <a href="#Base.cumprod!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>cumprod!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>cumprod</code> on a non-array iterator requires at least Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cumprod(fill(1//2, 3))
3-element Vector{Rational{Int64}}:
 1//2
 1//4
 1//8

julia&gt; cumprod([fill(1//3, 2, 2) for i in 1:3])
3-element Vector{Matrix{Rational{Int64}}}:
 [1//3 1//3; 1//3 1//3]
 [2//9 2//9; 2//9 2//9]
 [4//27 4//27; 4//27 4//27]

julia&gt; cumprod((1, 2, 1))
(1, 2, 2)

julia&gt; cumprod(x^2 for x in 1:3)
3-element Vector{Int64}:
  1
  4
 36</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/accumulate.jl#L200-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cumsum!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T" href="#Base.cumsum!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T"><code>Base.cumsum!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cumsum!(B, A; dims::Integer)</code></pre><p>Cumulative sum of <code>A</code> along the dimension <code>dims</code>, storing the result in <code>B</code>. See also <a href="#Base.cumsum-Tuple{AbstractVector{T} where T}"><code>cumsum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/accumulate.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cumsum-Tuple{AbstractVector{T} where T}" href="#Base.cumsum-Tuple{AbstractVector{T} where T}"><code>Base.cumsum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cumsum(itr)</code></pre><p>Cumulative sum an iterator. See also <a href="#Base.cumsum!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T"><code>cumsum!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>cumsum</code> on a non-array iterator requires at least Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cumsum([1, 1, 1])
3-element Vector{Int64}:
 1
 2
 3

julia&gt; cumsum([fill(1, 2) for i in 1:3])
3-element Vector{Vector{Int64}}:
 [1, 1]
 [2, 2]
 [3, 3]

julia&gt; cumsum((1, 1, 1))
(1, 2, 3)

julia&gt; cumsum(x^2 for x in 1:3)
3-element Vector{Int64}:
  1
  5
 14</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/accumulate.jl#L116-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cumsum-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T" href="#Base.cumsum-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T"><code>Base.cumsum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cumsum(A; dims::Integer)</code></pre><p>Cumulative sum along the dimension <code>dims</code>. See also <a href="#Base.cumsum!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T"><code>cumsum!</code></a> to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2 3; 4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; cumsum(a, dims=1)
2×3 Matrix{Int64}:
 1  2  3
 5  7  9

julia&gt; cumsum(a, dims=2)
2×3 Matrix{Int64}:
 1  3   6
 4  9  15</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The return array&#39;s <code>eltype</code> is <code>Int</code> for signed integers of less than system word size  and <code>UInt</code> for unsigned integers of less than system word size. To preserve <code>eltype</code> of arrays with small signed or unsigned integer <code>accumulate(+, A)</code> should be used.</p><pre><code class="language-julia-repl hljs">julia&gt; cumsum(Int8[100, 28])
2-element Vector{Int64}:
 100
 128

julia&gt; accumulate(+,Int8[100, 28])
2-element Vector{Int8}:
  100
 -128</code></pre><p>In the former case, the integers are widened to system word size and therefore the result is <code>Int64[100, 128]</code>. In the latter case, no such widening happens and integer overflow results in <code>Int8[100, -128]</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/accumulate.jl#L64-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.current_task-Tuple{}" href="#Base.current_task-Tuple{}"><code>Base.current_task</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">current_task()</code></pre><p>Get the currently running <a href="@ref"><code>Task</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.dataids-Tuple{AbstractArray}" href="#Base.dataids-Tuple{AbstractArray}"><code>Base.dataids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.dataids(A::AbstractArray)</code></pre><p>Return a tuple of <code>UInt</code>s that represent the mutable data segments of an array.</p><p>Custom arrays that would like to opt-in to aliasing detection of their component parts can specialize this method to return the concatenation of the <code>dataids</code> of their component parts.  A typical definition for an array that wraps a parent is <code>Base.dataids(C::CustomArray) = dataids(C.parent)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1397-L1406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.datatype_alignment-Tuple{DataType}" href="#Base.datatype_alignment-Tuple{DataType}"><code>Base.datatype_alignment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.datatype_alignment(dt::DataType) -&gt; Int</code></pre><p>Memory allocation minimum alignment for instances of this type. Can be called on any <code>isconcretetype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L307-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.datatype_fielddesc_type-Tuple{DataType}" href="#Base.datatype_fielddesc_type-Tuple{DataType}"><code>Base.datatype_fielddesc_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.datatype_fielddesc_type(dt::DataType) -&gt; Int</code></pre><p>Return the size in bytes of each field-description entry in the layout array, located at <code>(dt.layout + sizeof(DataTypeLayout))</code>. Can be called on any <code>isconcretetype</code>.</p><p>See also <a href="#Base.fieldoffset-Tuple{DataType, Integer}"><code>fieldoffset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L383-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.datatype_haspadding-Tuple{DataType}" href="#Base.datatype_haspadding-Tuple{DataType}"><code>Base.datatype_haspadding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.datatype_haspadding(dt::DataType) -&gt; Bool</code></pre><p>Return whether the fields of instances of this type are packed in memory, with no intervening padding bytes. Can be called on any <code>isconcretetype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L344-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.datatype_nfields-Tuple{DataType}" href="#Base.datatype_nfields-Tuple{DataType}"><code>Base.datatype_nfields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.datatype_nfields(dt::DataType) -&gt; Bool</code></pre><p>Return the number of fields known to this datatype&#39;s layout. Can be called on any <code>isconcretetype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L358-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.datatype_pointerfree-Tuple{DataType}" href="#Base.datatype_pointerfree-Tuple{DataType}"><code>Base.datatype_pointerfree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.datatype_pointerfree(dt::DataType) -&gt; Bool</code></pre><p>Return whether instances of this type can contain references to gc-managed memory. Can be called on any <code>isconcretetype</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L370-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.decode_overlong" href="#Base.decode_overlong"><code>Base.decode_overlong</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decode_overlong(c::AbstractChar) -&gt; Integer</code></pre><p>When <a href="#Base.isoverlong-Tuple{AbstractChar}"><code>isoverlong(c)</code></a> is <code>true</code>, <code>decode_overlong(c)</code> returns the Unicode codepoint value of <code>c</code>. <code>AbstractChar</code> implementations that support overlong encodings should implement <code>Base.decode_overlong</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/char.jl#L139-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.deepcopy-Tuple{Any}" href="#Base.deepcopy-Tuple{Any}"><code>Base.deepcopy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deepcopy(x)</code></pre><p>Create a deep copy of <code>x</code>: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling <code>deepcopy</code> on an object should generally have the same effect as serializing and then deserializing it.</p><p>While it isn&#39;t normally necessary, user-defined types can override the default <code>deepcopy</code> behavior by defining a specialized version of the function <code>deepcopy_internal(x::T, dict::IdDict)</code> (which shouldn&#39;t otherwise be used), where <code>T</code> is the type to be specialized for, and <code>dict</code> keeps track of objects copied so far within the recursion. Within the definition, <code>deepcopy_internal</code> should be used in place of <code>deepcopy</code>, and the <code>dict</code> variable should be updated as appropriate before returning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/deepcopy.jl#L8-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!-Tuple{Any, Any}" href="#Base.delete!-Tuple{Any, Any}"><code>Base.delete!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete!(collection, key)</code></pre><p>Delete the mapping for the given key in a collection, if any, and return the collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2)
Dict{String, Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; delete!(d, &quot;b&quot;)
Dict{String, Int64} with 1 entry:
  &quot;a&quot; =&gt; 1

julia&gt; delete!(d, &quot;b&quot;) # d is left unchanged
Dict{String, Int64} with 1 entry:
  &quot;a&quot; =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L636-L656">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete_method-Tuple{Method}" href="#Base.delete_method-Tuple{Method}"><code>Base.delete_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_method(m::Method)</code></pre><p>Make method <code>m</code> uncallable and force recompilation of any methods that use(d) it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1529-L1533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.deleteat!-Tuple{Vector{T} where T, Any}" href="#Base.deleteat!-Tuple{Vector{T} where T, Any}"><code>Base.deleteat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deleteat!(a::Vector, inds)</code></pre><p>Remove the items at the indices given by <code>inds</code>, and return the modified <code>a</code>. Subsequent items are shifted to fill the resulting gap.</p><p><code>inds</code> can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as <code>a</code> with <code>true</code> indicating entries to delete.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Vector{Int64}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])
3-element Vector{Int64}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], (2, 2))
ERROR: ArgumentError: indices must be unique and sorted
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1347-L1375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.deleteat!-Tuple{Vector{T} where T, Integer}" href="#Base.deleteat!-Tuple{Vector{T} where T, Integer}"><code>Base.deleteat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deleteat!(a::Vector, i::Integer)</code></pre><p>Remove the item at the given <code>i</code> and return the modified <code>a</code>. Subsequent items are shifted to fill the resulting gap.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 2)
5-element Vector{Int64}:
 6
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1322-L1338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.denominator-Tuple{Integer}" href="#Base.denominator-Tuple{Integer}"><code>Base.denominator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">denominator(x)</code></pre><p>Denominator of the rational representation of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; denominator(2//3)
3

julia&gt; denominator(4)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/rational.jl#L237-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.detach-Tuple{Cmd}" href="#Base.detach-Tuple{Cmd}"><code>Base.detach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detach(command)</code></pre><p>Mark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/cmd.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.diff-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#Base.diff-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>Base.diff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diff(A::AbstractVector)
diff(A::AbstractArray; dims::Integer)</code></pre><p>Finite difference operator on a vector or a multidimensional array <code>A</code>. In the latter case the dimension to operate on needs to be specified with the <code>dims</code> keyword argument.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>diff</code> for arrays with dimension higher than 2 requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [2 4; 6 16]
2×2 Matrix{Int64}:
 2   4
 6  16

julia&gt; diff(a, dims=2)
2×1 Matrix{Int64}:
  2
 10

julia&gt; diff(vec(a))
3-element Vector{Int64}:
  4
 -2
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/multidimensional.jl#L924-L953">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.digits!-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Integer" href="#Base.digits!-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Integer"><code>Base.digits!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">digits!(array, n::Integer; base::Integer = 10)</code></pre><p>Fills an array of the digits of <code>n</code> in the given base. More significant digits are at higher indices. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; digits!([2,2,2,2], 10, base = 2)
4-element Vector{Int64}:
 0
 1
 0
 1

julia&gt; digits!([2,2,2,2,2,2], 10, base = 2)
6-element Vector{Int64}:
 0
 1
 0
 1
 0
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L850-L875">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.digits-Tuple{Integer}" href="#Base.digits-Tuple{Integer}"><code>Base.digits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">digits([T&lt;:Integer], n::Integer; base::T = 10, pad::Integer = 1)</code></pre><p>Return an array with element type <code>T</code> (default <code>Int</code>) of the digits of <code>n</code> in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indices, such that <code>n == sum(digits[k]*base^(k-1) for k=1:length(digits))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; digits(10, base = 10)
2-element Vector{Int64}:
 0
 1

julia&gt; digits(10, base = 2)
4-element Vector{Int64}:
 0
 1
 0
 1

julia&gt; digits(10, base = 2, pad = 6)
6-element Vector{Int64}:
 0
 1
 0
 1
 0
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L804-L834">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.disable_sigint-Tuple{Function}" href="#Base.disable_sigint-Tuple{Function}"><code>Base.disable_sigint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disable_sigint(f::Function)</code></pre><p>Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using <code>do</code> block syntax as follows:</p><pre><code class="nohighlight hljs">disable_sigint() do
    # interrupt-unsafe code
    ...
end</code></pre><p>This is not needed on worker threads (<code>Threads.threadid() != 1</code>) since the <code>InterruptException</code> will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L439-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.displaysize-Tuple{IO}" href="#Base.displaysize-Tuple{IO}"><code>Base.displaysize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">displaysize([io::IO]) -&gt; (lines, columns)</code></pre><p>Return the nominal size of the screen that may be used for rendering output to this <code>IO</code> object. If no input is provided, the environment variables <code>LINES</code> and <code>COLUMNS</code> are read. If those are not set, a default size of <code>(24, 80)</code> is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; withenv(&quot;LINES&quot; =&gt; 30, &quot;COLUMNS&quot; =&gt; 100) do
           displaysize()
       end
(30, 100)</code></pre><p>To get your TTY size,</p><pre><code class="language-julia hljs">julia&gt; displaysize(stdout)
(34, 147)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L488-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.div" href="#Base.div"><code>Base.div</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">div(x, y)
÷(x, y)</code></pre><p>The quotient from Euclidean division. Computes <code>x/y</code>, truncated to an integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 9 ÷ 4
2

julia&gt; -5 ÷ 3
-1

julia&gt; 5.0 ÷ 2
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L743-L760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.div-Tuple{Any, Any, RoundingMode}" href="#Base.div-Tuple{Any, Any, RoundingMode}"><code>Base.div</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">div(x, y, r::RoundingMode=RoundToZero)</code></pre><p>The quotient from Euclidean division. Computes x/y, rounded to an integer according to the rounding mode <code>r</code>. In other words, the quantity</p><pre><code class="nohighlight hljs">round(x/y,r)</code></pre><p>without any intermediate rounding.</p><p>See also: <a href="#Base.fld-Tuple{Any, Any}"><code>fld</code></a>, <a href="#Base.cld-Tuple{Any, Any}"><code>cld</code></a> which are special cases of this function</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; div(4, 3, RoundDown) # Matches fld(4, 3)
1
julia&gt; div(4, 3, RoundUp) # Matches cld(4, 3)
2
julia&gt; div(5, 2, RoundNearest)
2
julia&gt; div(5, 2, RoundNearestTiesAway)
3
julia&gt; div(-5, 2, RoundNearest)
-2
julia&gt; div(-5, 2, RoundNearestTiesAway)
-3
julia&gt; div(-5, 2, RoundNearestTiesUp)
-2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/div.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.div12-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractFloat" href="#Base.div12-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractFloat"><code>Base.div12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zhi, zlo = div12(x, y)</code></pre><p>A high-precision representation of <code>x / y</code> for floating-point numbers. Mathematically, <code>zhi + zlo ≈ x / y</code>, where <code>zhi</code> contains the most significant bits and <code>zlo</code> the least significant.</p><p>Example: ```julia julia&gt; x, y = Float32(π), 3.1f0 (3.1415927f0, 3.1f0)</p><p>julia&gt; x / y 1.013417f0</p><p>julia&gt; Float64(x) / Float64(y) 1.0134170444063078</p><p>julia&gt; hi, lo = Base.div12(x, y) (1.013417f0, 3.8867366f-8)</p><p>julia&gt; Float64(hi) + Float64(lo) 1.0134170444063066</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/twiceprecision.jl#L121-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.divrem-Tuple{Any, Any}" href="#Base.divrem-Tuple{Any, Any}"><code>Base.divrem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divrem(x, y, r::RoundingMode=RoundToZero)</code></pre><p>The quotient and remainder from Euclidean division. Equivalent to <code>(div(x,y,r), rem(x,y,r))</code>. Equivalently, with the default value of <code>r</code>, this call is equivalent to <code>(x÷y, x%y)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; divrem(3,7)
(0, 3)

julia&gt; divrem(7,3)
(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/div.jl#L104-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.download-Tuple{AbstractString, AbstractString}" href="#Base.download-Tuple{AbstractString, AbstractString}"><code>Base.download</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">download(url::AbstractString, [path::AbstractString = tempname()]) -&gt; path</code></pre><p>Download a file from the given url, saving it to the location <code>path</code>, or if not specified, a temporary path. Returns the path of the downloaded file.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Since Julia 1.6, this function is deprecated and is just a thin wrapper around <code>Downloads.download</code>. In new code, you should use that function directly instead of calling this.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/download.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.dropdims-Tuple{Any}" href="#Base.dropdims-Tuple{Any}"><code>Base.dropdims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dropdims(A; dims)</code></pre><p>Remove the dimensions specified by <code>dims</code> from array <code>A</code>. Elements of <code>dims</code> must be unique and within the range <code>1:ndims(A)</code>. <code>size(A,i)</code> must equal 1 for all <code>i</code> in <code>dims</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = reshape(Vector(1:4),(2,2,1,1))
2×2×1×1 Array{Int64, 4}:
[:, :, 1, 1] =
 1  3
 2  4

julia&gt; dropdims(a; dims=3)
2×2×1 Array{Int64, 3}:
[:, :, 1] =
 1  3
 2  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarraymath.jl#L48-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.dump-Tuple{Any}" href="#Base.dump-Tuple{Any}"><code>Base.dump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dump(x; maxdepth=8)</code></pre><p>Show every part of the representation of a value. The depth of the output is truncated at <code>maxdepth</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct MyStruct
           x
           y
       end

julia&gt; x = MyStruct(1, (2,3));

julia&gt; dump(x)
MyStruct
  x: Int64 1
  y: Tuple{Int64, Int64}
    1: Int64 2
    2: Int64 3

julia&gt; dump(x; maxdepth = 1)
MyStruct
  x: Int64 1
  y: Tuple{Int64, Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L2527-L2554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachcol-Tuple{AbstractVecOrMat{T} where T}" href="#Base.eachcol-Tuple{AbstractVecOrMat{T} where T}"><code>Base.eachcol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachcol(A::AbstractVecOrMat)</code></pre><p>Create a generator that iterates over the second dimension of matrix <code>A</code>, returning the columns as <code>AbstractVector</code> views.</p><p>See also <a href="#Base.eachrow-Tuple{AbstractVecOrMat{T} where T}"><code>eachrow</code></a> and <a href="#Base.eachslice-Tuple{AbstractArray}"><code>eachslice</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; first(eachcol(a))
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:
 1
 3

julia&gt; collect(eachcol(a))
2-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:
 [1, 3]
 [2, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarraymath.jl#L422-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachindex-Tuple{AbstractArray}" href="#Base.eachindex-Tuple{AbstractArray}"><code>Base.eachindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachindex(A...)</code></pre><p>Create an iterable object for visiting each index of an <code>AbstractArray</code> <code>A</code> in an efficient manner. For array types that have opted into fast linear indexing (like <code>Array</code>), this is simply the range <code>1:length(A)</code>. For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).</p><p>If you supply more than one <code>AbstractArray</code> argument, <code>eachindex</code> will create an iterable object that is fast for all arguments (a <a href="#Base.UnitRange"><code>UnitRange</code></a> if all inputs have fast linear indexing, a <a href="@ref"><code>CartesianIndices</code></a> otherwise). If the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception will be thrown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4];

julia&gt; for i in eachindex(A) # linear indexing
           println(i)
       end
1
2
3
4

julia&gt; for i in eachindex(view(A, 1:2, 1:1)) # Cartesian indexing
           println(i)
       end
CartesianIndex(1, 1)
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L266-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachline" href="#Base.eachline"><code>Base.eachline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachline(io::IO=stdin; keep::Bool=false)
eachline(filename::AbstractString; keep::Bool=false)</code></pre><p>Create an iterable <code>EachLine</code> object that will yield each line from an I/O stream or a file. Iteration calls <a href="#Base.readline-Tuple{AbstractString}"><code>readline</code></a> on the stream argument repeatedly with <code>keep</code> passed through, determining whether trailing end-of-line characters are retained. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the <code>EachLine</code> object is garbage collected.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; open(&quot;my_file.txt&quot;, &quot;w&quot;) do io
           write(io, &quot;JuliaLang is a GitHub organization.\n It has many members.\n&quot;);
       end;

julia&gt; for line in eachline(&quot;my_file.txt&quot;)
           print(line)
       end
JuliaLang is a GitHub organization. It has many members.

julia&gt; rm(&quot;my_file.txt&quot;);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L979-L1003">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachmatch-Tuple{Regex, AbstractString}" href="#Base.eachmatch-Tuple{Regex, AbstractString}"><code>Base.eachmatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachmatch(r::Regex, s::AbstractString; overlap::Bool=false)</code></pre><p>Search for all matches of the regular expression <code>r</code> in <code>s</code> and return an iterator over the matches. If <code>overlap</code> is <code>true</code>, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rx = r&quot;a.a&quot;
r&quot;a.a&quot;

julia&gt; m = eachmatch(rx, &quot;a1a2a3a&quot;)
Base.RegexMatchIterator(r&quot;a.a&quot;, &quot;a1a2a3a&quot;, false)

julia&gt; collect(m)
2-element Vector{RegexMatch}:
 RegexMatch(&quot;a1a&quot;)
 RegexMatch(&quot;a3a&quot;)

julia&gt; collect(eachmatch(rx, &quot;a1a2a3a&quot;, overlap = true))
3-element Vector{RegexMatch}:
 RegexMatch(&quot;a1a&quot;)
 RegexMatch(&quot;a2a&quot;)
 RegexMatch(&quot;a3a&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L611-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachrow-Tuple{AbstractVecOrMat{T} where T}" href="#Base.eachrow-Tuple{AbstractVecOrMat{T} where T}"><code>Base.eachrow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachrow(A::AbstractVecOrMat)</code></pre><p>Create a generator that iterates over the first dimension of vector or matrix <code>A</code>, returning the rows as <code>AbstractVector</code> views.</p><p>See also <a href="#Base.eachcol-Tuple{AbstractVecOrMat{T} where T}"><code>eachcol</code></a> and <a href="#Base.eachslice-Tuple{AbstractArray}"><code>eachslice</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; first(eachrow(a))
2-element view(::Matrix{Int64}, 1, :) with eltype Int64:
 1
 2

julia&gt; collect(eachrow(a))
2-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:
 [1, 2]
 [3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarraymath.jl#L389-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachslice-Tuple{AbstractArray}" href="#Base.eachslice-Tuple{AbstractArray}"><code>Base.eachslice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachslice(A::AbstractArray; dims)</code></pre><p>Create a generator that iterates over dimensions <code>dims</code> of <code>A</code>, returning views that select all the data from the other dimensions in <code>A</code>.</p><p>Only a single dimension in <code>dims</code> is currently supported. Equivalent to <code>(view(A,:,:,...,i,:,: ...)) for i in axes(A, dims))</code>, where <code>i</code> is in position <code>dims</code>.</p><p>See also <a href="#Base.eachrow-Tuple{AbstractVecOrMat{T} where T}"><code>eachrow</code></a>, <a href="#Base.eachcol-Tuple{AbstractVecOrMat{T} where T}"><code>eachcol</code></a>, and <a href="#Base.selectdim-Tuple{AbstractArray, Integer, Any}"><code>selectdim</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; M = [1 2 3; 4 5 6; 7 8 9]
3×3 Matrix{Int64}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; first(eachslice(M, dims=1))
3-element view(::Matrix{Int64}, 1, :) with eltype Int64:
 1
 2
 3

julia&gt; collect(eachslice(M, dims=2))
3-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:
 [1, 4, 7]
 [2, 5, 8]
 [3, 6, 9]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarraymath.jl#L454-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.elsize-Tuple{AbstractArray}" href="#Base.elsize-Tuple{AbstractArray}"><code>Base.elsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elsize(type)</code></pre><p>Compute the memory stride in bytes between consecutive elements of <code>eltype</code> stored inside the given <code>type</code>, if the array elements are stored densely with a uniform linear stride.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L190-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Tuple{Type}" href="#Base.eltype-Tuple{Type}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype(type)</code></pre><p>Determine the type of the elements generated by iterating a collection of the given <code>type</code>. For dictionary types, this will be a <code>Pair{KeyType,ValType}</code>. The definition <code>eltype(x) = eltype(typeof(x))</code> is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eltype(fill(1f0, (2,2)))
Float32

julia&gt; eltype(fill(0x1, (2,2)))
UInt8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L167-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty!-Union{Tuple{Dict{K, V}}, Tuple{V}, Tuple{K}} where {K, V}" href="#Base.empty!-Union{Tuple{Dict{K, V}}, Tuple{V}, Tuple{K}} where {K, V}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty!(collection) -&gt; collection</code></pre><p>Remove all elements from a <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)
Dict{String, Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; empty!(A);

julia&gt; A
Dict{String, Int64}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L247-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty-Tuple{AbstractDict}" href="#Base.empty-Tuple{AbstractDict}"><code>Base.empty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty(a::AbstractDict, [index_type=keytype(a)], [value_type=valtype(a)])</code></pre><p>Create an empty <code>AbstractDict</code> container which can accept indices of type <code>index_type</code> and values of type <code>value_type</code>. The second and third arguments are optional and default to the input&#39;s <code>keytype</code> and <code>valtype</code>, respectively. (If only one of the two types is specified, it is assumed to be the <code>value_type</code>, and the <code>index_type</code> we default to <code>keytype(a)</code>).</p><p>Custom <code>AbstractDict</code> subtypes may choose which specific dictionary type is best suited to return for the given index and value types, by specializing on the three-argument signature. The default is to return an empty <code>Dict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L142-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty-Tuple{Tuple}" href="#Base.empty-Tuple{Tuple}"><code>Base.empty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty(x::Tuple)</code></pre><p>Returns an empty tuple, <code>()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/tuple.jl#L517-L521">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty-Union{Tuple{AbstractVector{T}}, Tuple{U}, Tuple{T}, Tuple{AbstractVector{T}, Type{U}}} where {T, U}" href="#Base.empty-Union{Tuple{AbstractVector{T}}, Tuple{U}, Tuple{T}, Tuple{AbstractVector{T}, Type{U}}} where {T, U}"><code>Base.empty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">empty(v::AbstractVector, [eltype])</code></pre><p>Create an empty vector similar to <code>v</code>, optionally changing the <code>eltype</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; empty([1.0, 2.0, 3.0])
Float64[]

julia&gt; empty([1.0, 2.0, 3.0], String)
String[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L787-L801">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.endswith-Tuple{AbstractString, AbstractString}" href="#Base.endswith-Tuple{AbstractString, AbstractString}"><code>Base.endswith</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">endswith(s::AbstractString, suffix::AbstractString)</code></pre><p>Return <code>true</code> if <code>s</code> ends with <code>suffix</code>. If <code>suffix</code> is a vector or set of characters, test whether the last character of <code>s</code> belongs to that set.</p><p>See also <a href="#Base.startswith-Tuple{AbstractString, AbstractString}"><code>startswith</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; endswith(&quot;Sunday&quot;, &quot;day&quot;)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L27-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.endswith-Tuple{AbstractString, Regex}" href="#Base.endswith-Tuple{AbstractString, Regex}"><code>Base.endswith</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">endswith(s::AbstractString, suffix::Regex)</code></pre><p>Return <code>true</code> if <code>s</code> ends with the regex pattern, <code>suffix</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>endswith</code> does not compile the anchoring into the regular expression, but instead passes the anchoring as <code>match_option</code> to PCRE. If compile time is amortized, <code>occursin(r&quot;...$&quot;, s)</code> is faster than <code>endswith(s, r&quot;...&quot;)</code>.</p></div></div><p>See also <a href="#Base.occursin-Tuple{Any}"><code>occursin</code></a> and <a href="#Base.startswith-Tuple{AbstractString, AbstractString}"><code>startswith</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This method requires at least Julia 1.2.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; endswith(&quot;JuliaLang&quot;, r&quot;Lang|Roberts&quot;)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L234-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.endswith-Tuple{Any}" href="#Base.endswith-Tuple{Any}"><code>Base.endswith</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">endswith(suffix)</code></pre><p>Create a function that checks whether its argument ends with <code>suffix</code>, i.e. a function equivalent to <code>y -&gt; endswith(y, suffix)</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(endswith)}</code>, which can be used to implement specialized methods.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The single argument <code>endswith(suffix)</code> requires at least Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; endswith_julia = endswith(&quot;Julia&quot;);

julia&gt; endswith_julia(&quot;Julia&quot;)
true

julia&gt; endswith_julia(&quot;JuliaLang&quot;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L100-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eof-Tuple{Base.AbstractPipe}" href="#Base.eof-Tuple{Base.AbstractPipe}"><code>Base.eof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eof(stream) -&gt; Bool</code></pre><p>Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return <code>false</code>. Therefore it is always safe to read one byte after seeing <code>eof</code> return <code>false</code>. <code>eof</code> will return <code>false</code> as long as buffered data is still available, even if the remote end of a connection is closed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L405-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eps-Tuple{AbstractFloat}" href="#Base.eps-Tuple{AbstractFloat}"><code>Base.eps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eps(x::AbstractFloat)</code></pre><p>Return the <em>unit in last place</em> (ulp) of <code>x</code>. This is the distance between consecutive representable floating point values at <code>x</code>. In most cases, if the distance on either side of <code>x</code> is different, then the larger of the two is taken, that is</p><pre><code class="nohighlight hljs">eps(x) == max(x-prevfloat(x), nextfloat(x)-x)</code></pre><p>The exceptions to this rule are the smallest and largest finite values (e.g. <code>nextfloat(-Inf)</code> and <code>prevfloat(Inf)</code> for <a href="@ref"><code>Float64</code></a>), which round to the smaller of the values.</p><p>The rationale for this behavior is that <code>eps</code> bounds the floating point rounding error. Under the default <code>RoundNearest</code> rounding mode, if <span>$y$</span> is a real number and <span>$x$</span> is the nearest floating point number to <span>$y$</span>, then</p><p class="math-container">\[|y-x| \leq \operatorname{eps}(x)/2.\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eps(1.0)
2.220446049250313e-16

julia&gt; eps(prevfloat(2.0))
2.220446049250313e-16

julia&gt; eps(2.0)
4.440892098500626e-16

julia&gt; x = prevfloat(Inf)      # largest finite Float64
1.7976931348623157e308

julia&gt; x + eps(x)/2            # rounds up
Inf

julia&gt; x + prevfloat(eps(x)/2) # rounds down
1.7976931348623157e308</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L835-L876">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eps-Tuple{Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:AbstractFloat}" href="#Base.eps-Tuple{Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:AbstractFloat}"><code>Base.eps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eps(::Type{T}) where T&lt;:AbstractFloat
eps()</code></pre><p>Return the <em>machine epsilon</em> of the floating point type <code>T</code> (<code>T = Float64</code> by default). This is defined as the gap between 1 and the next largest value representable by <code>typeof(one(T))</code>, and is equivalent to <code>eps(one(T))</code>.  (Since <code>eps(T)</code> is a bound on the <em>relative error</em> of <code>T</code>, it is a &quot;dimensionless&quot; quantity like <a href="#Base.one-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Number"><code>one</code></a>.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eps()
2.220446049250313e-16

julia&gt; eps(Float32)
1.1920929f-7

julia&gt; 1.0 + eps()
1.0000000000000002

julia&gt; 1.0 + eps()/2
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L809-L832">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.error-Tuple{AbstractString}" href="#Base.error-Tuple{AbstractString}"><code>Base.error</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">error(message::AbstractString)</code></pre><p>Raise an <code>ErrorException</code> with the given message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.error-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N" href="#Base.error-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N"><code>Base.error</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">error(msg...)</code></pre><p>Raise an <code>ErrorException</code> with the given message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.esc-Tuple{Any}" href="#Base.esc-Tuple{Any}"><code>Base.esc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">esc(e)</code></pre><p>Only valid in the context of an <a href="@ref"><code>Expr</code></a> returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the <a href="@ref man-macros">Macros</a> section of the Metaprogramming chapter of the manual for more details and examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L473-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.escape_microsoft_c_args-Tuple{IO, Vararg{AbstractString, N} where N}" href="#Base.escape_microsoft_c_args-Tuple{IO, Vararg{AbstractString, N} where N}"><code>Base.escape_microsoft_c_args</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">escape_microsoft_c_args(args::Union{Cmd,AbstractString...})
escape_microsoft_c_args(io::IO, args::Union{Cmd,AbstractString...})</code></pre><p>Convert a collection of string arguments into a string that can be passed to many Windows command-line applications.</p><p>Microsoft Windows passes the entire command line as a single string to the application (unlike POSIX systems, where the shell splits the command line into a list of arguments). Many Windows API applications (including julia.exe), use the conventions of the <a href="https://docs.microsoft.com/en-us/cpp/c-language/parsing-c-command-line-arguments">Microsoft C/C++ runtime</a> to split that command line into a list of strings.</p><p>This function implements an inverse for a parser compatible with these rules. It joins command-line arguments to be passed to a Windows C/C++/Julia application into a command line, escaping or quoting the meta characters space, TAB, double quote and backslash where needed.</p><p>See also: <a href="#Base.shell_escape_wincmd-Tuple{IO, AbstractString}"><code>shell_escape_wincmd</code></a>, <a href="#Base.escape_raw_string-Tuple{Any, AbstractString}"><code>escape_raw_string</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/shell.jl#L360-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.escape_raw_string-Tuple{Any, AbstractString}" href="#Base.escape_raw_string-Tuple{Any, AbstractString}"><code>Base.escape_raw_string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">escape_raw_string(s::AbstractString)
escape_raw_string(io, s::AbstractString)</code></pre><p>Escape a string in the manner used for parsing raw string literals. For each double-quote (<code>&quot;</code>) character in input string <code>s</code>, this function counts the number <em>n</em> of preceeding backslash (<code>\</code>) characters, and then increases there the number of backslashes from <em>n</em> to 2<em>n</em>+1 (even for <em>n</em> = 0). It also doubles a sequence of backslashes at the end of the string.</p><p>This escaping convention is used in raw strings and other non-standard string literals. (It also happens to be the escaping convention expected by the Microsoft C/C++ compiler runtime when it parses a command-line string into the argv[] array.)</p><p>See also: <a href="#Base.escape_string"><code>escape_string</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L518-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.escape_string" href="#Base.escape_string"><code>Base.escape_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">escape_string(str::AbstractString[, esc])::AbstractString
escape_string(io, str::AbstractString[, esc::])::Nothing</code></pre><p>General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to <code>io</code>.</p><p>Backslashes (<code>\</code>) are escaped with a double-backslash (<code>&quot;\\&quot;</code>). Non-printable characters are escaped either with their standard C escape codes, <code>&quot;\0&quot;</code> for NUL (if unambiguous), unicode code point (<code>&quot;\u&quot;</code> prefix) or hex (<code>&quot;\x&quot;</code> prefix).</p><p>The optional <code>esc</code> argument specifies any additional characters that should also be escaped by a prepending backslash (<code>&quot;</code> is also escaped by default in the first form).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; escape_string(&quot;aaa\nbbb&quot;)
&quot;aaa\\nbbb&quot;

julia&gt; escape_string(&quot;\xfe\xff&quot;) # invalid utf-8
&quot;\\xfe\\xff&quot;

julia&gt; escape_string(string(&#39;\u2135&#39;,&#39;\0&#39;)) # unambiguous
&quot;ℵ\\0&quot;

julia&gt; escape_string(string(&#39;\u2135&#39;,&#39;\0&#39;,&#39;0&#39;)) # \0 would be ambiguous
&quot;ℵ\\x000&quot;</code></pre><p><strong>See also</strong></p><p><a href="#Base.unescape_string"><code>unescape_string</code></a> for the reverse operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L302-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.evalfile" href="#Base.evalfile"><code>Base.evalfile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evalfile(path::AbstractString, args::Vector{String}=String[])</code></pre><p>Load the file using <a href="#Base.include"><code>include</code></a>, evaluate all expressions, and return the value of the last one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L1180-L1185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exit-Tuple{Any}" href="#Base.exit-Tuple{Any}"><code>Base.exit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exit(code=0)</code></pre><p>Stop the program with an exit code. The default exit code is zero, indicating that the program completed successfully. In an interactive session, <code>exit()</code> can be called with the keyboard shortcut <code>^D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/initdefs.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exit_on_sigint-Tuple{Bool}" href="#Base.exit_on_sigint-Tuple{Bool}"><code>Base.exit_on_sigint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exit_on_sigint(on::Bool)</code></pre><p>Set <code>exit_on_sigint</code> flag of the julia runtime.  If <code>false</code>, Ctrl-C (SIGINT) is capturable as <a href="@ref"><code>InterruptException</code></a> in <code>try</code> block. This is the default behavior in REPL, any code run via <code>-e</code> and <code>-E</code> and in Julia script run with <code>-i</code> option.</p><p>If <code>true</code>, <code>InterruptException</code> is not thrown by Ctrl-C.  Running code upon such event requires <a href="#Base.atexit-Tuple{Function}"><code>atexit</code></a>.  This is the default behavior in Julia script run without <code>-i</code> option.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Function <code>exit_on_sigint</code> requires at least Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L478-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.extrema-Tuple{AbstractArray}" href="#Base.extrema-Tuple{AbstractArray}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extrema(A::AbstractArray; dims) -&gt; Array{Tuple}</code></pre><p>Compute the minimum and maximum elements of an array over the given dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(Vector(1:2:16), (2,2,2))
2×2×2 Array{Int64, 3}:
[:, :, 1] =
 1  5
 3  7

[:, :, 2] =
  9  13
 11  15

julia&gt; extrema(A, dims = (1,2))
1×1×2 Array{Tuple{Int64, Int64}, 3}:
[:, :, 1] =
 (1, 7)

[:, :, 2] =
 (9, 15)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/multidimensional.jl#L1659-L1684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.extrema-Tuple{Any, AbstractArray}" href="#Base.extrema-Tuple{Any, AbstractArray}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extrema(f, A::AbstractArray; dims) -&gt; Array{Tuple}</code></pre><p>Compute the minimum and maximum of <code>f</code> applied to each element in the given dimensions of <code>A</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This method requires Julia 1.2 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/multidimensional.jl#L1687-L1695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.extrema-Tuple{Any, Any}" href="#Base.extrema-Tuple{Any, Any}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extrema(f, itr) -&gt; Tuple</code></pre><p>Compute both the minimum and maximum of <code>f</code> applied to each element in <code>itr</code> and return them as a 2-tuple. Only one pass is made over <code>itr</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This method requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; extrema(sin, 0:π)
(0.0, 0.9092974268256817)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L464-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.extrema-Tuple{Any}" href="#Base.extrema-Tuple{Any}"><code>Base.extrema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extrema(itr) -&gt; Tuple</code></pre><p>Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; extrema(2:10)
(2, 10)

julia&gt; extrema([9,pi,4.5])
(3.141592653589793, 9.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L448-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.factorial-Tuple{Integer}" href="#Base.factorial-Tuple{Integer}"><code>Base.factorial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factorial(n::Integer)</code></pre><p>Factorial of <code>n</code>. If <code>n</code> is an <a href="@ref"><code>Integer</code></a>, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if <code>n</code> is not small, but you can use <code>factorial(big(n))</code> to compute the result exactly in arbitrary precision.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; factorial(6)
720

julia&gt; factorial(21)
ERROR: OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead
Stacktrace:
[...]

julia&gt; factorial(big(21))
51090942171709440000</code></pre><p><strong>See also</strong></p><ul><li><a href="#Base.binomial-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>binomial</code></a></li></ul><p><strong>External links</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Factorial">Factorial</a> on Wikipedia.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L931-L957">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.falses-Tuple{Vararg{Union{Integer, AbstractUnitRange}, N} where N}" href="#Base.falses-Tuple{Vararg{Union{Integer, AbstractUnitRange}, N} where N}"><code>Base.falses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">falses(dims)</code></pre><p>Create a <code>BitArray</code> with all values set to <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; falses(2,3)
2×3 BitMatrix:
 0  0  0
 0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bitarray.jl#L390-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fd-Tuple{IOStream}" href="#Base.fd-Tuple{IOStream}"><code>Base.fd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fd(stream)</code></pre><p>Return the file descriptor backing the stream or file. Note that this function only applies to synchronous <code>File</code>&#39;s and <code>IOStream</code>&#39;s not to any of the asynchronous streams.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fdio" href="#Base.fdio"><code>Base.fdio</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -&gt; IOStream</code></pre><p>Create an <a href="#Base.IOStream"><code>IOStream</code></a> object from an integer file descriptor. If <code>own</code> is <code>true</code>, closing this object will close the underlying descriptor. By default, an <code>IOStream</code> is closed when it is garbage collected. <code>name</code> allows you to associate the descriptor with a named file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L238-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fetch-Tuple{Channel}" href="#Base.fetch-Tuple{Channel}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fetch(c::Channel)</code></pre><p>Wait for and get the first available item from the channel. Does not remove the item. <code>fetch</code> is unsupported on an unbuffered (0-size) channel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/channels.jl#L353-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fetch-Tuple{Task}" href="#Base.fetch-Tuple{Task}"><code>Base.fetch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fetch(t::Task)</code></pre><p>Wait for a Task to finish, then return its result value. If the task fails with an exception, a <code>TaskFailedException</code> (which wraps the failed task) is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L329-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldcount-Tuple{Any}" href="#Base.fieldcount-Tuple{Any}"><code>Base.fieldcount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fieldcount(t::Type)</code></pre><p>Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L697-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldindex" href="#Base.fieldindex"><code>Base.fieldindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.fieldindex(T, name::Symbol, err:Bool=true)</code></pre><p>Get the index of a named field, throwing an error if the field does not exist (when err==true) or returning 0 (when err==false).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           x::Int64
           y::String
       end

julia&gt; Base.fieldindex(Foo, :z)
ERROR: type Foo has no field z
Stacktrace:
[...]

julia&gt; Base.fieldindex(Foo, :z, false)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L661-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldname-Tuple{DataType, Integer}" href="#Base.fieldname-Tuple{DataType, Integer}"><code>Base.fieldname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fieldname(x::DataType, i::Integer)</code></pre><p>Get the name of field <code>i</code> of a <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fieldname(Rational, 1)
:num

julia&gt; fieldname(Rational, 2)
:den</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L131-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldnames-Tuple{DataType}" href="#Base.fieldnames-Tuple{DataType}"><code>Base.fieldnames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fieldnames(x::DataType)</code></pre><p>Get a tuple with the names of the fields of a <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fieldnames(Rational)
(:num, :den)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L165-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldoffset-Tuple{DataType, Integer}" href="#Base.fieldoffset-Tuple{DataType, Integer}"><code>Base.fieldoffset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fieldoffset(type, i)</code></pre><p>The byte offset of field <code>i</code> of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:</p><pre><code class="language-julia-repl hljs">julia&gt; structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];

julia&gt; structinfo(Base.Filesystem.StatStruct)
12-element Vector{Tuple{UInt64, Symbol, DataType}}:
 (0x0000000000000000, :device, UInt64)
 (0x0000000000000008, :inode, UInt64)
 (0x0000000000000010, :mode, UInt64)
 (0x0000000000000018, :nlink, Int64)
 (0x0000000000000020, :uid, UInt64)
 (0x0000000000000028, :gid, UInt64)
 (0x0000000000000030, :rdev, UInt64)
 (0x0000000000000038, :size, Int64)
 (0x0000000000000040, :blksize, Int64)
 (0x0000000000000048, :blocks, Int64)
 (0x0000000000000050, :mtime, Float64)
 (0x0000000000000058, :ctime, Float64)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L613-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fieldtypes-Tuple{Type}" href="#Base.fieldtypes-Tuple{Type}"><code>Base.fieldtypes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fieldtypes(T::Type)</code></pre><p>The declared types of all fields in a composite DataType <code>T</code> as a tuple.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           x::Int64
           y::String
       end

julia&gt; fieldtypes(Foo)
(Int64, String)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L737-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fill" href="#Base.fill"><code>Base.fill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fill(x, dims::Tuple)
fill(x, dims...)</code></pre><p>Create an array filled with the value <code>x</code>. For example, <code>fill(1.0, (5,5))</code> returns a 5×5 array of floats, with each element initialized to <code>1.0</code>.</p><p><code>dims</code> may be specified as either a tuple or a sequence of arguments. For example, the common idiom <code>fill(x)</code> creates a zero-dimensional array containing the single value <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fill(1.0, (2,3))
2×3 Matrix{Float64}:
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; fill(42)
0-dimensional Array{Int64, 0}:
42</code></pre><p>If <code>x</code> is an object reference, all elements will refer to the same object:</p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(zeros(2), 2);

julia&gt; A[1][1] = 42; # modifies both A[1][1] and A[2][1]

julia&gt; A
2-element Vector{Vector{Float64}}:
 [42.0, 0.0]
 [42.0, 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L413-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fill!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T" href="#Base.fill!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T"><code>Base.fill!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill!(A, x)</code></pre><p>Fill array <code>A</code> with the value <code>x</code>. If <code>x</code> is an object reference, all elements will refer to the same object. <code>fill!(A, Foo())</code> will return <code>A</code> filled with the result of evaluating <code>Foo()</code> once.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(2,3)
2×3 Matrix{Float64}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; fill!(A, 2.)
2×3 Matrix{Float64}:
 2.0  2.0  2.0
 2.0  2.0  2.0

julia&gt; a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(undef, 3), a); a[1] = 2; A
3-element Vector{Vector{Int64}}:
 [2, 1, 1]
 [2, 1, 1]
 [2, 1, 1]

julia&gt; x = 0; f() = (global x += 1; x); fill!(Vector{Int}(undef, 3), f())
3-element Vector{Int64}:
 1
 1
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/multidimensional.jl#L1022-L1053">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter!-Tuple{Any, AbstractDict}" href="#Base.filter!-Tuple{Any, AbstractDict}"><code>Base.filter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter!(f, d::AbstractDict)</code></pre><p>Update <code>d</code>, removing elements for which <code>f</code> is <code>false</code>. The function <code>f</code> is passed <code>key=&gt;value</code> pairs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(1=&gt;&quot;a&quot;, 2=&gt;&quot;b&quot;, 3=&gt;&quot;c&quot;)
Dict{Int64, String} with 3 entries:
  2 =&gt; &quot;b&quot;
  3 =&gt; &quot;c&quot;
  1 =&gt; &quot;a&quot;

julia&gt; filter!(p-&gt;isodd(p.first), d)
Dict{Int64, String} with 2 entries:
  3 =&gt; &quot;c&quot;
  1 =&gt; &quot;a&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L369-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter!-Tuple{Any, AbstractVector{T} where T}" href="#Base.filter!-Tuple{Any, AbstractVector{T} where T}"><code>Base.filter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter!(f, a)</code></pre><p>Update collection <code>a</code>, removing elements for which <code>f</code> is <code>false</code>. The function <code>f</code> is passed one argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; filter!(isodd, Vector(1:10))
5-element Vector{Int64}:
 1
 3
 5
 7
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2531-L2547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter-Tuple{Any, AbstractDict}" href="#Base.filter-Tuple{Any, AbstractDict}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter(f, d::AbstractDict)</code></pre><p>Return a copy of <code>d</code>, removing elements for which <code>f</code> is <code>false</code>. The function <code>f</code> is passed <code>key=&gt;value</code> pairs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(1=&gt;&quot;a&quot;, 2=&gt;&quot;b&quot;)
Dict{Int64, String} with 2 entries:
  2 =&gt; &quot;b&quot;
  1 =&gt; &quot;a&quot;

julia&gt; filter(p-&gt;isodd(p.first), d)
Dict{Int64, String} with 1 entry:
  1 =&gt; &quot;a&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L411-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter-Tuple{Any, Base.SkipMissing{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:AbstractArray}" href="#Base.filter-Tuple{Any, Base.SkipMissing{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:AbstractArray}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter(f, itr::SkipMissing{&lt;:AbstractArray})</code></pre><p>Return a vector similar to the array wrapped by the given <code>SkipMissing</code> iterator but with all missing elements and those for which <code>f</code> returns <code>false</code> removed.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This method requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1 2; missing 4]
2×2 Matrix{Union{Missing, Int64}}:
 1         2
  missing  4

julia&gt; filter(isodd, skipmissing(x))
1-element Vector{Int64}:
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/missing.jl#L360-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter-Union{Tuple{N}, Tuple{T}, Tuple{Any, Array{T, N}}} where {T, N}" href="#Base.filter-Union{Tuple{N}, Tuple{T}, Tuple{Any, Array{T, N}}} where {T, N}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter(f, a)</code></pre><p>Return a copy of collection <code>a</code>, removing elements for which <code>f</code> is <code>false</code>. The function <code>f</code> is passed one argument.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>Support for <code>a</code> as a tuple requires at least Julia 1.4.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = 1:10
1:10

julia&gt; filter(isodd, a)
5-element Vector{Int64}:
 1
 3
 5
 7
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2479-L2501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.finalize-Tuple{Any}" href="#Base.finalize-Tuple{Any}"><code>Base.finalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finalize(x)</code></pre><p>Immediately run finalizers registered for object <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/gcutils.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.finalizer-Tuple{Any, Any}" href="#Base.finalizer-Tuple{Any, Any}"><code>Base.finalizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finalizer(f, x)</code></pre><p>Register a function <code>f(x)</code> to be called when there are no program-accessible references to <code>x</code>, and return <code>x</code>. The type of <code>x</code> must be a <code>mutable struct</code>, otherwise the behavior of this function is unpredictable.</p><p><code>f</code> must not cause a task switch, which excludes most I/O operations such as <code>println</code>. Using the <code>@async</code> macro (to defer context switching to outside of the finalizer) or <code>ccall</code> to directly invoke IO functions in C may be helpful for debugging purposes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">finalizer(my_mutable_struct) do x
    @async println(&quot;Finalizing $x.&quot;)
end

finalizer(my_mutable_struct) do x
    ccall(:jl_safe_printf, Cvoid, (Cstring, Cstring), &quot;Finalizing %s.&quot;, repr(x))
end</code></pre><p>A finalizer may be registered at object construction. In the following example note that we implicitly rely on the finalizer returning the newly created mutable struct <code>x</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mutable struct MyMutableStruct
    bar
    function MyMutableStruct(bar)
        x = new(bar)
        f(t) = @async println(&quot;Finalizing $t.&quot;)
        finalizer(f, x)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/gcutils.jl#L7-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findall-Tuple{Any}" href="#Base.findall-Tuple{Any}"><code>Base.findall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findall(A)</code></pre><p>Return a vector <code>I</code> of the <code>true</code> indices or keys of <code>A</code>. If there are no such elements of <code>A</code>, return an empty array. To search for other kinds of values, pass a predicate as the first argument.</p><p>Indices or keys are of the same type as those returned by <a href="#Base.keys"><code>keys(A)</code></a> and <a href="#Base.pairs-Tuple{Any}"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true, false, false, true]
4-element Vector{Bool}:
 1
 0
 0
 1

julia&gt; findall(A)
2-element Vector{Int64}:
 1
 4

julia&gt; A = [true false; false true]
2×2 Matrix{Bool}:
 1  0
 0  1

julia&gt; findall(A)
2-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 2)

julia&gt; findall(falses(3))
Int64[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2155-L2192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findall-Tuple{Function, Any}" href="#Base.findall-Tuple{Function, Any}"><code>Base.findall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findall(f::Function, A)</code></pre><p>Return a vector <code>I</code> of the indices or keys of <code>A</code> where <code>f(A[I])</code> returns <code>true</code>. If there are no such elements of <code>A</code>, return an empty array.</p><p>Indices or keys are of the same type as those returned by <a href="#Base.keys"><code>keys(A)</code></a> and <a href="#Base.pairs-Tuple{Any}"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [1, 3, 4]
3-element Vector{Int64}:
 1
 3
 4

julia&gt; findall(isodd, x)
2-element Vector{Int64}:
 1
 2

julia&gt; A = [1 2 0; 3 4 0]
2×3 Matrix{Int64}:
 1  2  0
 3  4  0
julia&gt; findall(isodd, A)
2-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)

julia&gt; findall(!iszero, A)
4-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)

julia&gt; d = Dict(:A =&gt; 10, :B =&gt; -1, :C =&gt; 0)
Dict{Symbol, Int64} with 3 entries:
  :A =&gt; 10
  :B =&gt; -1
  :C =&gt; 0

julia&gt; findall(x -&gt; x &gt;= 0, d)
2-element Vector{Symbol}:
 :A
 :C
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2102-L2152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findall-Tuple{Union{AbstractPattern, AbstractString}, AbstractString}" href="#Base.findall-Tuple{Union{AbstractPattern, AbstractString}, AbstractString}"><code>Base.findall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findall(
    pattern::Union{AbstractString,AbstractPattern},
    string::AbstractString;
    overlap::Bool = false,
)</code></pre><p>Return a <code>Vector{UnitRange{Int}}</code> of all the matches for <code>pattern</code> in <code>string</code>. Each element of the returned vector is a range of indices where the matching sequence is found, like the return value of <a href="#Base.findnext-Tuple{AbstractChar, AbstractString, Integer}"><code>findnext</code></a>.</p><p>If <code>overlap=true</code>, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findall(&quot;a&quot;, &quot;apple&quot;)
1-element Vector{UnitRange{Int64}}:
 1:1

julia&gt; findall(&quot;nana&quot;, &quot;banana&quot;)
1-element Vector{UnitRange{Int64}}:
 3:6

julia&gt; findall(&quot;a&quot;, &quot;banana&quot;)
3-element Vector{UnitRange{Int64}}:
 2:2
 4:4
 6:6</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L352-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findfirst-Tuple{AbstractChar, AbstractString}" href="#Base.findfirst-Tuple{AbstractChar, AbstractString}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findfirst(ch::AbstractChar, string::AbstractString)</code></pre><p>Find the first occurrence of character <code>ch</code> in <code>string</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findfirst(&#39;a&#39;, &quot;happy&quot;)
2

julia&gt; findfirst(&#39;z&#39;, &quot;happy&quot;) === nothing
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L107-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findfirst-Tuple{AbstractString, AbstractString}" href="#Base.findfirst-Tuple{AbstractString, AbstractString}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findfirst(pattern::AbstractString, string::AbstractString)
findfirst(pattern::AbstractPattern, string::String)</code></pre><p>Find the first occurrence of <code>pattern</code> in <code>string</code>. Equivalent to <a href="#Base.findnext-Tuple{AbstractChar, AbstractString, Integer}"><code>findnext(pattern, string, firstindex(s))</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findfirst(&quot;z&quot;, &quot;Hello to the world&quot;) # returns nothing, but not printed in the REPL

julia&gt; findfirst(&quot;Julia&quot;, &quot;JuliaLang&quot;)
1:5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L89-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findfirst-Tuple{AbstractVector{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Union{Int8, UInt8}, AbstractVector{var&quot;#s831&quot;} where var&quot;#s831&quot;&lt;:Union{Int8, UInt8}}" href="#Base.findfirst-Tuple{AbstractVector{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Union{Int8, UInt8}, AbstractVector{var&quot;#s831&quot;} where var&quot;#s831&quot;&lt;:Union{Int8, UInt8}}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findfirst(pattern::AbstractVector{&lt;:Union{Int8,UInt8}},
          A::AbstractVector{&lt;:Union{Int8,UInt8}})</code></pre><p>Find the first occurrence of sequence <code>pattern</code> in vector <code>A</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This method requires at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findfirst([0x52, 0x62], [0x40, 0x52, 0x62, 0x63])
2:3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L126-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findfirst-Tuple{Any}" href="#Base.findfirst-Tuple{Any}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findfirst(A)</code></pre><p>Return the index or key of the first <code>true</code> value in <code>A</code>. Return <code>nothing</code> if no such value is found. To search for other kinds of values, pass a predicate as the first argument.</p><p>Indices or keys are of the same type as those returned by <a href="#Base.keys"><code>keys(A)</code></a> and <a href="#Base.pairs-Tuple{Any}"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [false, false, true, false]
4-element Vector{Bool}:
 0
 0
 1
 0

julia&gt; findfirst(A)
3

julia&gt; findfirst(falses(3)) # returns nothing, but not printed in the REPL

julia&gt; A = [false false; true false]
2×2 Matrix{Bool}:
 0  0
 1  0

julia&gt; findfirst(A)
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1781-L1813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findfirst-Tuple{Function, Any}" href="#Base.findfirst-Tuple{Function, Any}"><code>Base.findfirst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findfirst(predicate::Function, A)</code></pre><p>Return the index or key of the first element of <code>A</code> for which <code>predicate</code> returns <code>true</code>. Return <code>nothing</code> if there is no such element.</p><p>Indices or keys are of the same type as those returned by <a href="#Base.keys"><code>keys(A)</code></a> and <a href="#Base.pairs-Tuple{Any}"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 4, 2, 2]
4-element Vector{Int64}:
 1
 4
 2
 2

julia&gt; findfirst(iseven, A)
2

julia&gt; findfirst(x -&gt; x&gt;10, A) # returns nothing, but not printed in the REPL

julia&gt; findfirst(isequal(4), A)
2

julia&gt; A = [1 4; 2 2]
2×2 Matrix{Int64}:
 1  4
 2  2

julia&gt; findfirst(iseven, A)
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1863-L1897">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findlast-Tuple{AbstractChar, AbstractString}" href="#Base.findlast-Tuple{AbstractChar, AbstractString}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findlast(ch::AbstractChar, string::AbstractString)</code></pre><p>Find the last occurrence of character <code>ch</code> in <code>string</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findlast(&#39;p&#39;, &quot;happy&quot;)
4

julia&gt; findlast(&#39;z&#39;, &quot;happy&quot;) === nothing
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L383-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findlast-Tuple{AbstractString, AbstractString}" href="#Base.findlast-Tuple{AbstractString, AbstractString}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findlast(pattern::AbstractString, string::AbstractString)</code></pre><p>Find the last occurrence of <code>pattern</code> in <code>string</code>. Equivalent to <a href="#Base.findprev-Tuple{AbstractChar, AbstractString, Integer}"><code>findprev(pattern, string, lastindex(string))</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findlast(&quot;o&quot;, &quot;Hello to the world&quot;)
15:15

julia&gt; findfirst(&quot;Julia&quot;, &quot;JuliaLang&quot;)
1:5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L348-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findlast-Tuple{AbstractVector{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Union{Int8, UInt8}, AbstractVector{var&quot;#s831&quot;} where var&quot;#s831&quot;&lt;:Union{Int8, UInt8}}" href="#Base.findlast-Tuple{AbstractVector{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Union{Int8, UInt8}, AbstractVector{var&quot;#s831&quot;} where var&quot;#s831&quot;&lt;:Union{Int8, UInt8}}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findlast(pattern::AbstractVector{&lt;:Union{Int8,UInt8}},
         A::AbstractVector{&lt;:Union{Int8,UInt8}})</code></pre><p>Find the last occurrence of <code>pattern</code> in array <code>A</code>. Equivalent to <a href="#Base.findprev-Tuple{AbstractChar, AbstractString, Integer}"><code>findprev(pattern, A, lastindex(A))</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findlast([0x52, 0x62], [0x52, 0x62, 0x52, 0x62])
3:4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L366-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findlast-Tuple{Any}" href="#Base.findlast-Tuple{Any}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findlast(A)</code></pre><p>Return the index or key of the last <code>true</code> value in <code>A</code>. Return <code>nothing</code> if there is no <code>true</code> value in <code>A</code>.</p><p>Indices or keys are of the same type as those returned by <a href="#Base.keys"><code>keys(A)</code></a> and <a href="#Base.pairs-Tuple{Any}"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [true, false, true, false]
4-element Vector{Bool}:
 1
 0
 1
 0

julia&gt; findlast(A)
3

julia&gt; A = falses(2,2);

julia&gt; findlast(A) # returns nothing, but not printed in the REPL

julia&gt; A = [true false; true false]
2×2 Matrix{Bool}:
 1  0
 1  0

julia&gt; findlast(A)
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1968-L2001">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findlast-Tuple{Function, Any}" href="#Base.findlast-Tuple{Function, Any}"><code>Base.findlast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findlast(predicate::Function, A)</code></pre><p>Return the index or key of the last element of <code>A</code> for which <code>predicate</code> returns <code>true</code>. Return <code>nothing</code> if there is no such element.</p><p>Indices or keys are of the same type as those returned by <a href="#Base.keys"><code>keys(A)</code></a> and <a href="#Base.pairs-Tuple{Any}"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 2, 3, 4]
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; findlast(isodd, A)
3

julia&gt; findlast(x -&gt; x &gt; 5, A) # returns nothing, but not printed in the REPL

julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; findlast(isodd, A)
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2059-L2090">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findmax!-Tuple{AbstractArray, AbstractArray, AbstractArray}" href="#Base.findmax!-Tuple{AbstractArray, AbstractArray, AbstractArray}"><code>Base.findmax!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findmax!(rval, rind, A) -&gt; (maxval, index)</code></pre><p>Find the maximum of <code>A</code> and the corresponding linear index along singleton dimensions of <code>rval</code> and <code>rind</code>, and store the results in <code>rval</code> and <code>rind</code>. <code>NaN</code> is treated as greater than all other values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L1006-L1012">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findmax-Tuple{AbstractArray}" href="#Base.findmax-Tuple{AbstractArray}"><code>Base.findmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findmax(A; dims) -&gt; (maxval, index)</code></pre><p>For an array input, returns the value and index of the maximum over the given dimensions. <code>NaN</code> is treated as greater than all other values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2; 3 4]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; findmax(A, dims=1)
([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])

julia&gt; findmax(A, dims=2)
([2.0; 4.0], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L1018-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findmax-Tuple{Any}" href="#Base.findmax-Tuple{Any}"><code>Base.findmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findmax(itr) -&gt; (x, index)</code></pre><p>Return the maximum element of the collection <code>itr</code> and its index or key. If there are multiple maximal elements, then the first one will be returned. If any data element is <code>NaN</code>, this element is returned. The result is in line with <code>max</code>.</p><p>The collection must not be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmax([8,0.1,-9,pi])
(8.0, 1)

julia&gt; findmax([1,7,7,6])
(7, 2)

julia&gt; findmax([1,7,7,NaN])
(NaN, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2214-L2235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findmin!-Tuple{AbstractArray, AbstractArray, AbstractArray}" href="#Base.findmin!-Tuple{AbstractArray, AbstractArray, AbstractArray}"><code>Base.findmin!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findmin!(rval, rind, A) -&gt; (minval, index)</code></pre><p>Find the minimum of <code>A</code> and the corresponding linear index along singleton dimensions of <code>rval</code> and <code>rind</code>, and store the results in <code>rval</code> and <code>rind</code>. <code>NaN</code> is treated as less than all other values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L957-L963">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findmin-Tuple{AbstractArray}" href="#Base.findmin-Tuple{AbstractArray}"><code>Base.findmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findmin(A; dims) -&gt; (minval, index)</code></pre><p>For an array input, returns the value and index of the minimum over the given dimensions. <code>NaN</code> is treated as less than all other values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1.0 2; 3 4]
2×2 Matrix{Float64}:
 1.0  2.0
 3.0  4.0

julia&gt; findmin(A, dims=1)
([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])

julia&gt; findmin(A, dims=2)
([1.0; 3.0], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L969-L988">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findmin-Tuple{Any}" href="#Base.findmin-Tuple{Any}"><code>Base.findmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findmin(itr) -&gt; (x, index)</code></pre><p>Return the minimum element of the collection <code>itr</code> and its index or key. If there are multiple minimal elements, then the first one will be returned. If any data element is <code>NaN</code>, this element is returned. The result is in line with <code>min</code>.</p><p>The collection must not be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findmin([8,0.1,-9,pi])
(-9.0, 3)

julia&gt; findmin([7,1,1,6])
(1, 2)

julia&gt; findmin([7,1,1,NaN])
(NaN, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2259-L2280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findnext-Tuple{AbstractChar, AbstractString, Integer}" href="#Base.findnext-Tuple{AbstractChar, AbstractString, Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findnext(ch::AbstractChar, string::AbstractString, start::Integer)</code></pre><p>Find the next occurrence of character <code>ch</code> in <code>string</code> starting at position <code>start</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findnext(&#39;z&#39;, &quot;Hello to the world&quot;, 1) === nothing
true

julia&gt; findnext(&#39;o&#39;, &quot;Hello to the world&quot;, 6)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L304-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findnext-Tuple{AbstractString, AbstractString, Integer}" href="#Base.findnext-Tuple{AbstractString, AbstractString, Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findnext(pattern::AbstractString, string::AbstractString, start::Integer)
findnext(pattern::AbstractPattern, string::String, start::Integer)</code></pre><p>Find the next occurrence of <code>pattern</code> in <code>string</code> starting at position <code>start</code>. <code>pattern</code> can be either a string, or a regular expression, in which case <code>string</code> must be of type <code>String</code>.</p><p>The return value is a range of indices where the matching sequence is found, such that <code>s[findnext(x, s, i)] == x</code>:</p><p><code>findnext(&quot;substring&quot;, string, i)</code> == <code>start:stop</code> such that <code>string[start:stop] == &quot;substring&quot;</code> and <code>i &lt;= start</code>, or <code>nothing</code> if unmatched.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findnext(&quot;z&quot;, &quot;Hello to the world&quot;, 1) === nothing
true

julia&gt; findnext(&quot;o&quot;, &quot;Hello to the world&quot;, 6)
8:8

julia&gt; findnext(&quot;Lang&quot;, &quot;JuliaLang&quot;, 2)
6:9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L276-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findnext-Tuple{AbstractVector{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Union{Int8, UInt8}, AbstractVector{var&quot;#s831&quot;} where var&quot;#s831&quot;&lt;:Union{Int8, UInt8}, Integer}" href="#Base.findnext-Tuple{AbstractVector{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Union{Int8, UInt8}, AbstractVector{var&quot;#s831&quot;} where var&quot;#s831&quot;&lt;:Union{Int8, UInt8}, Integer}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findnext(pattern::AbstractVector{&lt;:Union{Int8,UInt8}},
         A::AbstractVector{&lt;:Union{Int8,UInt8}},
         start::Integer)</code></pre><p>Find the next occurrence of the sequence <code>pattern</code> in vector <code>A</code> starting at position <code>start</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This method requires at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findnext([0x52, 0x62], [0x52, 0x62, 0x72], 3) === nothing
true

julia&gt; findnext([0x52, 0x62], [0x40, 0x52, 0x62, 0x52, 0x62], 3)
4:5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L324-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findnext-Tuple{Any, Any}" href="#Base.findnext-Tuple{Any, Any}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findnext(A, i)</code></pre><p>Find the next index after or including <code>i</code> of a <code>true</code> element of <code>A</code>, or <code>nothing</code> if not found.</p><p>Indices are of the same type as those returned by <a href="#Base.keys"><code>keys(A)</code></a> and <a href="#Base.pairs-Tuple{Any}"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [false, false, true, false]
4-element Vector{Bool}:
 0
 0
 1
 0

julia&gt; findnext(A, 1)
3

julia&gt; findnext(A, 4) # returns nothing, but not printed in the REPL

julia&gt; A = [false false; true false]
2×2 Matrix{Bool}:
 0  0
 1  0

julia&gt; findnext(A, CartesianIndex(1, 1))
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1736-L1767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findnext-Tuple{Function, Any, Any}" href="#Base.findnext-Tuple{Function, Any, Any}"><code>Base.findnext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findnext(predicate::Function, A, i)</code></pre><p>Find the next index after or including <code>i</code> of an element of <code>A</code> for which <code>predicate</code> returns <code>true</code>, or <code>nothing</code> if not found.</p><p>Indices are of the same type as those returned by <a href="#Base.keys"><code>keys(A)</code></a> and <a href="#Base.pairs-Tuple{Any}"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 4, 2, 2];

julia&gt; findnext(isodd, A, 1)
1

julia&gt; findnext(isodd, A, 2) # returns nothing, but not printed in the REPL

julia&gt; A = [1 4; 2 2];

julia&gt; findnext(isodd, A, CartesianIndex(1, 1))
CartesianIndex(1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1826-L1849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findprev-Tuple{AbstractChar, AbstractString, Integer}" href="#Base.findprev-Tuple{AbstractChar, AbstractString, Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findprev(ch::AbstractChar, string::AbstractString, start::Integer)</code></pre><p>Find the previous occurrence of character <code>ch</code> in <code>string</code> starting at position <code>start</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findprev(&#39;z&#39;, &quot;Hello to the world&quot;, 18) === nothing
true

julia&gt; findprev(&#39;o&#39;, &quot;Hello to the world&quot;, 18)
15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L558-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findprev-Tuple{AbstractString, AbstractString, Integer}" href="#Base.findprev-Tuple{AbstractString, AbstractString, Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findprev(pattern::AbstractString, string::AbstractString, start::Integer)</code></pre><p>Find the previous occurrence of <code>pattern</code> in <code>string</code> starting at position <code>start</code>.</p><p>The return value is a range of indices where the matching sequence is found, such that <code>s[findprev(x, s, i)] == x</code>:</p><p><code>findprev(&quot;substring&quot;, string, i)</code> == <code>start:stop</code> such that <code>string[start:stop] == &quot;substring&quot;</code> and <code>stop &lt;= i</code>, or <code>nothing</code> if unmatched.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findprev(&quot;z&quot;, &quot;Hello to the world&quot;, 18) === nothing
true

julia&gt; findprev(&quot;o&quot;, &quot;Hello to the world&quot;, 18)
15:15

julia&gt; findprev(&quot;Julia&quot;, &quot;JuliaLang&quot;, 6)
1:5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L533-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findprev-Tuple{AbstractVector{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Union{Int8, UInt8}, AbstractVector{var&quot;#s831&quot;} where var&quot;#s831&quot;&lt;:Union{Int8, UInt8}, Integer}" href="#Base.findprev-Tuple{AbstractVector{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Union{Int8, UInt8}, AbstractVector{var&quot;#s831&quot;} where var&quot;#s831&quot;&lt;:Union{Int8, UInt8}, Integer}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findprev(pattern::AbstractVector{&lt;:Union{Int8,UInt8}},
         A::AbstractVector{&lt;:Union{Int8,UInt8}},
         start::Integer)</code></pre><p>Find the previous occurrence of the sequence <code>pattern</code> in vector <code>A</code> starting at position <code>start</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This method requires at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; findprev([0x52, 0x62], [0x40, 0x52, 0x62, 0x52, 0x62], 3)
2:3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L578-L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findprev-Tuple{Any, Any}" href="#Base.findprev-Tuple{Any, Any}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findprev(A, i)</code></pre><p>Find the previous index before or including <code>i</code> of a <code>true</code> element of <code>A</code>, or <code>nothing</code> if not found.</p><p>Indices are of the same type as those returned by <a href="#Base.keys"><code>keys(A)</code></a> and <a href="#Base.pairs-Tuple{Any}"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [false, false, true, true]
4-element Vector{Bool}:
 0
 0
 1
 1

julia&gt; findprev(A, 3)
3

julia&gt; findprev(A, 1) # returns nothing, but not printed in the REPL

julia&gt; A = [false false; true true]
2×2 Matrix{Bool}:
 0  0
 1  1

julia&gt; findprev(A, CartesianIndex(2, 1))
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1923-L1954">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findprev-Tuple{Function, Any, Any}" href="#Base.findprev-Tuple{Function, Any, Any}"><code>Base.findprev</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findprev(predicate::Function, A, i)</code></pre><p>Find the previous index before or including <code>i</code> of an element of <code>A</code> for which <code>predicate</code> returns <code>true</code>, or <code>nothing</code> if not found.</p><p>Indices are of the same type as those returned by <a href="#Base.keys"><code>keys(A)</code></a> and <a href="#Base.pairs-Tuple{Any}"><code>pairs(A)</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [4, 6, 1, 2]
4-element Vector{Int64}:
 4
 6
 1
 2

julia&gt; findprev(isodd, A, 1) # returns nothing, but not printed in the REPL

julia&gt; findprev(isodd, A, 3)
3

julia&gt; A = [4 6; 1 2]
2×2 Matrix{Int64}:
 4  6
 1  2

julia&gt; findprev(isodd, A, CartesianIndex(1, 2))
CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2014-L2045">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first-Tuple{AbstractString, Integer}" href="#Base.first-Tuple{AbstractString, Integer}"><code>Base.first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">first(s::AbstractString, n::Integer)</code></pre><p>Get a string consisting of the first <code>n</code> characters of <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 0)
&quot;&quot;

julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 1)
&quot;∀&quot;

julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 3)
&quot;∀ϵ≠&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L632-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first-Tuple{Any, Integer}" href="#Base.first-Tuple{Any, Integer}"><code>Base.first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">first(itr, n::Integer)</code></pre><p>Get the first <code>n</code> elements of the iterable collection <code>itr</code>, or fewer elements if <code>v</code> is not long enough.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This method requires at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; first([&quot;foo&quot;, &quot;bar&quot;, &quot;qux&quot;], 2)
2-element Vector{String}:
 &quot;foo&quot;
 &quot;bar&quot;

julia&gt; first(1:6, 10)
1:6

julia&gt; first(Bool[], 1)
Bool[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L391-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first-Tuple{Any}" href="#Base.first-Tuple{Any}"><code>Base.first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">first(coll)</code></pre><p>Get the first element of an iterable collection. Return the start point of an <a href="#Base.AbstractRange"><code>AbstractRange</code></a> even if it is empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; first(2:2:10)
2

julia&gt; first([1; 2; 3; 4])
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L370-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.firstindex-Tuple{AbstractArray}" href="#Base.firstindex-Tuple{AbstractArray}"><code>Base.firstindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">firstindex(collection) -&gt; Integer
firstindex(collection, d) -&gt; Integer</code></pre><p>Return the first index of <code>collection</code>. If <code>d</code> is given, return the first index of <code>collection</code> along dimension <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; firstindex([1,2,4])
1

julia&gt; firstindex(rand(3,4,5), 2)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L350-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fld-Tuple{Any, Any}" href="#Base.fld-Tuple{Any, Any}"><code>Base.fld</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fld(x, y)</code></pre><p>Largest integer less than or equal to <code>x/y</code>. Equivalent to <code>div(x, y, RoundDown)</code>.</p><p>See also: <a href="#Base.div"><code>div</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fld(7.3,5.5)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/div.jl#L73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fld1-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#Base.fld1-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>Base.fld1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fld1(x, y)</code></pre><p>Flooring division, returning a value consistent with <code>mod1(x,y)</code></p><p>See also: <a href="#Base.mod1-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>mod1</code></a>, <a href="#Base.fldmod1-Tuple{Any, Any}"><code>fldmod1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = 15; y = 4;

julia&gt; fld1(x, y)
4

julia&gt; x == fld(x, y) * y + mod(x, y)
true

julia&gt; x == (fld1(x, y) - 1) * y + mod1(x, y)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L784-L804">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fldmod-Tuple{Any, Any}" href="#Base.fldmod-Tuple{Any, Any}"><code>Base.fldmod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fldmod(x, y)</code></pre><p>The floored quotient and modulus after division. A convenience wrapper for <code>divrem(x, y, RoundDown)</code>. Equivalent to <code>(fld(x,y), mod(x,y))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/div.jl#L181-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fldmod1-Tuple{Any, Any}" href="#Base.fldmod1-Tuple{Any, Any}"><code>Base.fldmod1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fldmod1(x, y)</code></pre><p>Return <code>(fld1(x,y), mod1(x,y))</code>.</p><p>See also: <a href="#Base.fld1-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>fld1</code></a>, <a href="#Base.mod1-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>mod1</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L811-L817">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.flipsign-Tuple{Real, Real}" href="#Base.flipsign-Tuple{Real, Real}"><code>Base.flipsign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flipsign(x, y)</code></pre><p>Return <code>x</code> with its sign flipped if <code>y</code> is negative. For example <code>abs(x) = flipsign(x,x)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; flipsign(5, 3)
5

julia&gt; flipsign(5, -3)
-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L153-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.float-Tuple{Any}" href="#Base.float-Tuple{Any}"><code>Base.float</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">float(x)</code></pre><p>Convert a number or array to a floating point data type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L201-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.float-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Number" href="#Base.float-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Number"><code>Base.float</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">float(T::Type)</code></pre><p>Return an appropriate type to represent a value of type <code>T</code> as a floating point value. Equivalent to <code>typeof(float(zero(T)))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; float(Complex{Int})
ComplexF64 (alias for Complex{Float64})

julia&gt; float(Int)
Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L208-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floatmax-Tuple{T} where T&lt;:AbstractFloat" href="#Base.floatmax-Tuple{T} where T&lt;:AbstractFloat"><code>Base.floatmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floatmax(T = Float64)</code></pre><p>Return the largest finite number representable by the floating-point type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; floatmax(Float16)
Float16(6.55e4)

julia&gt; floatmax(Float32)
3.4028235f38

julia&gt; floatmax()
1.7976931348623157e308</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L787-L803">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floatmin-Tuple{T} where T&lt;:AbstractFloat" href="#Base.floatmin-Tuple{T} where T&lt;:AbstractFloat"><code>Base.floatmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floatmin(T = Float64)</code></pre><p>Return the smallest positive normal number representable by the floating-point type <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; floatmin(Float16)
Float16(6.104e-5)

julia&gt; floatmin(Float32)
1.1754944f-38

julia&gt; floatmin()
2.2250738585072014e-308</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L767-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floor" href="#Base.floor"><code>Base.floor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">floor([T,] x)
floor(x; digits::Integer= [, base = 10])
floor(x; sigdigits::Integer= [, base = 10])</code></pre><p><code>floor(x)</code> returns the nearest integral value of the same type as <code>x</code> that is less than or equal to <code>x</code>.</p><p><code>floor(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p><p><code>digits</code>, <code>sigdigits</code> and <code>base</code> work as for <a href="#Base.round"><code>round</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L564-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.flush-Tuple{IO}" href="#Base.flush-Tuple{IO}"><code>Base.flush</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flush(stream)</code></pre><p>Commit all currently buffered writes to the given stream.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L1113-L1117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fma" href="#Base.fma"><code>Base.fma</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fma(x, y, z)</code></pre><p>Computes <code>x*y+z</code> without rounding the intermediate result <code>x*y</code>. On some systems this is significantly more expensive than <code>x*y+z</code>. <code>fma</code> is used to improve accuracy in certain algorithms. See <a href="@ref"><code>muladd</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/floatfuncs.jl#L311-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.foldl-Tuple{Any, Any}" href="#Base.foldl-Tuple{Any, Any}"><code>Base.foldl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">foldl(op, itr; [init])</code></pre><p>Like <a href="#Base.reduce-Tuple{Any, AbstractArray}"><code>reduce</code></a>, but with guaranteed left associativity. If provided, the keyword argument <code>init</code> will be used exactly once. In general, it will be necessary to provide <code>init</code> to work with empty collections.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; foldl(=&gt;, 1:4)
((1 =&gt; 2) =&gt; 3) =&gt; 4

julia&gt; foldl(=&gt;, 1:4; init=0)
(((0 =&gt; 1) =&gt; 2) =&gt; 3) =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L162-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.foldr-Tuple{Any, Any}" href="#Base.foldr-Tuple{Any, Any}"><code>Base.foldr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">foldr(op, itr; [init])</code></pre><p>Like <a href="#Base.reduce-Tuple{Any, AbstractArray}"><code>reduce</code></a>, but with guaranteed right associativity. If provided, the keyword argument <code>init</code> will be used exactly once. In general, it will be necessary to provide <code>init</code> to work with empty collections.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; foldr(=&gt;, 1:4)
1 =&gt; (2 =&gt; (3 =&gt; 4))

julia&gt; foldr(=&gt;, 1:4; init=0)
1 =&gt; (2 =&gt; (3 =&gt; (4 =&gt; 0)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L206-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.foreach-Tuple{Any}" href="#Base.foreach-Tuple{Any}"><code>Base.foreach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">foreach(f, c...) -&gt; Nothing</code></pre><p>Call function <code>f</code> on each element of iterable <code>c</code>. For multiple iterable arguments, <code>f</code> is called elementwise. <code>foreach</code> should be used instead of <code>map</code> when the results of <code>f</code> are not needed, for example in <code>foreach(println, array)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = 1:3:7;

julia&gt; foreach(x -&gt; println(x^2), a)
1
16
49</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L2122-L2139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.front-Tuple{Tuple}" href="#Base.front-Tuple{Tuple}"><code>Base.front</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">front(x::Tuple)::Tuple</code></pre><p>Return a <code>Tuple</code> consisting of all but the last component of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.front((1,2,3))
(1, 2)

julia&gt; Base.front(())
ERROR: ArgumentError: Cannot call front on an empty tuple.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/tuple.jl#L184-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fullname-Tuple{Module}" href="#Base.fullname-Tuple{Module}"><code>Base.fullname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fullname(m::Module)</code></pre><p>Get the fully-qualified name of a module as a tuple of symbols. For example,</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fullname(Base.Iterators)
(:Base, :Iterators)

julia&gt; fullname(Main)
(:Main,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L60-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.functionloc-Tuple{Any, Any}" href="#Base.functionloc-Tuple{Any, Any}"><code>Base.functionloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">functionloc(f::Function, types)</code></pre><p>Returns a tuple <code>(filename,line)</code> giving the location of a generic <code>Function</code> definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/methodshow.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.functionloc-Tuple{Method}" href="#Base.functionloc-Tuple{Method}"><code>Base.functionloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">functionloc(m::Method)</code></pre><p>Returns a tuple <code>(filename,line)</code> giving the location of a <code>Method</code> definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/methodshow.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.gc_live_bytes-Tuple{}" href="#Base.gc_live_bytes-Tuple{}"><code>Base.gc_live_bytes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.gc_live_bytes()</code></pre><p>Return the total size (in bytes) of objects currently in memory. This is computed as the total size of live objects after the last garbage collection, plus the number of bytes allocated since then.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/timing.jl#L65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.gcd-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer" href="#Base.gcd-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>Base.gcd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gcd(x, y...)</code></pre><p>Greatest common (positive) divisor (or zero if all arguments are zero). The arguments may be integer and rational numbers.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>Rational arguments require Julia 1.4 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gcd(6,9)
3

julia&gt; gcd(6,-9)
3

julia&gt; gcd(6,0)
6

julia&gt; gcd(0,0)
0

julia&gt; gcd(1//3,2//3)
1//3

julia&gt; gcd(1//3,-2//3)
1//3

julia&gt; gcd(1//3,2)
1//3

julia&gt; gcd(0, 0, 10, 15)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L5-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.gcdx-Tuple{Integer, Integer}" href="#Base.gcdx-Tuple{Integer, Integer}"><code>Base.gcdx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gcdx(a, b)</code></pre><p>Computes the greatest common (positive) divisor of <code>a</code> and <code>b</code> and their Bézout coefficients, i.e. the integer coefficients <code>u</code> and <code>v</code> that satisfy <span>$ua+vb = d = gcd(a, b)$</span>. <span>$gcdx(a, b)$</span> returns <span>$(d, u, v)$</span>.</p><p>The arguments may be integer and rational numbers.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>Rational arguments require Julia 1.4 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gcdx(12, 42)
(6, -3, 1)

julia&gt; gcdx(240, 46)
(2, -9, 47)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Bézout coefficients are <em>not</em> uniquely defined. <code>gcdx</code> returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients <code>u</code> and <code>v</code> are minimal in the sense that <span>$|u| &lt; |y/d|$</span> and <span>$|v| &lt; |x/d|$</span>. Furthermore, the signs of <code>u</code> and <code>v</code> are chosen so that <code>d</code> is positive. For unsigned integers, the coefficients <code>u</code> and <code>v</code> might be near their <code>typemax</code>, and the identity then holds only via the unsigned integers&#39; modulo arithmetic.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L147-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.gensym-Tuple{}" href="#Base.gensym-Tuple{}"><code>Base.gensym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gensym([tag])</code></pre><p>Generates a symbol which will not conflict with other variable names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get!-Tuple{Any, Any, Any}" href="#Base.get!-Tuple{Any, Any, Any}"><code>Base.get!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get!(collection, key, default)</code></pre><p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; default</code>, and return <code>default</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; get!(d, &quot;a&quot;, 5)
1

julia&gt; get!(d, &quot;d&quot;, 4)
4

julia&gt; d
Dict{String, Int64} with 4 entries:
  &quot;c&quot; =&gt; 3
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1
  &quot;d&quot; =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L396-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get!-Tuple{Function, Any, Any}" href="#Base.get!-Tuple{Function, Any, Any}"><code>Base.get!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get!(f::Function, collection, key)</code></pre><p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; f()</code>, and return <code>f()</code>.</p><p>This is intended to be called using <code>do</code> block syntax.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; squares = Dict{Int, Int}();

julia&gt; function get_square!(d, i)
           get!(d, i) do
               i^2
           end
       end
get_square! (generic function with 1 method)

julia&gt; get_square!(squares, 2)
4

julia&gt; squares
Dict{Int64, Int64} with 1 entry:
  2 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L422-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get-Tuple{Any, Any, Any}" href="#Base.get-Tuple{Any, Any, Any}"><code>Base.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get(collection, key, default)</code></pre><p>Return the value stored for the given key, or the given default value if no mapping for the key is present.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; get(d, &quot;a&quot;, 3)
1

julia&gt; get(d, &quot;c&quot;, 3)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L485-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get-Tuple{Function, Any, Any}" href="#Base.get-Tuple{Function, Any, Any}"><code>Base.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get(f::Function, collection, key)</code></pre><p>Return the value stored for the given key, or if no mapping for the key is present, return <code>f()</code>.  Use <a href="#Base.get!-Tuple{Any, Any, Any}"><code>get!</code></a> to also store the default value in the dictionary.</p><p>This is intended to be called using <code>do</code> block syntax</p><pre><code class="language-julia hljs">get(dict, key) do
    # default value calculated here
    time()
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L509-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getindex(collection, key...)</code></pre><p>Retrieve the value(s) stored at the given key or index within a collection. The syntax <code>a[i,j,...]</code> is converted by the compiler to <code>getindex(a, i, j, ...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)
Dict{String, Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; getindex(A, &quot;a&quot;)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L781-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractArray, Vararg{Any, N} where N}" href="#Base.getindex-Tuple{AbstractArray, Vararg{Any, N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(A, inds...)</code></pre><p>Return a subset of array <code>A</code> as specified by <code>inds</code>, where each <code>ind</code> may be, for example, an <code>Int</code>, an <a href="#Base.AbstractRange"><code>AbstractRange</code></a>, or a <a href="#Base.Vector"><code>Vector</code></a>. See the manual section on <a href="@ref man-array-indexing">array indexing</a> for details.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; getindex(A, 1)
1

julia&gt; getindex(A, [2, 1])
2-element Vector{Int64}:
 3
 1

julia&gt; getindex(A, 2:4)
3-element Vector{Int64}:
 3
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1138-L1166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T" href="#Base.getindex-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(type[, elements...])</code></pre><p>Construct a 1-d array of the specified type. This is usually called with the syntax <code>Type[]</code>. Element values can be specified using <code>Type[a,b,c,...]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Int8[1, 2, 3]
3-element Vector{Int8}:
 1
 2
 3

julia&gt; getindex(Int8, 1, 2, 3)
3-element Vector{Int8}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L362-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getkey-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K, V}, Any, Any}} where {K, V}" href="#Base.getkey-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K, V}, Any, Any}} where {K, V}"><code>Base.getkey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getkey(collection, key, default)</code></pre><p>Return the key matching argument <code>key</code> if one exists in <code>collection</code>, otherwise return <code>default</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char, Int64} with 2 entries:
  &#39;a&#39; =&gt; 2
  &#39;b&#39; =&gt; 3

julia&gt; getkey(D, &#39;a&#39;, 1)
&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia&gt; getkey(D, &#39;d&#39;, &#39;a&#39;)
&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L553-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getpass" href="#Base.getpass"><code>Base.getpass</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.getpass(message::AbstractString) -&gt; Base.SecretBuffer</code></pre><p>Display a message and wait for the user to input a secret, returning an <code>IO</code> object containing the secret.</p><p>Note that on Windows, the secret might be displayed as it is typed; see <code>Base.winprompt</code> for securely retrieving username/password pairs from a graphical interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/util.jl#L215-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.has_bottom_parameter-Tuple{DataType}" href="#Base.has_bottom_parameter-Tuple{DataType}"><code>Base.has_bottom_parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_bottom_parameter(t) -&gt; Bool</code></pre><p>Determine whether <code>t</code> is a Type for which one or more of its parameters is <code>Union{}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1542-L1546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.has_offset_axes-Tuple{Any}" href="#Base.has_offset_axes-Tuple{Any}"><code>Base.has_offset_axes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_offset_axes(A)
has_offset_axes(A, B, ...)</code></pre><p>Return <code>true</code> if the indices of <code>A</code> start with something other than 1 along any axis. If multiple arguments are passed, equivalent to <code>has_offset_axes(A) | has_offset_axes(B) | ...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hasfastin-Tuple{Type}" href="#Base.hasfastin-Tuple{Type}"><code>Base.hasfastin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasfastin(T)</code></pre><p>Determine whether the computation <code>x ∈ collection</code> where <code>collection::T</code> can be considered as a &quot;fast&quot; operation (typically constant or logarithmic complexity). The definition <code>hasfastin(x) = hasfastin(typeof(x))</code> is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L288-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hasfield-Tuple{Type, Symbol}" href="#Base.hasfield-Tuple{Type, Symbol}"><code>Base.hasfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasfield(T::Type, name::Symbol)</code></pre><p>Return a boolean indicating whether <code>T</code> has <code>name</code> as one of its own fields.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This function requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L183-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hash-Tuple{Any}" href="#Base.hash-Tuple{Any}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hash(x[, h::UInt])</code></pre><p>Compute an integer hash code such that <code>isequal(x,y)</code> implies <code>hash(x)==hash(y)</code>. The optional second argument <code>h</code> is a hash code to be mixed with the result.</p><p>New types should implement the 2-argument form, typically by calling the 2-argument <code>hash</code> method recursively in order to mix hashes of the contents with each other (and with <code>h</code>). Typically, any type that implements <code>hash</code> should also implement its own <code>==</code> (hence <code>isequal</code>) to guarantee the property mentioned above. Types supporting subtraction (operator <code>-</code>) should also implement <a href="#Base.widen-Tuple{T} where T"><code>widen</code></a>, which is required to hash values inside heterogeneous arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/hashing.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.haskey-Tuple{Dict, Any}" href="#Base.haskey-Tuple{Dict, Any}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">haskey(collection, key) -&gt; Bool</code></pre><p>Determine whether a collection has a mapping for a given <code>key</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char, Int64} with 2 entries:
  &#39;a&#39; =&gt; 2
  &#39;b&#39; =&gt; 3

julia&gt; haskey(D, &#39;a&#39;)
true

julia&gt; haskey(D, &#39;c&#39;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L531-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hasmethod-Tuple{Any, Any}" href="#Base.hasmethod-Tuple{Any, Any}"><code>Base.hasmethod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasmethod(f, t::Type{&lt;:Tuple}[, kwnames]; world=typemax(UInt)) -&gt; Bool</code></pre><p>Determine whether the given generic function has a method matching the given <code>Tuple</code> of argument types with the upper bound of world age given by <code>world</code>.</p><p>If a tuple of keyword argument names <code>kwnames</code> is provided, this also checks whether the method of <code>f</code> matching <code>t</code> has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with <code>kwargs...</code>, any names given in <code>kwnames</code> are considered valid. Otherwise the provided names must be a subset of the method&#39;s keyword arguments.</p><p>See also <a href="@ref"><code>applicable</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>Providing keyword argument names requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hasmethod(length, Tuple{Array})
true

julia&gt; f(; oranges=0) = oranges;

julia&gt; hasmethod(f, Tuple{}, (:oranges,))
true

julia&gt; hasmethod(f, Tuple{}, (:apples, :bananas))
false

julia&gt; g(; xs...) = 4;

julia&gt; hasmethod(g, Tuple{}, (:a, :b, :c, :d))  # g accepts arbitrary kwargs
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1311-L1346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hasproperty-Tuple{Any, Symbol}" href="#Base.hasproperty-Tuple{Any, Symbol}"><code>Base.hasproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasproperty(x, s::Symbol)</code></pre><p>Return a boolean indicating whether the object <code>x</code> has <code>s</code> as one of its own properties.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This function requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1583-L1590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hastypemax-Tuple{Union{Type{Int128}, Type{Int16}, Type{Int32}, Type{Int64}, Type{Int8}, Type{UInt128}, Type{UInt16}, Type{UInt32}, Type{UInt64}, Type{UInt8}}}" href="#Base.hastypemax-Tuple{Union{Type{Int128}, Type{Int16}, Type{Int32}, Type{Int64}, Type{Int8}, Type{UInt128}, Type{UInt16}, Type{UInt32}, Type{UInt64}, Type{UInt8}}}"><code>Base.hastypemax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hastypemax(T::Type) -&gt; Bool</code></pre><p>Return true if and only if the extrema <code>typemax(T)</code> and <code>typemin(T)</code> are defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L842-L846">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hcat-Tuple" href="#Base.hcat-Tuple"><code>Base.hcat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hcat(A...)</code></pre><p>Concatenate along dimension 2.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1; 2; 3; 4; 5]
5-element Vector{Int64}:
 1
 2
 3
 4
 5

julia&gt; b = [6 7; 8 9; 10 11; 12 13; 14 15]
5×2 Matrix{Int64}:
  6   7
  8   9
 10  11
 12  13
 14  15

julia&gt; hcat(a,b)
5×3 Matrix{Int64}:
 1   6   7
 2   8   9
 3  10  11
 4  12  13
 5  14  15

julia&gt; c = ([1; 2; 3], [4; 5; 6])
([1, 2, 3], [4, 5, 6])

julia&gt; hcat(c...)
3×2 Matrix{Int64}:
 1  4
 2  5
 3  6

julia&gt; x = Matrix(undef, 3, 0)  # x = [] would have created an Array{Any, 1}, but need an Array{Any, 2}
3×0 Matrix{Any}

julia&gt; hcat(x, [1; 2; 3])
3×1 Matrix{Any}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1711-L1760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hex2bytes" href="#Base.hex2bytes"><code>Base.hex2bytes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hex2bytes(s::Union{AbstractString,AbstractVector{UInt8}})</code></pre><p>Given a string or array <code>s</code> of ASCII codes for a sequence of hexadecimal digits, returns a <code>Vector{UInt8}</code> of bytes  corresponding to the binary representation: each successive pair of hexadecimal digits in <code>s</code> gives the value of one byte in the return vector.</p><p>The length of <code>s</code> must be even, and the returned array has half of the length of <code>s</code>. See also <a href="#Base.hex2bytes!-Tuple{AbstractVector{UInt8}, Union{String, AbstractVector{UInt8}}}"><code>hex2bytes!</code></a> for an in-place version, and <a href="#Base.bytes2hex"><code>bytes2hex</code></a> for the inverse.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = string(12345, base = 16)
&quot;3039&quot;

julia&gt; hex2bytes(s)
2-element Vector{UInt8}:
 0x30
 0x39

julia&gt; a = b&quot;01abEF&quot;
6-element Base.CodeUnits{UInt8, String}:
 0x30
 0x31
 0x61
 0x62
 0x45
 0x46

julia&gt; hex2bytes(a)
3-element Vector{UInt8}:
 0x01
 0xab
 0xef</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L597-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hex2bytes!-Tuple{AbstractVector{UInt8}, Union{String, AbstractVector{UInt8}}}" href="#Base.hex2bytes!-Tuple{AbstractVector{UInt8}, Union{String, AbstractVector{UInt8}}}"><code>Base.hex2bytes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hex2bytes!(d::AbstractVector{UInt8}, s::Union{String,AbstractVector{UInt8}})</code></pre><p>Convert an array <code>s</code> of bytes representing a hexadecimal string to its binary representation, similar to <a href="#Base.hex2bytes"><code>hex2bytes</code></a> except that the output is written in-place in <code>d</code>.   The length of <code>s</code> must be exactly twice the length of <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L643-L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.htol-Tuple{Any}" href="#Base.htol-Tuple{Any}"><code>Base.htol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">htol(x)</code></pre><p>Convert the endianness of a value from that used by the Host to Little-endian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L605-L609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hton-Tuple{Any}" href="#Base.hton-Tuple{Any}"><code>Base.hton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hton(x)</code></pre><p>Convert the endianness of a value from that used by the Host to Network byte order (big-endian).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L591-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hvcat-Tuple{Tuple{Vararg{Int64, N} where N}, Vararg{AbstractVecOrMat{T} where T, N} where N}" href="#Base.hvcat-Tuple{Tuple{Vararg{Int64, N} where N}, Vararg{AbstractVecOrMat{T} where T, N} where N}"><code>Base.hvcat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hvcat(rows::Tuple{Vararg{Int}}, values...)</code></pre><p>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a, b, c, d, e, f = 1, 2, 3, 4, 5, 6
(1, 2, 3, 4, 5, 6)

julia&gt; [a b c; d e f]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; hvcat((3,3), a,b,c,d,e,f)
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; [a b;c d; e f]
3×2 Matrix{Int64}:
 1  2
 3  4
 5  6

julia&gt; hvcat((2,2,2), a,b,c,d,e,f)
3×2 Matrix{Int64}:
 1  2
 3  4
 5  6</code></pre><p>If the first argument is a single integer <code>n</code>, then all block rows are assumed to have <code>n</code> block columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1811-L1848">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.identity-Tuple{Any}" href="#Base.identity-Tuple{Any}"><code>Base.identity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">identity(x)</code></pre><p>The identity function. Returns its argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; identity(&quot;Well, what did you expect?&quot;)
&quot;Well, what did you expect?&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L502-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ignorestatus-Tuple{Cmd}" href="#Base.ignorestatus-Tuple{Cmd}"><code>Base.ignorestatus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ignorestatus(command)</code></pre><p>Mark a command object so that running it will not throw an error if the result code is non-zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/cmd.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.imag-Tuple{Complex}" href="#Base.imag-Tuple{Complex}"><code>Base.imag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imag(z)</code></pre><p>Return the imaginary part of the complex number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; imag(1 + 3im)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L65-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in" href="#Base.in"><code>Base.in</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">in(item, collection) -&gt; Bool
∈(item, collection) -&gt; Bool</code></pre><p>Determine whether an item is in the given collection, in the sense that it is <a href="#Base.:=="><code>==</code></a> to one of the values generated by iterating over the collection. Returns a <code>Bool</code> value, except if <code>item</code> is <a href="#Base.missing"><code>missing</code></a> or <code>collection</code> contains <code>missing</code> but not <code>item</code>, in which case <code>missing</code> is returned (<a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, matching the behavior of <a href="#Base.any-Tuple{AbstractArray}"><code>any</code></a> and <a href="#Base.:=="><code>==</code></a>).</p><p>Some collections follow a slightly different definition. For example, <a href="#Base.Set-Tuple{Any}"><code>Set</code></a>s check whether the item <a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a> to one of the elements. <a href="#Base.Dict"><code>Dict</code></a>s look for <code>key=&gt;value</code> pairs, and the key is compared using <a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a>. To test for the presence of a key in a dictionary, use <a href="#Base.haskey-Tuple{Dict, Any}"><code>haskey</code></a> or <code>k in keys(dict)</code>. For these collections, the result is always a <code>Bool</code> and never <code>missing</code>.</p><p>To determine whether an item is not in a given collection, see <a href="#Base.:∉"><code>:∉</code></a>. You may also negate the <code>in</code> by doing <code>!(a in b)</code> which is logically similar to &quot;not in&quot;.</p><p>When broadcasting with <code>in.(items, collection)</code> or <code>items .∈ collection</code>, both <code>item</code> and <code>collection</code> are broadcasted over, which is often not what is intended. For example, if both arguments are vectors (and the dimensions match), the result is a vector indicating whether each value in collection <code>items</code> is <code>in</code> the value at the corresponding position in <code>collection</code>. To get a vector indicating whether each value in <code>items</code> is in <code>collection</code>, wrap <code>collection</code> in a tuple or a <code>Ref</code> like this: <code>in.(items, Ref(collection))</code> or <code>items .∈ Ref(collection)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = 1:3:20
1:3:19

julia&gt; 4 in a
true

julia&gt; 5 in a
false

julia&gt; missing in [1, 2]
missing

julia&gt; 1 in [2, missing]
missing

julia&gt; 1 in [1, missing]
true

julia&gt; missing in Set([1, 2])
false

julia&gt; !(21 in a)
true

julia&gt; !(19 in a)
false

julia&gt; [1, 2] .∈ [2, 3]
2-element BitVector:
 0
 0

julia&gt; [1, 2] .∈ ([2, 3],)
2-element BitVector:
 0
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1168-L1236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{Any}" href="#Base.in-Tuple{Any}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">in(collection)
∈(collection)</code></pre><p>Create a function that checks whether its argument is <a href="#Base.in"><code>in</code></a> <code>collection</code>, i.e. a function equivalent to <code>y -&gt; y in collection</code>. See also <a href="@ref"><code>insorted</code></a> for use with sorted collections.</p><p>The returned function is of type <code>Base.Fix2{typeof(in)}</code>, which can be used to implement specialized methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1116-L1126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.include" href="#Base.include"><code>Base.include</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.include([mapexpr::Function,] [m::Module,] path::AbstractString)</code></pre><p>Evaluate the contents of the input source file in the global scope of module <code>m</code>. Every module (except those defined with <a href="@ref"><code>baremodule</code></a>) has its own definition of <code>include</code> omitting the <code>m</code> argument, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to <code>include</code> will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</p><p>The optional first argument <code>mapexpr</code> can be used to transform the included code before it is evaluated: for each parsed expression <code>expr</code> in <code>path</code>, the <code>include</code> function actually evaluates <code>mapexpr(expr)</code>.  If it is omitted, <code>mapexpr</code> defaults to <a href="#Base.identity-Tuple{Any}"><code>identity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L1142-L1156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.include_dependency-Tuple{AbstractString}" href="#Base.include_dependency-Tuple{AbstractString}"><code>Base.include_dependency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">include_dependency(path::AbstractString)</code></pre><p>In a module, declare that the file specified by <code>path</code> (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</p><p>This is only needed if your module depends on a file that is not used via <a href="#Base.include"><code>include</code></a>. It has no effect outside of compilation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L821-L830">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.include_string" href="#Base.include_string"><code>Base.include_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">include_string([mapexpr::Function,] m::Module, code::AbstractString, filename::AbstractString=&quot;string&quot;)</code></pre><p>Like <a href="#Base.include"><code>include</code></a>, except reads code from the given string rather than from a file.</p><p>The optional first argument <code>mapexpr</code> can be used to transform the included code before it is evaluated: for each parsed expression <code>expr</code> in <code>code</code>, the <code>include_string</code> function actually evaluates <code>mapexpr(expr)</code>.  If it is omitted, <code>mapexpr</code> defaults to <a href="#Base.identity-Tuple{Any}"><code>identity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L1089-L1097">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.indentation-Tuple{AbstractString}" href="#Base.indentation-Tuple{AbstractString}"><code>Base.indentation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">indentation(str::AbstractString; tabwidth=8) -&gt; (Int, Bool)</code></pre><p>Calculate the width of leading white space. Return the width and a flag to indicate if the string is empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.indentation(&quot;&quot;)
(0, true)

julia&gt; Base.indentation(&quot;  a&quot;)
(2, false)

julia&gt; Base.indentation(&quot;\ta&quot;; tabwidth=3)
(3, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L569-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.indexin-Tuple{Any, AbstractArray}" href="#Base.indexin-Tuple{Any, AbstractArray}"><code>Base.indexin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">indexin(a, b)</code></pre><p>Return an array containing the first index in <code>b</code> for each value in <code>a</code> that is a member of <code>b</code>. The output array contains <code>nothing</code> wherever <code>a</code> is not a member of <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;];

julia&gt; b = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

julia&gt; indexin(a, b)
6-element Vector{Union{Nothing, Int64}}:
 1
 2
 3
 2
  nothing
 1

julia&gt; indexin(b, a)
3-element Vector{Union{Nothing, Int64}}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L2349-L2377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.insert!-Union{Tuple{T}, Tuple{Vector{T}, Integer, Any}} where T" href="#Base.insert!-Union{Tuple{T}, Tuple{Vector{T}, Integer, Any}} where T"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert!(a::Vector, index::Integer, item)</code></pre><p>Insert an <code>item</code> into <code>a</code> at the given <code>index</code>. <code>index</code> is the index of <code>item</code> in the resulting <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; insert!([6, 5, 4, 2, 1], 4, 3)
6-element Vector{Int64}:
 6
 5
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1295-L1312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.instances" href="#Base.instances"><code>Base.instances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">instances(T::Type)</code></pre><p>Return a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see <code>@enum</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @enum Color red blue green

julia&gt; instances(Color)
(red, blue, green)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L760-L773">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect!-Tuple{AbstractSet, Vararg{Any, N} where N}" href="#Base.intersect!-Tuple{AbstractSet, Vararg{Any, N} where N}"><code>Base.intersect!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>Intersect all passed in sets and overwrite <code>s</code> with the result. Maintain order with arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect-Tuple{AbstractSet, Any, Vararg{Any, N} where N}" href="#Base.intersect-Tuple{AbstractSet, Any, Vararg{Any, N} where N}"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersect(s, itrs...)
∩(s, itrs...)</code></pre><p>Construct the intersection of sets. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; intersect([1, 2, 3], [3, 4, 5])
1-element Vector{Int64}:
 3

julia&gt; intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])
2-element Vector{Int64}:
 4
 6

julia&gt; intersect(Set([1, 2]), BitSet([2, 3]))
Set{Int64} with 1 element:
  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L101-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{Number}" href="#Base.inv-Tuple{Number}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(x)</code></pre><p>Return the multiplicative inverse of <code>x</code>, such that <code>x*inv(x)</code> or <code>inv(x)*x</code> yields <a href="#Base.one-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Number"><code>one(x)</code></a> (the multiplicative identity) up to roundoff errors.</p><p>If <code>x</code> is a number, this is essentially the same as <code>one(x)/x</code>, but for some types <code>inv(x)</code> may be slightly more efficient.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inv(2)
0.5

julia&gt; inv(1 + 2im)
0.2 - 0.4im

julia&gt; inv(1 + 2im) * (1 + 2im)
1.0 + 0.0im

julia&gt; inv(2//3)
3//2</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p><code>inv(::Missing)</code> requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L190-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.invmod-Tuple{Integer, Integer}" href="#Base.invmod-Tuple{Integer, Integer}"><code>Base.invmod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invmod(n, m)</code></pre><p>Take the inverse of <code>n</code> modulo <code>m</code>: <code>y</code> such that <span>$n y = 1 \pmod m$</span>, and <span>$div(y,m) = 0$</span>. This will throw an error if <span>$m = 0$</span>, or if <span>$gcd(n,m) \neq 1$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; invmod(2,5)
3

julia&gt; invmod(2,3)
2

julia&gt; invmod(5,6)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L200-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.invoke_in_world-Tuple{UInt64, Any, Vararg{Any, N} where N}" href="#Base.invoke_in_world-Tuple{UInt64, Any, Vararg{Any, N} where N}"><code>Base.invoke_in_world</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invoke_in_world(world, f, args...; kwargs...)</code></pre><p>Call <code>f(args...; kwargs...)</code> in a fixed world age, <code>world</code>.</p><p>This is useful for infrastructure running in the user&#39;s Julia session which is not part of the user&#39;s program. For example, things related to the REPL, editor support libraries, etc. In these cases it can be useful to prevent unwanted method invalidation and recompilation latency, and to prevent the user from breaking supporting infrastructure by mistake.</p><p>The current world age can be queried using <a href="@ref"><code>Base.get_world_counter()</code></a> and stored for later use within the lifetime of the current Julia session, or when serializing and reloading the system image.</p><p>Technically, <code>invoke_in_world</code> will prevent any function called by <code>f</code> from being extended by the user during their Julia session. That is, generic function method tables seen by <code>f</code> (and any functions it calls) will be frozen as they existed at the given <code>world</code> age. In a sense, this is like the opposite of <a href="#Base.invokelatest-Tuple{Any, Vararg{Any, N} where N}"><code>invokelatest</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is not valid to store world ages obtained in precompilation for later use. This is because precompilation generates a &quot;parallel universe&quot; where the world age refers to system state unrelated to the main Julia session.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L713-L738">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.invokelatest-Tuple{Any, Vararg{Any, N} where N}" href="#Base.invokelatest-Tuple{Any, Vararg{Any, N} where N}"><code>Base.invokelatest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invokelatest(f, args...; kwargs...)</code></pre><p>Calls <code>f(args...; kwargs...)</code>, but guarantees that the most recent method of <code>f</code> will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function <code>f</code>. (The drawback is that <code>invokelatest</code> is somewhat slower than calling <code>f</code> directly, and the type of the result cannot be inferred by the compiler.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L695-L704">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.invperm-Tuple{AbstractVector{T} where T}" href="#Base.invperm-Tuple{AbstractVector{T} where T}"><code>Base.invperm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invperm(v)</code></pre><p>Return the inverse permutation of <code>v</code>. If <code>B = A[v]</code>, then <code>A == B[invperm(v)]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = [2; 4; 3; 1];

julia&gt; invperm(v)
4-element Vector{Int64}:
 4
 1
 3
 2

julia&gt; A = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];

julia&gt; B = A[v]
4-element Vector{Char}:
 &#39;b&#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
 &#39;d&#39;: ASCII/Unicode U+0064 (category Ll: Letter, lowercase)
 &#39;c&#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
 &#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia&gt; B[invperm(v)]
4-element Vector{Char}:
 &#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
 &#39;b&#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
 &#39;c&#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
 &#39;d&#39;: ASCII/Unicode U+0064 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/combinatorics.jl#L225-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.invpermute!-Tuple{Any, AbstractVector{T} where T}" href="#Base.invpermute!-Tuple{Any, AbstractVector{T} where T}"><code>Base.invpermute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invpermute!(v, p)</code></pre><p>Like <a href="#Base.permute!-Tuple{Any, AbstractVector{T} where T}"><code>permute!</code></a>, but the inverse of the given permutation is applied.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 1, 3, 4];

julia&gt; perm = [2, 4, 3, 1];

julia&gt; invpermute!(A, perm);

julia&gt; A
4-element Vector{Int64}:
 4
 1
 3
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/combinatorics.jl#L202-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isabstracttype-Tuple{Any}" href="#Base.isabstracttype-Tuple{Any}"><code>Base.isabstracttype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isabstracttype(T)</code></pre><p>Determine whether type <code>T</code> was declared as an abstract type (i.e. using the <code>abstract</code> keyword).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isabstracttype(AbstractArray)
true

julia&gt; isabstracttype(Vector)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L573-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isambiguous-Tuple{Method, Method}" href="#Base.isambiguous-Tuple{Method, Method}"><code>Base.isambiguous</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.isambiguous(m1, m2; ambiguous_bottom=false) -&gt; Bool</code></pre><p>Determine whether two methods <code>m1</code> and <code>m2</code> may be ambiguous for some call signature. This test is performed in the context of other methods of the same function; in isolation, <code>m1</code> and <code>m2</code> might be ambiguous, but if a third method resolving the ambiguity has been defined, this returns <code>false</code>. Alternatively, in isolation <code>m1</code> and <code>m2</code> might be ordered, but if a third method cannot be sorted with them, they may cause an ambiguity together.</p><p>For parametric types, the <code>ambiguous_bottom</code> keyword argument controls whether <code>Union{}</code> counts as an ambiguous intersection of type parameters – when <code>true</code>, it is considered ambiguous, when <code>false</code> it is not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; foo(x::Complex{&lt;:Integer}) = 1
foo (generic function with 1 method)

julia&gt; foo(x::Complex{&lt;:Rational}) = 2
foo (generic function with 2 methods)

julia&gt; m1, m2 = collect(methods(foo));

julia&gt; typeintersect(m1.sig, m2.sig)
Tuple{typeof(foo), Complex{Union{}}}

julia&gt; Base.isambiguous(m1, m2, ambiguous_bottom=true)
true

julia&gt; Base.isambiguous(m1, m2, ambiguous_bottom=false)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1410-L1443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Any}" href="#Base.isapprox-Tuple{Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(x; kwargs...) / ≈(x; kwargs...)</code></pre><p>Create a function that compares its argument to <code>x</code> using <code>≈</code>, i.e. a function equivalent to <code>y -&gt; y ≈ x</code>.</p><p>The keyword arguments supported here are the same as those in the 2-argument <code>isapprox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/floatfuncs.jl#L284-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Number, Number}" href="#Base.isapprox-Tuple{Number, Number}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(x, y; atol::Real=0, rtol::Real=atol&gt;0 ? 0 : √eps, nans::Bool=false[, norm::Function])</code></pre><p>Inexact equality comparison: <code>true</code> if <code>norm(x-y) &lt;= max(atol, rtol*max(norm(x), norm(y)))</code>. The default <code>atol</code> is zero and the default <code>rtol</code> depends on the types of <code>x</code> and <code>y</code>. The keyword argument <code>nans</code> determines whether or not NaN values are considered equal (defaults to false).</p><p>For real or complex floating-point values, if an <code>atol &gt; 0</code> is not specified, <code>rtol</code> defaults to the square root of <a href="#Base.eps-Tuple{AbstractFloat}"><code>eps</code></a> of the type of <code>x</code> or <code>y</code>, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an <code>atol &gt; 0</code> is supplied, <code>rtol</code> defaults to zero.</p><p>The <code>norm</code> keyword defaults to <code>abs</code> for numeric <code>(x,y)</code> and to <code>LinearAlgebra.norm</code> for arrays (where an alternative <code>norm</code> choice is sometimes useful). When <code>x</code> and <code>y</code> are arrays, if <code>norm(x-y)</code> is not finite (i.e. <code>±Inf</code> or <code>NaN</code>), the comparison falls back to checking whether all elements of <code>x</code> and <code>y</code> are approximately equal component-wise.</p><p>The binary operator <code>≈</code> is equivalent to <code>isapprox</code> with the default arguments, and <code>x ≉ y</code> is equivalent to <code>!isapprox(x,y)</code>.</p><p>Note that <code>x ≈ 0</code> (i.e., comparing to zero with the default tolerances) is equivalent to <code>x == 0</code> since the default <code>atol</code> is <code>0</code>.  In such cases, you should either supply an appropriate <code>atol</code> (or use <code>norm(x) ≤ atol</code>) or rearrange your code (e.g. use <code>x ≈ y</code> rather than <code>x - y ≈ 0</code>).   It is not possible to pick a nonzero <code>atol</code> automatically because it depends on the overall scaling (the &quot;units&quot;) of your problem: for example, in <code>x - y ≈ 0</code>, <code>atol=1e-9</code> is an absurdly small tolerance if <code>x</code> is the <a href="https://en.wikipedia.org/wiki/Earth_radius">radius of the Earth</a> in meters, but an absurdly large tolerance if <code>x</code> is the <a href="https://en.wikipedia.org/wiki/Bohr_radius">radius of a Hydrogen atom</a> in meters.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Passing the <code>norm</code> keyword argument when comparing numeric (non-array) arguments requires Julia 1.6 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 0.1 ≈ (0.1 - 1e-10)
true

julia&gt; isapprox(10, 11; atol = 2)
true

julia&gt; isapprox([10.0^9, 1.0], [10.0^9, 2.0])
true

julia&gt; 1e-10 ≈ 0
false

julia&gt; isapprox(1e-10, 0, atol=1e-8)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/floatfuncs.jl#L225-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isascii-Tuple{Char}" href="#Base.isascii-Tuple{Char}"><code>Base.isascii</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isascii(c::Union{AbstractChar,AbstractString}) -&gt; Bool</code></pre><p>Test whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isascii(&#39;a&#39;)
true

julia&gt; isascii(&#39;α&#39;)
false

julia&gt; isascii(&quot;abc&quot;)
true

julia&gt; isascii(&quot;αβγ&quot;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L579-L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isassigned" href="#Base.isassigned"><code>Base.isassigned</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isassigned(array, i) -&gt; Bool</code></pre><p>Test whether the given array has a value associated with index <code>i</code>. Return <code>false</code> if the index is out of bounds, or has an undefined reference.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isassigned(rand(3, 3), 5)
true

julia&gt; isassigned(rand(3, 3), 3 * 3 + 1)
false

julia&gt; mutable struct Foo end

julia&gt; v = similar(rand(3), Foo)
3-element Vector{Foo}:
 #undef
 #undef
 #undef

julia&gt; isassigned(v, 1)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L620-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isassigned-Tuple{Base.RefValue}" href="#Base.isassigned-Tuple{Base.RefValue}"><code>Base.isassigned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isassigned(ref::RefValue) -&gt; Bool</code></pre><p>Test whether the given <a href="#Core.Ref"><code>Ref</code></a> is associated with a value. This is always true for a <a href="#Core.Ref"><code>Ref</code></a> of a bitstype object. Return <code>false</code> if the reference is undefined.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ref = Ref{Function}()
Base.RefValue{Function}(#undef)

julia&gt; isassigned(ref)
false

julia&gt; ref[] = (foobar(x) = x)
foobar (generic function with 1 method)

julia&gt; isassigned(ref)
true

julia&gt; isassigned(Ref{Int}())
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/refvalue.jl#L11-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isbinaryoperator-Tuple{Symbol}" href="#Base.isbinaryoperator-Tuple{Symbol}"><code>Base.isbinaryoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isbinaryoperator(s::Symbol)</code></pre><p>Return <code>true</code> if the symbol can be used as a binary (infix) operator, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Meta.isbinaryoperator(:-), Meta.isbinaryoperator(:√), Meta.isbinaryoperator(:f)
(true, false, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L1273-L1283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isbits-Tuple{Any}" href="#Base.isbits-Tuple{Any}"><code>Base.isbits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isbits(x)</code></pre><p>Return <code>true</code> if <code>x</code> is an instance of an <code>isbitstype</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L516-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isbitstype-Tuple{Type}" href="#Base.isbitstype-Tuple{Type}"><code>Base.isbitstype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isbitstype(T)</code></pre><p>Return <code>true</code> if type <code>T</code> is a &quot;plain data&quot; type, meaning it is immutable and contains no references to other values, only <code>primitive</code> types and other <code>isbitstype</code> types. Typical examples are numeric types such as <a href="@ref"><code>UInt8</code></a>, <a href="@ref"><code>Float64</code></a>, and <a href="#Base.Complex"><code>Complex{Float64}</code></a>. This category of types is significant since they are valid as type parameters, may not track <a href="@ref"><code>isdefined</code></a> / <a href="#Base.isassigned"><code>isassigned</code></a> status, and have a defined layout that is compatible with C.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isbitstype(Complex{Float64})
true

julia&gt; isbitstype(Complex)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L493-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isbitsunion-Tuple{Union}" href="#Base.isbitsunion-Tuple{Union}"><code>Base.isbitsunion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.isbitsunion(::Type{T})</code></pre><p>Return whether a type is an &quot;is-bits&quot; Union type, meaning each type included in a Union is <a href="#Base.isbitstype-Tuple{Type}"><code>isbitstype</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.isbitsunion(Union{Float64, UInt8})
true

julia&gt; Base.isbitsunion(Union{Float64, String})
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L141-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isconcretetype-Tuple{Any}" href="#Base.isconcretetype-Tuple{Any}"><code>Base.isconcretetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isconcretetype(T)</code></pre><p>Determine whether type <code>T</code> is a concrete type, meaning it could have direct instances (values <code>x</code> such that <code>typeof(x) === T</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isconcretetype(Complex)
false

julia&gt; isconcretetype(Complex{Float32})
true

julia&gt; isconcretetype(Vector{Complex})
true

julia&gt; isconcretetype(Vector{Complex{Float32}})
true

julia&gt; isconcretetype(Union{})
false

julia&gt; isconcretetype(Union{Int,String})
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L544-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isconst-Tuple{Module, Symbol}" href="#Base.isconst-Tuple{Module, Symbol}"><code>Base.isconst</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isconst(m::Module, s::Symbol) -&gt; Bool</code></pre><p>Determine whether a global is declared <code>const</code> in a given <code>Module</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isdisjoint-Tuple{Any, Any}" href="#Base.isdisjoint-Tuple{Any, Any}"><code>Base.isdisjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isdisjoint(v1, v2) -&gt; Bool</code></pre><p>Return whether the collections <code>v1</code> and <code>v2</code> are disjoint, i.e. whether their intersection is empty.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L385-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isdispatchtuple-Tuple{Any}" href="#Base.isdispatchtuple-Tuple{Any}"><code>Base.isdispatchtuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isdispatchtuple(T)</code></pre><p>Determine whether type <code>T</code> is a tuple &quot;leaf type&quot;, meaning it could appear as a type signature in dispatch and has no subtypes (or supertypes) which could appear in a call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L523-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isdone-Tuple{Any, Vararg{Any, N} where N}" href="#Base.isdone-Tuple{Any, Vararg{Any, N} where N}"><code>Base.isdone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isdone(itr, state...) -&gt; Union{Bool, Missing}</code></pre><p>This function provides a fast-path hint for iterator completion. This is useful for mutable iterators that want to avoid having elements consumed, if they are not going to be exposed to the user (e.g. to check for done-ness in <code>isempty</code> or <code>zip</code>). Mutable iterators that want to opt into this feature should define an isdone method that returns true/false depending on whether the iterator is done or not. Stateless iterators need not implement this function. If the result is <code>missing</code>, callers may go ahead and compute <code>iterate(x, state...) === nothing</code> to compute a definite answer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L856-L868">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{Any}" href="#Base.isempty-Tuple{Any}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isempty(collection) -&gt; Bool</code></pre><p>Determine whether a collection is empty (has no elements).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isempty([])
true

julia&gt; isempty([1 2 3])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L750-L763">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{Base.GenericCondition}" href="#Base.isempty-Tuple{Base.GenericCondition}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isempty(condition)</code></pre><p>Return <code>true</code> if no tasks are waiting on the condition, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/condition.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Tuple{Any, Any}" href="#Base.isequal-Tuple{Any, Any}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isequal(x, y)</code></pre><p>Similar to <a href="#Base.:=="><code>==</code></a>, except for the treatment of floating point numbers and of missing values. <code>isequal</code> treats all floating-point <code>NaN</code> values as equal to each other, treats <code>-0.0</code> as unequal to <code>0.0</code>, and <a href="#Base.missing"><code>missing</code></a> as equal to <code>missing</code>. Always returns a <code>Bool</code> value.</p><p><strong>Implementation</strong></p><p>The default implementation of <code>isequal</code> calls <code>==</code>, so a type that does not involve floating-point values generally only needs to define <code>==</code>.</p><p><code>isequal</code> is the comparison function used by hash tables (<code>Dict</code>). <code>isequal(x,y)</code> must imply that <code>hash(x) == hash(y)</code>.</p><p>This typically means that types for which a custom <code>==</code> or <code>isequal</code> method exists must implement a corresponding <code>hash</code> method (and vice versa). Collections typically implement <code>isequal</code> by calling <code>isequal</code> recursively on all contents.</p><p>Scalar types generally do not need to implement <code>isequal</code> separate from <code>==</code>, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on <code>isnan</code>, <code>signbit</code>, and <code>==</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isequal([1., NaN], [1., NaN])
true

julia&gt; [1., NaN] == [1., NaN]
false

julia&gt; 0.0 == -0.0
true

julia&gt; isequal(0.0, -0.0)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L85-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Tuple{Any}" href="#Base.isequal-Tuple{Any}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isequal(x)</code></pre><p>Create a function that compares its argument to <code>x</code> using <a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a>, i.e. a function equivalent to <code>y -&gt; isequal(y, x)</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(isequal)}</code>, which can be used to implement specialized methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1004-L1012">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iseven-Tuple{Integer}" href="#Base.iseven-Tuple{Integer}"><code>Base.iseven</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iseven(x::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>x</code> is even (that is, divisible by 2), and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; iseven(9)
false

julia&gt; iseven(10)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L111-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isfinite-Tuple{Number}" href="#Base.isfinite-Tuple{Number}"><code>Base.isfinite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isfinite(f) -&gt; Bool</code></pre><p>Test whether a number is finite.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isfinite(5)
true

julia&gt; isfinite(NaN32)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isidentifier-Tuple{AbstractString}" href="#Base.isidentifier-Tuple{AbstractString}"><code>Base.isidentifier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> isidentifier(s) -&gt; Bool</code></pre><p>Return whether the symbol or string <code>s</code> contains characters that are parsed as a valid identifier in Julia code.</p><p>Internally Julia allows any sequence of characters in a <code>Symbol</code> (except <code>\0</code>s), and macros automatically use variable names containing <code>#</code> in order to avoid naming collision with the surrounding code. In order for the parser to recognize a variable, it uses a limited set of characters (greatly extended by Unicode). <code>isidentifier()</code> makes it possible to query the parser directly whether a symbol contains valid characters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Meta.isidentifier(:x), Meta.isidentifier(&quot;1x&quot;)
(true, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L1213-L1231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isimmutable-Tuple{Any}" href="#Base.isimmutable-Tuple{Any}"><code>Base.isimmutable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isimmutable(v) -&gt; Bool</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Consider using <code>!ismutable(v)</code> instead, as <code>isimmutable(v)</code> will be replaced by <code>!ismutable(v)</code> in a future release. (Since Julia 1.5)</p></div></div><p>Return <code>true</code> iff value <code>v</code> is immutable.  See <a href="@ref">Mutable Composite Types</a> for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of <code>DataType</code> is mutable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isimmutable(1)
true

julia&gt; isimmutable([1,2])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/deprecated.jl#L181-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isinf-Tuple{Real}" href="#Base.isinf-Tuple{Real}"><code>Base.isinf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinf(f) -&gt; Bool</code></pre><p>Test whether a number is infinite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L456-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isinteger-Tuple{Integer}" href="#Base.isinteger-Tuple{Integer}"><code>Base.isinteger</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinteger(x) -&gt; Bool</code></pre><p>Test whether <code>x</code> is numerically equal to some integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isinteger(4.0)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isinteractive-Tuple{}" href="#Base.isinteractive-Tuple{}"><code>Base.isinteractive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isinteractive() -&gt; Bool</code></pre><p>Determine whether Julia is running an interactive session.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/initdefs.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isiterable-Tuple{Any}" href="#Base.isiterable-Tuple{Any}"><code>Base.isiterable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isiterable(T) -&gt; Bool</code></pre><p>Test if type <code>T</code> is an iterable collection type or not, that is whether it has an <code>iterate</code> method or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L880-L885">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless" href="#Base.isless"><code>Base.isless</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isless(x, y)</code></pre><p>Test whether <code>x</code> is less than <code>y</code>, according to a fixed total order. <code>isless</code> is not defined on all pairs of values <code>(x, y)</code>. However, if it is defined, it is expected to satisfy the following:</p><ul><li>If <code>isless(x, y)</code> is defined, then so is <code>isless(y, x)</code> and <code>isequal(x, y)</code>, and exactly one of those three yields <code>true</code>.</li><li>The relation defined by <code>isless</code> is transitive, i.e., <code>isless(x, y) &amp;&amp; isless(y, z)</code> implies <code>isless(x, z)</code>.</li></ul><p>Values that are normally unordered, such as <code>NaN</code>, are ordered in an arbitrary but consistent fashion. <a href="#Base.missing"><code>missing</code></a> values are ordered last.</p><p>This is the default comparison used by <a href="@ref"><code>sort</code></a>.</p><p><strong>Implementation</strong></p><p>Non-numeric types with a total order should implement this function. Numeric types only need to implement it if they have special values such as <code>NaN</code>. Types with a partial order should implement <a href="#Base.:&lt;-Tuple{Any, Any}"><code>&lt;</code></a>. See the documentation on <a href="@ref">Alternate orderings</a> for how to define alternate ordering methods that can be used in sorting and related functions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isless(1, 3)
true

julia&gt; isless(&quot;Red&quot;, &quot;Blue&quot;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L132-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{AbstractString, AbstractString}" href="#Base.isless-Tuple{AbstractString, AbstractString}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isless(a::AbstractString, b::AbstractString) -&gt; Bool</code></pre><p>Test whether string <code>a</code> comes before string <code>b</code> in alphabetical order (technically, in lexicographical order by Unicode code points).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isless(&quot;a&quot;, &quot;b&quot;)
true

julia&gt; isless(&quot;β&quot;, &quot;α&quot;)
false

julia&gt; isless(&quot;a&quot;, &quot;a&quot;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L326-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}" href="#Base.isless-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isless(A::AbstractVector, B::AbstractVector)</code></pre><p>Returns true when <code>A</code> is less than <code>B</code> in lexicographic order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1984-L1988">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{Tuple, Tuple}" href="#Base.isless-Tuple{Tuple, Tuple}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isless(t1::Tuple, t2::Tuple)</code></pre><p>Returns true when t1 is less than t2 in lexicographic order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/tuple.jl#L438-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.islocked-Tuple{ReentrantLock}" href="#Base.islocked-Tuple{ReentrantLock}"><code>Base.islocked</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">islocked(lock) -&gt; Status (Boolean)</code></pre><p>Check whether the <code>lock</code> is held by any task/thread. This should not be used for synchronization (see instead <a href="#Base.trylock-Tuple{ReentrantLock}"><code>trylock</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/lock.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ismalformed-Tuple{AbstractChar}" href="#Base.ismalformed-Tuple{AbstractChar}"><code>Base.ismalformed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismalformed(c::AbstractChar) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>c</code> represents malformed (non-Unicode) data according to the encoding used by <code>c</code>.  Defaults to <code>false</code> for non-<code>Char</code> types.  See also <a href="#Base.show_invalid"><code>show_invalid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/char.jl#L106-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ismarked-Tuple{IO}" href="#Base.ismarked-Tuple{IO}"><code>Base.ismarked</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismarked(s)</code></pre><p>Return <code>true</code> if stream <code>s</code> is marked.</p><p>See also <a href="#Base.mark-Tuple{IO}"><code>mark</code></a>, <a href="#Base.unmark-Tuple{IO}"><code>unmark</code></a>, <a href="#Base.reset-Tuple{T} where T&lt;:IO"><code>reset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L1101-L1107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ismissing-Tuple{Any}" href="#Base.ismissing-Tuple{Any}"><code>Base.ismissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismissing(x)</code></pre><p>Indicate whether <code>x</code> is <a href="#Base.missing"><code>missing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L809-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ismutable-Tuple{Any}" href="#Base.ismutable-Tuple{Any}"><code>Base.ismutable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ismutable(v) -&gt; Bool</code></pre><p>Return <code>true</code> iff value <code>v</code> is mutable.  See <a href="@ref">Mutable Composite Types</a> for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of <code>DataType</code> is mutable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ismutable(1)
false

julia&gt; ismutable([1,2])
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L442-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isnan-Tuple{AbstractFloat}" href="#Base.isnan-Tuple{AbstractFloat}"><code>Base.isnan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isnan(f) -&gt; Bool</code></pre><p>Test whether a number value is a NaN, an indeterminate value which is neither an infinity nor a finite number (&quot;not a number&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L443-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isnothing-Tuple{Any}" href="#Base.isnothing-Tuple{Any}"><code>Base.isnothing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isnothing(x)</code></pre><p>Return <code>true</code> if <code>x === nothing</code>, and return <code>false</code> if not.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This function requires at least Julia 1.1.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/some.jl#L58-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isodd-Tuple{Integer}" href="#Base.isodd-Tuple{Integer}"><code>Base.isodd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isodd(x::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>x</code> is odd (that is, not divisible by 2), and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isodd(9)
true

julia&gt; isodd(10)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L95-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isone-Tuple{Any}" href="#Base.isone-Tuple{Any}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isone(x)</code></pre><p>Return <code>true</code> if <code>x == one(x)</code>; if <code>x</code> is an array, this checks whether <code>x</code> is an identity matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isone(1.0)
true

julia&gt; isone([1 0; 0 2])
false

julia&gt; isone([1 0; 0 true])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L42-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isopen" href="#Base.isopen"><code>Base.isopen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isopen(object) -&gt; Bool</code></pre><p>Determine whether an object - such as a stream or timer – is not yet closed. Once an object is closed, it will never produce a new event. However, since a closed stream may still have data to read in its buffer, use <a href="#Base.eof-Tuple{Base.AbstractPipe}"><code>eof</code></a> to check for the ability to read data. Use the <code>FileWatching</code> package to be notified when a stream might be writable or readable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = open(&quot;my_file.txt&quot;, &quot;w+&quot;);

julia&gt; isopen(io)
true

julia&gt; close(io)

julia&gt; isopen(io)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L33-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isoperator-Tuple{Union{AbstractString, Symbol}}" href="#Base.isoperator-Tuple{Union{AbstractString, Symbol}}"><code>Base.isoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isoperator(s::Symbol)</code></pre><p>Return <code>true</code> if the symbol can be used as an operator, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Meta.isoperator(:+), Meta.isoperator(:f)
(true, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L1245-L1255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isoverlong-Tuple{AbstractChar}" href="#Base.isoverlong-Tuple{AbstractChar}"><code>Base.isoverlong</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isoverlong(c::AbstractChar) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>c</code> represents an overlong UTF-8 sequence. Defaults to <code>false</code> for non-<code>Char</code> types.  See also <a href="#Base.decode_overlong"><code>decode_overlong</code></a> and <a href="#Base.show_invalid"><code>show_invalid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/char.jl#L115-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isperm-Tuple{Any}" href="#Base.isperm-Tuple{Any}"><code>Base.isperm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isperm(v) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>v</code> is a valid permutation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isperm([1; 2])
true

julia&gt; isperm([1; 3])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/combinatorics.jl#L55-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ispostfixoperator-Tuple{Union{AbstractString, Symbol}}" href="#Base.ispostfixoperator-Tuple{Union{AbstractString, Symbol}}"><code>Base.ispostfixoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispostfixoperator(s::Union{Symbol,AbstractString})</code></pre><p>Return <code>true</code> if the symbol can be used as a postfix operator, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Meta.ispostfixoperator(Symbol(&quot;&#39;&quot;)), Meta.ispostfixoperator(Symbol(&quot;&#39;ᵀ&quot;)), Meta.ispostfixoperator(:-)
(true, true, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L1289-L1299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ispow2-Tuple{Number}" href="#Base.ispow2-Tuple{Number}"><code>Base.ispow2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ispow2(n::Number) -&gt; Bool</code></pre><p>Test whether <code>n</code> is an integer power of two.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ispow2(4)
true

julia&gt; ispow2(5)
false

julia&gt; ispow2(4.5)
false

julia&gt; ispow2(0.25)
true

julia&gt; ispow2(1//8)
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Support for non-<code>Integer</code> arguments was added in Julia 1.6.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L387-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isprimitivetype-Tuple{Type}" href="#Base.isprimitivetype-Tuple{Type}"><code>Base.isprimitivetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isprimitivetype(T) -&gt; Bool</code></pre><p>Determine whether type <code>T</code> was declared as a primitive type (i.e. using the <code>primitive</code> keyword).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L478-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isqrt-Tuple{Integer}" href="#Base.isqrt-Tuple{Integer}"><code>Base.isqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isqrt(n::Integer)</code></pre><p>Integer square root: the largest integer <code>m</code> such that <code>m*m &lt;= n</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; isqrt(5)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L910-L919">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isreadable" href="#Base.isreadable"><code>Base.isreadable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isreadable(io) -&gt; Bool</code></pre><p>Return <code>true</code> if the specified IO object is readable (if that can be determined).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; open(&quot;myfile.txt&quot;, &quot;w&quot;) do io
           print(io, &quot;Hello world!&quot;);
           isreadable(io)
       end
false

julia&gt; open(&quot;myfile.txt&quot;, &quot;r&quot;) do io
           isreadable(io)
       end
true

julia&gt; rm(&quot;myfile.txt&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L81-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isreadonly-Tuple{Any}" href="#Base.isreadonly-Tuple{Any}"><code>Base.isreadonly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isreadonly(io) -&gt; Bool</code></pre><p>Determine whether a stream is read-only.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization&quot;);

julia&gt; isreadonly(io)
true

julia&gt; io = IOBuffer();

julia&gt; isreadonly(io)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L613-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isready-Tuple{Channel}" href="#Base.isready-Tuple{Channel}"><code>Base.isready</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isready(c::Channel)</code></pre><p>Determine whether a <a href="#Base.Channel"><code>Channel</code></a> has a value stored to it. Returns immediately, does not block.</p><p>For unbuffered channels returns <code>true</code> if there are tasks waiting on a <a href="#Base.put!-Union{Tuple{T}, Tuple{Channel{T}, Any}} where T"><code>put!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/channels.jl#L411-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isreal-Tuple{Real}" href="#Base.isreal-Tuple{Real}"><code>Base.isreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isreal(x) -&gt; Bool</code></pre><p>Test whether <code>x</code> or all its elements are numerically equal to some real number including infinities and NaNs. <code>isreal(x)</code> is true if <code>isequal(x, real(x))</code> is true.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isreal(5.)
true

julia&gt; isreal(Inf + 0im)
true

julia&gt; isreal([4.; complex(0,1)])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L113-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.issetequal-Tuple{AbstractSet, AbstractSet}" href="#Base.issetequal-Tuple{AbstractSet, AbstractSet}"><code>Base.issetequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issetequal(a, b) -&gt; Bool</code></pre><p>Determine whether <code>a</code> and <code>b</code> have the same elements. Equivalent to <code>a ⊆ b &amp;&amp; b ⊆ a</code> but more efficient when possible.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; issetequal([1, 2], [1, 2, 3])
false

julia&gt; issetequal([1, 2], [2, 1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L352-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.issingletontype-Tuple{Any}" href="#Base.issingletontype-Tuple{Any}"><code>Base.issingletontype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.issingletontype(T)</code></pre><p>Determine whether type <code>T</code> has exactly one possible instance; for example, a struct type with no fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L595-L600">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isstructtype-Tuple{Type}" href="#Base.isstructtype-Tuple{Type}"><code>Base.isstructtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isstructtype(T) -&gt; Bool</code></pre><p>Determine whether type <code>T</code> was declared as a struct type (i.e. using the <code>struct</code> or <code>mutable struct</code> keyword).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L463-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.issubnormal-Tuple{T} where T&lt;:Union{Float16, Float32, Float64}" href="#Base.issubnormal-Tuple{T} where T&lt;:Union{Float16, Float32, Float64}"><code>Base.issubnormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issubnormal(f) -&gt; Bool</code></pre><p>Test whether a floating point number is subnormal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L731-L735">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.issubset" href="#Base.issubset"><code>Base.issubset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">issubset(a, b) -&gt; Bool
⊆(a, b) -&gt; Bool
⊇(b, a) -&gt; Bool</code></pre><p>Determine whether every element of <code>a</code> is also in <code>b</code>, using <a href="#Base.in"><code>in</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; issubset([1, 2], [1, 2, 3])
true

julia&gt; [1, 2, 3] ⊆ [1, 2]
false

julia&gt; [1, 2, 3] ⊇ [1, 2]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L246-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.istaskdone-Tuple{Task}" href="#Base.istaskdone-Tuple{Task}"><code>Base.istaskdone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istaskdone(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has exited.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a2() = sum(i for i in 1:1000);

julia&gt; b = Task(a2);

julia&gt; istaskdone(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L174-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.istaskfailed-Tuple{Task}" href="#Base.istaskfailed-Tuple{Task}"><code>Base.istaskfailed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istaskfailed(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has exited because an exception was thrown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a4() = error(&quot;task failed&quot;);

julia&gt; b = Task(a4);

julia&gt; istaskfailed(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskfailed(b)
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L215-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.istaskstarted-Tuple{Task}" href="#Base.istaskstarted-Tuple{Task}"><code>Base.istaskstarted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istaskstarted(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has started executing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a3() = sum(i for i in 1:1000);

julia&gt; b = Task(a3);

julia&gt; istaskstarted(b)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L198-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isunaryoperator-Tuple{Symbol}" href="#Base.isunaryoperator-Tuple{Symbol}"><code>Base.isunaryoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isunaryoperator(s::Symbol)</code></pre><p>Return <code>true</code> if the symbol can be used as a unary (prefix) operator, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Meta.isunaryoperator(:-), Meta.isunaryoperator(:√), Meta.isunaryoperator(:f)
(true, true, false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L1258-L1268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isvalid-Tuple{AbstractString, Integer}" href="#Base.isvalid-Tuple{AbstractString, Integer}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isvalid(s::AbstractString, i::Integer) -&gt; Bool</code></pre><p>Predicate indicating whether the given index is the start of the encoding of a character in <code>s</code> or not. If <code>isvalid(s, i)</code> is true then <code>s[i]</code> will return the character whose encoding starts at that index, if it&#39;s false, then <code>s[i]</code> will raise an invalid index error or a bounds error depending on if <code>i</code> is in bounds. In order for <code>isvalid(s, i)</code> to be an O(1) function, the encoding of <code>s</code> must be <a href="https://en.wikipedia.org/wiki/Self-synchronizing_code">self-synchronizing</a>. This is a basic assumption of Julia&#39;s generic string support.</p><p>See also: <a href="#Base.getindex"><code>getindex</code></a>, <a href="#Base.iterate"><code>iterate</code></a>, <a href="#Base.thisind-Tuple{AbstractString, Integer}"><code>thisind</code></a>, <a href="#Base.nextind-Tuple{AbstractString, Integer, Integer}"><code>nextind</code></a>, <a href="#Base.prevind-Tuple{AbstractString, Integer, Integer}"><code>prevind</code></a>, <a href="#Base.length"><code>length</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; str = &quot;αβγdef&quot;;

julia&gt; isvalid(str, 1)
true

julia&gt; str[1]
&#39;α&#39;: Unicode U+03B1 (category Ll: Letter, lowercase)

julia&gt; isvalid(str, 2)
false

julia&gt; str[2]
ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=&gt;&#39;α&#39;, [3]=&gt;&#39;β&#39;
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L110-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iswritable" href="#Base.iswritable"><code>Base.iswritable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswritable(io) -&gt; Bool</code></pre><p>Return <code>true</code> if the specified IO object is writable (if that can be determined).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; open(&quot;myfile.txt&quot;, &quot;w&quot;) do io
           print(io, &quot;Hello world!&quot;);
           iswritable(io)
       end
true

julia&gt; open(&quot;myfile.txt&quot;, &quot;r&quot;) do io
           iswritable(io)
       end
false

julia&gt; rm(&quot;myfile.txt&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L104-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iszero-Tuple{Any}" href="#Base.iszero-Tuple{Any}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iszero(x)</code></pre><p>Return <code>true</code> if <code>x == zero(x)</code>; if <code>x</code> is an array, this checks whether all of the elements of <code>x</code> are zero.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; iszero(0.0)
true

julia&gt; iszero([1, 9, 0])
false

julia&gt; iszero([false, 0, 0])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L22-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterate(iter [, state]) -&gt; Union{Nothing, Tuple{Any, Any}}</code></pre><p>Advance the iterator to obtain the next element. If no elements remain, <code>nothing</code> should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L871-L877">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Tuple{AbstractString, Integer}" href="#Base.iterate-Tuple{AbstractString, Integer}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate(s::AbstractString, i::Integer) -&gt; Union{Tuple{&lt;:AbstractChar, Int}, Nothing}</code></pre><p>Return a tuple of the character in <code>s</code> at index <code>i</code> with the index of the start of the following character in <code>s</code>. This is the key method that allows strings to be iterated, yielding a sequences of characters. If <code>i</code> is out of bounds in <code>s</code> then a bounds error is raised. The <code>iterate</code> function, as part of the iteration protocol may assume that <code>i</code> is the start of a character in <code>s</code>.</p><p>See also: <a href="#Base.getindex"><code>getindex</code></a>, <a href="#Base.checkbounds-Tuple{AbstractArray, Vararg{Any, N} where N}"><code>checkbounds</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L146-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.jit_total_bytes-Tuple{}" href="#Base.jit_total_bytes-Tuple{}"><code>Base.jit_total_bytes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.jit_total_bytes()</code></pre><p>Return the total amount (in bytes) allocated by the just-in-time compiler for e.g. native code and data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/timing.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.join-Tuple{IO, Any, Any, Any}" href="#Base.join-Tuple{IO, Any, Any, Any}"><code>Base.join</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">join([io::IO,] strings [, delim [, last]])</code></pre><p>Join an array of <code>strings</code> into a single string, inserting the given delimiter (if any) between adjacent strings. If <code>last</code> is given, it will be used instead of <code>delim</code> between the last two strings. If <code>io</code> is given, the result is written to <code>io</code> rather than returned as a <code>String</code>.</p><p><code>strings</code> can be any iterable over elements <code>x</code> which are convertible to strings via <code>print(io::IOBuffer, x)</code>. <code>strings</code> will be printed to <code>io</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; join([&quot;apples&quot;, &quot;bananas&quot;, &quot;pineapples&quot;], &quot;, &quot;, &quot; and &quot;)
&quot;apples, bananas and pineapples&quot;

julia&gt; join([1,2,3,4,5])
&quot;12345&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L246-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.julia_cmd" href="#Base.julia_cmd"><code>Base.julia_cmd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.julia_cmd(juliapath=joinpath(Sys.BINDIR::String, julia_exename()))</code></pre><p>Return a julia command similar to the one of the running process. Propagates any of the <code>--cpu-target</code>, <code>--sysimage</code>, <code>--compile</code>, <code>--sysimage-native-code</code>, <code>--compiled-modules</code>, <code>--inline</code>, <code>--check-bounds</code>, <code>--optimize</code>, <code>-g</code>, <code>--code-coverage</code>, <code>--track-allocation</code>, <code>--color</code>, <code>--startup-file</code>, and <code>--depwarn</code> command line arguments that are not at their default values.</p><p>Among others, <code>--math-mode</code>, <code>--warn-overwrite</code>, and <code>--trace-compile</code> are notably not propagated currently.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Only the <code>--cpu-target</code>, <code>--sysimage</code>, <code>--depwarn</code>, <code>--compile</code> and <code>--check-bounds</code> flags were propagated before Julia 1.1.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The flags <code>--color</code> and <code>--startup-file</code> were added in Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/util.jl#L110-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">keys(iterator)</code></pre><p>For an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{AbstractDict}" href="#Base.keys-Tuple{AbstractDict}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keys(a::AbstractDict)</code></pre><p>Return an iterator over all keys in a dictionary. <code>collect(keys(a))</code> returns an array of keys. When the keys are stored internally in a hash table, as is the case for <code>Dict</code>, the order in which they are returned may vary. But <code>keys(a)</code> and <code>values(a)</code> both iterate <code>a</code> and return the elements in the same order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char, Int64} with 2 entries:
  &#39;a&#39; =&gt; 2
  &#39;b&#39; =&gt; 3

julia&gt; collect(keys(D))
2-element Vector{Char}:
 &#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
 &#39;b&#39;: ASCII/Unicode U+0062 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L79-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keytype-Tuple{AbstractArray}" href="#Base.keytype-Tuple{AbstractArray}"><code>Base.keytype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keytype(T::Type{&lt;:AbstractArray})
keytype(A::AbstractArray)</code></pre><p>Return the key type of an array. This is equal to the <code>eltype</code> of the result of <code>keys(...)</code>, and is provided mainly for compatibility with the dictionary interface.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; keytype([1, 2, 3]) == Int
true

julia&gt; keytype([1 2; 3 4])
CartesianIndex{2}</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>For arrays, this function requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L118-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keytype-Union{Tuple{Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:AbstractDict{K, V}}, Tuple{V}, Tuple{K}} where {K, V}" href="#Base.keytype-Union{Tuple{Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:AbstractDict{K, V}}, Tuple{V}, Tuple{K}} where {K, V}"><code>Base.keytype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">keytype(type)</code></pre><p>Get the key type of an dictionary type. Behaves similarly to <a href="#Base.eltype-Tuple{Type}"><code>eltype</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; keytype(Dict(Int32(1) =&gt; &quot;foo&quot;))
Int32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L249-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kill" href="#Base.kill"><code>Base.kill</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kill(p::Process, signum=Base.SIGTERM)</code></pre><p>Send a signal to a process. The default is to terminate the process. Returns successfully if the process has already exited, but throws an error if killing the process failed for other reasons (e.g. insufficient permissions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L541-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last-Tuple{AbstractString, Integer}" href="#Base.last-Tuple{AbstractString, Integer}"><code>Base.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(s::AbstractString, n::Integer)</code></pre><p>Get a string consisting of the last <code>n</code> characters of <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 0)
&quot;&quot;

julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 1)
&quot;0&quot;

julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 3)
&quot;²&gt;0&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L651-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last-Tuple{Any, Integer}" href="#Base.last-Tuple{Any, Integer}"><code>Base.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(itr, n::Integer)</code></pre><p>Get the last <code>n</code> elements of the iterable collection <code>itr</code>, or fewer elements if <code>v</code> is not long enough.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This method requires at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; last([&quot;foo&quot;, &quot;bar&quot;, &quot;qux&quot;], 2)
2-element Vector{String}:
 &quot;bar&quot;
 &quot;qux&quot;

julia&gt; last(1:6, 10)
1:6

julia&gt; last(Float64[], 1)
Float64[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L439-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last-Tuple{Any}" href="#Base.last-Tuple{Any}"><code>Base.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(coll)</code></pre><p>Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling <a href="#Base.lastindex-Tuple{AbstractArray}"><code>lastindex</code></a> to get the last index. Return the end point of an <a href="#Base.AbstractRange"><code>AbstractRange</code></a> even if it is empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; last(1:2:10)
9

julia&gt; last([1; 2; 3; 4])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L421-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.lastindex-Tuple{AbstractArray}" href="#Base.lastindex-Tuple{AbstractArray}"><code>Base.lastindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lastindex(collection) -&gt; Integer
lastindex(collection, d) -&gt; Integer</code></pre><p>Return the last index of <code>collection</code>. If <code>d</code> is given, return the last index of <code>collection</code> along dimension <code>d</code>.</p><p>The syntaxes <code>A[end]</code> and <code>A[end, end]</code> lower to <code>A[lastindex(A)]</code> and <code>A[lastindex(A, 1), lastindex(A, 2)]</code>, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lastindex([1,2,4])
3

julia&gt; lastindex(rand(3,4,5), 2)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L329-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.lcm-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer" href="#Base.lcm-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>Base.lcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lcm(x, y...)</code></pre><p>Least common (positive) multiple (or zero if any argument is zero). The arguments may be integer and rational numbers.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>Rational arguments require Julia 1.4 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lcm(2,3)
6

julia&gt; lcm(-2,3)
6

julia&gt; lcm(0,3)
0

julia&gt; lcm(0,0)
0

julia&gt; lcm(1//3,2//3)
2//3

julia&gt; lcm(1//3,-2//3)
2//3

julia&gt; lcm(1//3,2)
2//1

julia&gt; lcm(1,3,5,7)
105</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L74-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.leading_ones-Tuple{Integer}" href="#Base.leading_ones-Tuple{Integer}"><code>Base.leading_ones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leading_ones(x::Integer) -&gt; Integer</code></pre><p>Number of ones leading the binary representation of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; leading_ones(UInt32(2 ^ 32 - 2))
31</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L413-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.leading_zeros-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}" href="#Base.leading_zeros-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}"><code>Base.leading_zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leading_zeros(x::Integer) -&gt; Integer</code></pre><p>Number of zeros leading the binary representation of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; leading_zeros(Int32(1))
31</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L374-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">length(collection) -&gt; Integer</code></pre><p>Return the number of elements in the collection.</p><p>Use <a href="#Base.lastindex-Tuple{AbstractArray}"><code>lastindex</code></a> to get the last valid index of an indexable collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; length(1:5)
5

julia&gt; length([1, 2, 3, 4])
4

julia&gt; length([1 2; 3 4])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L215-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{AbstractArray}" href="#Base.length-Tuple{AbstractArray}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(A::AbstractArray)</code></pre><p>Return the number of elements in the array, defaults to <code>prod(size(A))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; length([1, 2, 3, 4])
4

julia&gt; length([1 2; 3 4])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L236-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{AbstractString}" href="#Base.length-Tuple{AbstractString}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(s::AbstractString) -&gt; Int
length(s::AbstractString, i::Integer, j::Integer) -&gt; Int</code></pre><p>Return the number of characters in string <code>s</code> from indices <code>i</code> through <code>j</code>.</p><p>This is computed as the number of code unit indices from <code>i</code> to <code>j</code> which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With <code>i</code> and <code>j</code> arguments it computes the number of indices between <code>i</code> and <code>j</code> inclusive that are valid indices in the string <code>s</code>. In addition to in-bounds values, <code>i</code> may take the out-of-bounds value <code>ncodeunits(s) + 1</code> and <code>j</code> may take the out-of-bounds value <code>0</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The time complexity of this operation is linear in general. That is, it will take the time proportional to the number of bytes or characters in the string because it counts the value on the fly. This is in contrast to the method for arrays, which is a constant-time operation.</p></div></div><p>See also: <a href="#Base.isvalid-Tuple{AbstractString, Integer}"><code>isvalid</code></a>, <a href="#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a>, <a href="#Base.lastindex-Tuple{AbstractArray}"><code>lastindex</code></a>, <a href="#Base.thisind-Tuple{AbstractString, Integer}"><code>thisind</code></a>, <a href="#Base.nextind-Tuple{AbstractString, Integer, Integer}"><code>nextind</code></a>, <a href="#Base.prevind-Tuple{AbstractString, Integer, Integer}"><code>prevind</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; length(&quot;jμΛIα&quot;)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L358-L386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.lock-Tuple{Any, Base.AbstractLock}" href="#Base.lock-Tuple{Any, Base.AbstractLock}"><code>Base.lock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lock(f::Function, lock)</code></pre><p>Acquire the <code>lock</code>, execute <code>f</code> with the <code>lock</code> held, and release the <code>lock</code> when <code>f</code> returns. If the lock is already locked by a different task/thread, wait for it to become available.</p><p>When this function returns, the <code>lock</code> has been released, so the caller should not attempt to <code>unlock</code> it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/lock.jl#L174-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.lock-Tuple{ReentrantLock}" href="#Base.lock-Tuple{ReentrantLock}"><code>Base.lock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lock(lock)</code></pre><p>Acquire the <code>lock</code> when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</p><p>Each <code>lock</code> must be matched by an <a href="#Base.unlock-Tuple{ReentrantLock}"><code>unlock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/lock.jl#L77-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.lpad" href="#Base.lpad"><code>Base.lpad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=&#39; &#39;) -&gt; String</code></pre><p>Stringify <code>s</code> and pad the resulting string on the left with <code>p</code> to make it <code>n</code> characters (code points) long. If <code>s</code> is already <code>n</code> characters long, an equal string is returned. Pad with spaces by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; lpad(&quot;March&quot;, 10)
&quot;     March&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L314-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.lstrip-Tuple{Any, AbstractString}" href="#Base.lstrip-Tuple{Any, AbstractString}"><code>Base.lstrip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lstrip([pred=isspace,] str::AbstractString) -&gt; SubString
lstrip(str::AbstractString, chars) -&gt; SubString</code></pre><p>Remove leading characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p><p>The default behaviour is to remove leading whitespace and delimiters: see <a href="@ref"><code>isspace</code></a> for precise details.</p><p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = lpad(&quot;March&quot;, 20)
&quot;               March&quot;

julia&gt; lstrip(a)
&quot;March&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L223-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ltoh-Tuple{Any}" href="#Base.ltoh-Tuple{Any}"><code>Base.ltoh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ltoh(x)</code></pre><p>Convert the endianness of a value from Little-endian to that used by the Host.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L598-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.macroexpand-Tuple{Module, Any}" href="#Base.macroexpand-Tuple{Module, Any}"><code>Base.macroexpand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">macroexpand(m::Module, x; recursive=true)</code></pre><p>Take the expression <code>x</code> and return an equivalent expression with all macros removed (expanded) for executing in module <code>m</code>. The <code>recursive</code> keyword controls whether deeper levels of nested macros are also expanded. This is demonstrated in the example below:</p><pre><code class="language-julia-repl hljs">julia&gt; module M
           macro m1()
               42
           end
           macro m2()
               :(@m1())
           end
       end
M

julia&gt; macroexpand(M, :(@m2()), recursive=true)
42

julia&gt; macroexpand(M, :(@m2()), recursive=false)
:(#= REPL[16]:6 =# M.@m1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L85-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map!-Tuple{Any, Base.ValueIterator}" href="#Base.map!-Tuple{Any, Base.ValueIterator}"><code>Base.map!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map!(f, values(dict::AbstractDict))</code></pre><p>Modifies <code>dict</code> by transforming each value from <code>val</code> to <code>f(val)</code>. Note that the type of <code>dict</code> cannot be changed: if <code>f(val)</code> is not an instance of the value type of <code>dict</code> then it will be converted to the value type if possible and otherwise raise an error.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p><code>map!(f, values(dict::AbstractDict))</code> requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2)
Dict{Symbol, Int64} with 2 entries:
  :a =&gt; 1
  :b =&gt; 2

julia&gt; map!(v -&gt; v-1, values(d))
ValueIterator for a Dict{Symbol, Int64} with 2 entries. Values:
  0
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L548-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map!-Union{Tuple{F}, Tuple{F, AbstractArray, Vararg{AbstractArray, N} where N}} where F" href="#Base.map!-Union{Tuple{F}, Tuple{F, AbstractArray, Vararg{AbstractArray, N} where N}} where F"><code>Base.map!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map!(function, destination, collection...)</code></pre><p>Like <a href="#Base.map-Tuple{Any, Any}"><code>map</code></a>, but stores the result in <code>destination</code> rather than a new collection. <code>destination</code> must be at least as large as the first collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = zeros(3);

julia&gt; map!(x -&gt; x * 2, a, [1, 2, 3]);

julia&gt; a
3-element Vector{Float64}:
 2.0
 4.0
 6.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L2357-L2375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map-Tuple{Any, Any}" href="#Base.map-Tuple{Any, Any}"><code>Base.map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map(f, c...) -&gt; collection</code></pre><p>Transform collection <code>c</code> by applying <code>f</code> to each element. For multiple collection arguments, apply <code>f</code> elementwise.</p><p>See also: <a href="#Base.mapslices-Tuple{Any, AbstractArray}"><code>mapslices</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; map(x -&gt; x * 2, [1, 2, 3])
3-element Vector{Int64}:
 2
 4
 6

julia&gt; map(+, [1, 2, 3], [10, 20, 30])
3-element Vector{Int64}:
 11
 22
 33</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L2300-L2322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapfoldl-Tuple{Any, Any, Any}" href="#Base.mapfoldl-Tuple{Any, Any, Any}"><code>Base.mapfoldl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapfoldl(f, op, itr; [init])</code></pre><p>Like <a href="#Base.mapreduce-Tuple{Any, Any, Any}"><code>mapreduce</code></a>, but with guaranteed left associativity, as in <a href="#Base.foldl-Tuple{Any, Any}"><code>foldl</code></a>. If provided, the keyword argument <code>init</code> will be used exactly once. In general, it will be necessary to provide <code>init</code> to work with empty collections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L153-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapfoldr-Tuple{Any, Any, Any}" href="#Base.mapfoldr-Tuple{Any, Any, Any}"><code>Base.mapfoldr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapfoldr(f, op, itr; [init])</code></pre><p>Like <a href="#Base.mapreduce-Tuple{Any, Any, Any}"><code>mapreduce</code></a>, but with guaranteed right associativity, as in <a href="#Base.foldr-Tuple{Any, Any}"><code>foldr</code></a>. If provided, the keyword argument <code>init</code> will be used exactly once. In general, it will be necessary to provide <code>init</code> to work with empty collections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L196-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapreduce-Tuple{Any, Any, Any}" href="#Base.mapreduce-Tuple{Any, Any, Any}"><code>Base.mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapreduce(f, op, itrs...; [init])</code></pre><p>Apply function <code>f</code> to each element(s) in <code>itrs</code>, and then reduce the result using the binary function <code>op</code>. If provided, <code>init</code> must be a neutral element for <code>op</code> that will be returned for empty collections. It is unspecified whether <code>init</code> is used for non-empty collections. In general, it will be necessary to provide <code>init</code> to work with empty collections.</p><p><a href="#Base.mapreduce-Tuple{Any, Any, Any}"><code>mapreduce</code></a> is functionally equivalent to calling <code>reduce(op, map(f, itr); init=init)</code>, but will in general execute faster since no intermediate collection needs to be created. See documentation for <a href="#Base.reduce-Tuple{Any, AbstractArray}"><code>reduce</code></a> and <a href="#Base.map-Tuple{Any, Any}"><code>map</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p><code>mapreduce</code> with multiple iterators requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mapreduce(x-&gt;x^2, +, [1:3;]) # == 1 + 4 + 9
14</code></pre><p>The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of <code>f</code> for elements that appear multiple times in <code>itr</code>. Use <a href="#Base.mapfoldl-Tuple{Any, Any, Any}"><code>mapfoldl</code></a> or <a href="#Base.mapfoldr-Tuple{Any, Any, Any}"><code>mapfoldr</code></a> instead for guaranteed left or right associativity and invocation of <code>f</code> for every value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L260-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapreduce-Tuple{Any, Any, Union{Base.AbstractBroadcasted, AbstractArray}}" href="#Base.mapreduce-Tuple{Any, Any, Union{Base.AbstractBroadcasted, AbstractArray}}"><code>Base.mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapreduce(f, op, A::AbstractArray...; dims=:, [init])</code></pre><p>Evaluates to the same as <code>reduce(op, map(f, A); dims=dims, init=init)</code>, but is generally faster because the intermediate array is avoided.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p><code>mapreduce</code> with multiple iterators requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = reshape(Vector(1:16), (4,4))
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; mapreduce(isodd, *, a, dims=1)
1×4 Matrix{Bool}:
 0  0  0  0

julia&gt; mapreduce(isodd, |, a, dims=1)
1×4 Matrix{Bool}:
 1  1  1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L283-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapreduce_empty-Tuple{Any, Any, Any}" href="#Base.mapreduce_empty-Tuple{Any, Any, Any}"><code>Base.mapreduce_empty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.mapreduce_empty(f, op, T)</code></pre><p>The value to be returned when calling <a href="#Base.mapreduce-Tuple{Any, Any, Any}"><code>mapreduce</code></a>, <a href="@ref`"><code>mapfoldl</code></a> or <a href="#Base.mapfoldr-Tuple{Any, Any, Any}"><code>mapfoldr</code></a> with map <code>f</code> and reduction <code>op</code> over an empty array with element type of <code>T</code>.</p><p>If not defined, this will throw an <code>ArgumentError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L333-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapreduce_first-Tuple{Any, Any, Any}" href="#Base.mapreduce_first-Tuple{Any, Any, Any}"><code>Base.mapreduce_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.mapreduce_first(f, op, x)</code></pre><p>The value to be returned when calling <a href="#Base.mapreduce-Tuple{Any, Any, Any}"><code>mapreduce</code></a>, <a href="@ref`"><code>mapfoldl</code></a> or <a href="#Base.mapfoldr-Tuple{Any, Any, Any}"><code>mapfoldr</code></a> with map <code>f</code> and reduction <code>op</code> over an iterator which contains a single element <code>x</code>. This value may also used to initialise the recursion, so that <code>mapreduce(f, op, [x, y])</code> may call <code>op(reduce_first(op, f, x), f(y))</code>.</p><p>The default is <code>reduce_first(op, f(x))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L382-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapslices-Tuple{Any, AbstractArray}" href="#Base.mapslices-Tuple{Any, AbstractArray}"><code>Base.mapslices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mapslices(f, A; dims)</code></pre><p>Transform the given dimensions of array <code>A</code> using function <code>f</code>. <code>f</code> is called on each slice of <code>A</code> of the form <code>A[...,:,...,:,...]</code>. <code>dims</code> is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if <code>dims</code> is <code>[1,2]</code> and <code>A</code> is 4-dimensional, <code>f</code> is called on <code>A[:,:,i,j]</code> for all <code>i</code> and <code>j</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = reshape(Vector(1:16),(2,2,2,2))
2×2×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 1  3
 2  4

[:, :, 2, 1] =
 5  7
 6  8

[:, :, 1, 2] =
  9  11
 10  12

[:, :, 2, 2] =
 13  15
 14  16

julia&gt; mapslices(sum, a, dims = [1,2])
1×1×2×2 Array{Int64, 4}:
[:, :, 1, 1] =
 10

[:, :, 2, 1] =
 26

[:, :, 1, 2] =
 42

[:, :, 2, 2] =
 58</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L2149-L2192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mark-Tuple{IO}" href="#Base.mark-Tuple{IO}"><code>Base.mark</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mark(s)</code></pre><p>Add a mark at the current position of stream <code>s</code>. Return the marked position.</p><p>See also <a href="#Base.unmark-Tuple{IO}"><code>unmark</code></a>, <a href="#Base.reset-Tuple{T} where T&lt;:IO"><code>reset</code></a>, <a href="#Base.ismarked-Tuple{IO}"><code>ismarked</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L1061-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.match" href="#Base.match"><code>Base.match</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])</code></pre><p>Search for the first match of the regular expression <code>r</code> in <code>s</code> and return a <code>RegexMatch</code> object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing <code>m.match</code> and the captured sequences can be retrieved by accessing <code>m.captures</code> The optional <code>idx</code> argument specifies an index at which to start the search.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rx = r&quot;a(.)a&quot;
r&quot;a(.)a&quot;

julia&gt; m = match(rx, &quot;cabac&quot;)
RegexMatch(&quot;aba&quot;, 1=&quot;b&quot;)

julia&gt; m.captures
1-element Vector{Union{Nothing, SubString{String}}}:
 &quot;b&quot;

julia&gt; m.match
&quot;aba&quot;

julia&gt; match(rx, &quot;cabac&quot;, 3) === nothing
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L266-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.max-Tuple{Any, Any}" href="#Base.max-Tuple{Any, Any}"><code>Base.max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max(x, y, ...)</code></pre><p>Return the maximum of the arguments. See also the <a href="#Base.maximum-Tuple{AbstractArray}"><code>maximum</code></a> function to take the maximum element from a collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; max(2, 5, 1)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L407-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maximum!-Tuple{Any, Any}" href="#Base.maximum!-Tuple{Any, Any}"><code>Base.maximum!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximum!(r, A)</code></pre><p>Compute the maximum value of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; maximum!([1; 1], A)
2-element Vector{Int64}:
 2
 4

julia&gt; maximum!([1 1], A)
1×2 Matrix{Int64}:
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L625-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maximum-Tuple{AbstractArray}" href="#Base.maximum-Tuple{AbstractArray}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximum(A::AbstractArray; dims)</code></pre><p>Compute the maximum value of an array over the given dimensions. See also the <a href="#Base.max-Tuple{Any, Any}"><code>max(a,b)</code></a> function to take the maximum of two or more arguments, which can be applied elementwise to arrays via <code>max.(a,b)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; maximum(A, dims=1)
1×2 Matrix{Int64}:
 3  4

julia&gt; maximum(A, dims=2)
2×1 Matrix{Int64}:
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L574-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maximum-Tuple{Any, AbstractArray}" href="#Base.maximum-Tuple{Any, AbstractArray}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximum(f, A::AbstractArray; dims)</code></pre><p>Compute the maximum value from of calling the function <code>f</code> on each element of an array over the given dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; maximum(abs2, A, dims=1)
1×2 Matrix{Int64}:
 9  16

julia&gt; maximum(abs2, A, dims=2)
2×1 Matrix{Int64}:
  4
 16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L600-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maximum-Tuple{Any, Any}" href="#Base.maximum-Tuple{Any, Any}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximum(f, itr; [init])</code></pre><p>Returns the largest result of calling function <code>f</code> on each element of <code>itr</code>.</p><p>The value returned for empty <code>itr</code> can be specified by <code>init</code>. It must be a neutral element for <code>max</code> (i.e. which is less than or equal to any other element) as it is unspecified whether <code>init</code> is used for non-empty collections.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Keyword argument <code>init</code> requires Julia 1.6 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; maximum(length, [&quot;Julion&quot;, &quot;Julia&quot;, &quot;Jule&quot;])
6

julia&gt; maximum(length, []; init=-1)
-1

julia&gt; maximum(sin, Real[]; init=-1.0)  # good, since output of sin is &gt;= -1
-1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L647-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maximum-Tuple{Any}" href="#Base.maximum-Tuple{Any}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maximum(itr; [init])</code></pre><p>Returns the largest element in a collection.</p><p>The value returned for empty <code>itr</code> can be specified by <code>init</code>. It must be a neutral element for <code>max</code> (i.e. which is less than or equal to any other element) as it is unspecified whether <code>init</code> is used for non-empty collections.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Keyword argument <code>init</code> requires Julia 1.6 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; maximum(-20.5:10)
9.5

julia&gt; maximum([1,2,3])
3

julia&gt; maximum(())
ERROR: ArgumentError: reducing over an empty collection is not allowed
Stacktrace:
[...]

julia&gt; maximum((); init=-Inf)
-Inf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L701-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maxintfloat-Tuple{Type{Float64}}" href="#Base.maxintfloat-Tuple{Type{Float64}}"><code>Base.maxintfloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxintfloat(T=Float64)</code></pre><p>The largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type <code>T</code> (which defaults to <code>Float64</code>).</p><p>That is, <code>maxintfloat</code> returns the smallest positive integer-valued floating-point number <code>n</code> such that <code>n+1</code> is <em>not</em> exactly representable in the type <code>T</code>.</p><p>When an <code>Integer</code>-type value is needed, use <code>Integer(maxintfloat(T))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/floatfuncs.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maxintfloat-Union{Tuple{T}, Tuple{S}, Tuple{Type{S}, Type{T}}} where {S&lt;:AbstractFloat, T&lt;:Integer}" href="#Base.maxintfloat-Union{Tuple{T}, Tuple{S}, Tuple{Type{S}, Type{T}}} where {S&lt;:AbstractFloat, T&lt;:Integer}"><code>Base.maxintfloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxintfloat(T, S)</code></pre><p>The largest consecutive integer representable in the given floating-point type <code>T</code> that also does not exceed the maximum integer representable by the integer type <code>S</code>.  Equivalently, it is the minimum of <code>maxintfloat(T)</code> and <a href="#Base.typemax"><code>typemax(S)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/floatfuncs.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.may_invoke_generator-Tuple{Core.MethodInstance}" href="#Base.may_invoke_generator-Tuple{Core.MethodInstance}"><code>Base.may_invoke_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">may_invoke_generator(method, atypes, sparams)</code></pre><p>Computes whether or not we may invoke the generator for the given <code>method</code> on the given atypes and sparams. For correctness, all generated function are required to return monotonic answers. However, since we don&#39;t expect users to be able to successfully implement this criterion, we only call generated functions on concrete types. The one exception to this is that we allow calling generators with abstract types if the generator does not use said abstract type (and thus cannot incorrectly use it to break monotonicity). This function computes whether we are in either of these cases.</p><p>Unlike normal functions, the compilation heuristics still can&#39;t generate good dispatch in some cases, but this may still allow inference not to fall over in some limited cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1039-L1053">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{AbstractDict, Vararg{AbstractDict, N} where N}" href="#Base.merge!-Tuple{AbstractDict, Vararg{AbstractDict, N} where N}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge!(d::AbstractDict, others::AbstractDict...)</code></pre><p>Update collection with pairs from the other collections. See also <a href="#Base.merge-Tuple{AbstractDict, Vararg{AbstractDict, N} where N}"><code>merge</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d1 = Dict(1 =&gt; 2, 3 =&gt; 4);

julia&gt; d2 = Dict(1 =&gt; 4, 4 =&gt; 5);

julia&gt; merge!(d1, d2);

julia&gt; d1
Dict{Int64, Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 4
  1 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L160-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge-Tuple{AbstractDict, Vararg{AbstractDict, N} where N}" href="#Base.merge-Tuple{AbstractDict, Vararg{AbstractDict, N} where N}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge(d::AbstractDict, others::AbstractDict...)</code></pre><p>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed. See also <a href="#Base.mergewith-Tuple{Any, AbstractDict, Vararg{AbstractDict, N} where N}"><code>mergewith</code></a> for custom handling of values with the same key.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Dict(&quot;foo&quot; =&gt; 0.0, &quot;bar&quot; =&gt; 42.0)
Dict{String, Float64} with 2 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; b = Dict(&quot;baz&quot; =&gt; 17, &quot;bar&quot; =&gt; 4711)
Dict{String, Int64} with 2 entries:
  &quot;bar&quot; =&gt; 4711
  &quot;baz&quot; =&gt; 17

julia&gt; merge(a, b)
Dict{String, Float64} with 3 entries:
  &quot;bar&quot; =&gt; 4711.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; merge(b, a)
Dict{String, Float64} with 3 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L277-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge-Tuple{NamedTuple, Any}" href="#Base.merge-Tuple{NamedTuple, Any}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge(a::NamedTuple, iterable)</code></pre><p>Interpret an iterable of key-value pairs as a named tuple, and perform a merge.</p><pre><code class="language-julia-repl hljs">julia&gt; merge((a=1, b=2, c=3), [:b=&gt;4, :d=&gt;5])
(a = 1, b = 4, c = 3, d = 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/namedtuple.jl#L267-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge-Union{Tuple{bn}, Tuple{an}, Tuple{NamedTuple{an, T} where T&lt;:Tuple, NamedTuple{bn, T} where T&lt;:Tuple}} where {an, bn}" href="#Base.merge-Union{Tuple{bn}, Tuple{an}, Tuple{NamedTuple{an, T} where T&lt;:Tuple, NamedTuple{bn, T} where T&lt;:Tuple}} where {an, bn}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge(a::NamedTuple, bs::NamedTuple...)</code></pre><p>Construct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields present in both the leftmost and rightmost named tuples take the same position as they are found in the leftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that contains that field. Fields present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented for when only a single named tuple is supplied, with signature <code>merge(a::NamedTuple)</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Merging 3 or more <code>NamedTuple</code> requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; merge((a=1, b=2, c=3), (b=4, d=5))
(a = 1, b = 4, c = 3, d = 5)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; merge((a=1, b=2), (b=3, c=(d=1,)), (c=(d=2,),))
(a = 1, b = 3, c = (d = 2,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/namedtuple.jl#L217-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mergewith!-Tuple{Any, AbstractDict, Vararg{AbstractDict, N} where N}" href="#Base.mergewith!-Tuple{Any, AbstractDict, Vararg{AbstractDict, N} where N}"><code>Base.mergewith!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mergewith!(combine, d::AbstractDict, others::AbstractDict...) -&gt; d
mergewith!(combine)
merge!(combine, d::AbstractDict, others::AbstractDict...) -&gt; d</code></pre><p>Update collection with pairs from the other collections. Values with the same key will be combined using the combiner function.  The curried form <code>mergewith!(combine)</code> returns the function <code>(args...) -&gt; mergewith!(combine, args...)</code>.</p><p>Method <code>merge!(combine::Union{Function,Type}, args...)</code> as an alias of <code>mergewith!(combine, args...)</code> is still available for backward compatibility.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>mergewith!</code> requires Julia 1.5 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d1 = Dict(1 =&gt; 2, 3 =&gt; 4);

julia&gt; d2 = Dict(1 =&gt; 4, 4 =&gt; 5);

julia&gt; mergewith!(+, d1, d2);

julia&gt; d1
Dict{Int64, Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 4
  1 =&gt; 6

julia&gt; mergewith!(-, d1, d1);

julia&gt; d1
Dict{Int64, Int64} with 3 entries:
  4 =&gt; 0
  3 =&gt; 0
  1 =&gt; 0

julia&gt; foldl(mergewith!(+), [d1, d2]; init=Dict{Int64, Int64}())
Dict{Int64, Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 0
  1 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L190-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mergewith-Tuple{Any, AbstractDict, Vararg{AbstractDict, N} where N}" href="#Base.mergewith-Tuple{Any, AbstractDict, Vararg{AbstractDict, N} where N}"><code>Base.mergewith</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mergewith(combine, d::AbstractDict, others::AbstractDict...)
mergewith(combine)
merge(combine, d::AbstractDict, others::AbstractDict...)</code></pre><p>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.  The curried form <code>mergewith(combine)</code> returns the function <code>(args...) -&gt; mergewith(combine, args...)</code>.</p><p>Method <code>merge(combine::Union{Function,Type}, args...)</code> as an alias of <code>mergewith(combine, args...)</code> is still available for backward compatibility.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p><code>mergewith</code> requires Julia 1.5 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Dict(&quot;foo&quot; =&gt; 0.0, &quot;bar&quot; =&gt; 42.0)
Dict{String, Float64} with 2 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; b = Dict(&quot;baz&quot; =&gt; 17, &quot;bar&quot; =&gt; 4711)
Dict{String, Int64} with 2 entries:
  &quot;bar&quot; =&gt; 4711
  &quot;baz&quot; =&gt; 17

julia&gt; mergewith(+, a, b)
Dict{String, Float64} with 3 entries:
  &quot;bar&quot; =&gt; 4753.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; ans == mergewith(+)(a, b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L314-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.methods" href="#Base.methods"><code>Base.methods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">methods(f, [types], [module])</code></pre><p>Return the method table for <code>f</code>.</p><p>If <code>types</code> is specified, return an array of methods whose types match. If <code>module</code> is specified, return an array of methods defined in that module. A list of modules can also be specified as an array.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>At least Julia 1.4 is required for specifying a module.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L891-L902">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mightalias-Tuple{AbstractArray, AbstractArray}" href="#Base.mightalias-Tuple{AbstractArray, AbstractArray}"><code>Base.mightalias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.mightalias(A::AbstractArray, B::AbstractArray)</code></pre><p>Perform a conservative test to check if arrays <code>A</code> and <code>B</code> might share the same memory.</p><p>By default, this simply checks if either of the arrays reference the same memory regions, as identified by their <a href="#Base.dataids-Tuple{AbstractArray}"><code>Base.dataids</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1376-L1383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.min-Tuple{Any, Any}" href="#Base.min-Tuple{Any, Any}"><code>Base.min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">min(x, y, ...)</code></pre><p>Return the minimum of the arguments. See also the <a href="#Base.minimum-Tuple{AbstractArray}"><code>minimum</code></a> function to take the minimum element from a collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; min(2, 5, 1)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L421-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.minimum!-Tuple{Any, Any}" href="#Base.minimum!-Tuple{Any, Any}"><code>Base.minimum!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum!(r, A)</code></pre><p>Compute the minimum value of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; minimum!([1; 1], A)
2-element Vector{Int64}:
 1
 3

julia&gt; minimum!([1 1], A)
1×2 Matrix{Int64}:
 1  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L700-L721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.minimum-Tuple{AbstractArray}" href="#Base.minimum-Tuple{AbstractArray}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum(A::AbstractArray; dims)</code></pre><p>Compute the minimum value of an array over the given dimensions. See also the <a href="#Base.min-Tuple{Any, Any}"><code>min(a,b)</code></a> function to take the minimum of two or more arguments, which can be applied elementwise to arrays via <code>min.(a,b)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; minimum(A, dims=1)
1×2 Matrix{Int64}:
 1  2

julia&gt; minimum(A, dims=2)
2×1 Matrix{Int64}:
 1
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L649-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.minimum-Tuple{Any, AbstractArray}" href="#Base.minimum-Tuple{Any, AbstractArray}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum(f, A::AbstractArray; dims)</code></pre><p>Compute the minimum value from of calling the function <code>f</code> on each element of an array over the given dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; minimum(abs2, A, dims=1)
1×2 Matrix{Int64}:
 1  4

julia&gt; minimum(abs2, A, dims=2)
2×1 Matrix{Int64}:
 1
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L675-L697">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.minimum-Tuple{Any, Any}" href="#Base.minimum-Tuple{Any, Any}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum(f, itr; [init])</code></pre><p>Returns the smallest result of calling function <code>f</code> on each element of <code>itr</code>.</p><p>The value returned for empty <code>itr</code> can be specified by <code>init</code>. It must be a neutral element for <code>min</code> (i.e. which is greater than or equal to any other element) as it is unspecified whether <code>init</code> is used for non-empty collections.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Keyword argument <code>init</code> requires Julia 1.6 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; minimum(length, [&quot;Julion&quot;, &quot;Julia&quot;, &quot;Jule&quot;])
4

julia&gt; minimum(length, []; init=typemax(Int64))
9223372036854775807

julia&gt; minimum(sin, Real[]; init=1.0)  # good, since output of sin is &lt;= 1
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L674-L698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.minimum-Tuple{Any}" href="#Base.minimum-Tuple{Any}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum(itr; [init])</code></pre><p>Returns the smallest element in a collection.</p><p>The value returned for empty <code>itr</code> can be specified by <code>init</code>. It must be a neutral element for <code>min</code> (i.e. which is greater than or equal to any other element) as it is unspecified whether <code>init</code> is used for non-empty collections.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Keyword argument <code>init</code> requires Julia 1.6 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; minimum(-20.5:10)
-20.5

julia&gt; minimum([1,2,3])
1

julia&gt; minimum([])
ERROR: ArgumentError: reducing over an empty collection is not allowed
Stacktrace:
[...]

julia&gt; minimum([]; init=Inf)
Inf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L733-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.minmax-Tuple{Any, Any}" href="#Base.minmax-Tuple{Any, Any}"><code>Base.minmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minmax(x, y)</code></pre><p>Return <code>(min(x,y), max(x,y))</code>. See also: <a href="#Base.extrema-Tuple{AbstractArray}"><code>extrema</code></a> that returns <code>(minimum(x), maximum(x))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; minmax(&#39;c&#39;,&#39;b&#39;)
(&#39;b&#39;, &#39;c&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L435-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mod-Tuple{Integer, Base.OneTo}" href="#Base.mod-Tuple{Integer, Base.OneTo}"><code>Base.mod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mod(x::Integer, r::AbstractUnitRange)</code></pre><p>Find <code>y</code> in the range <code>r</code> such that <span>$x ≡ y (mod n)$</span>, where <code>n = length(r)</code>, i.e. <code>y = mod(x - first(r), n) + first(r)</code>.</p><p>See also: <a href="#Base.mod1-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>mod1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mod(0, Base.OneTo(3))
3

julia&gt; mod(3, 0:2)
0</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L1137-L1156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mod-Tuple{Integer, Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Integer}" href="#Base.mod-Tuple{Integer, Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Integer}"><code>Base.mod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem(x::Integer, T::Type{&lt;:Integer}) -&gt; T
mod(x::Integer, T::Type{&lt;:Integer}) -&gt; T
%(x::Integer, T::Type{&lt;:Integer}) -&gt; T</code></pre><p>Find <code>y::T</code> such that <code>x</code> ≡ <code>y</code> (mod n), where n is the number of integers representable in <code>T</code>, and <code>y</code> is an integer in <code>[typemin(T),typemax(T)]</code>. If <code>T</code> can represent any integer (e.g. <code>T == BigInt</code>), then this operation corresponds to a conversion to <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 129 % Int8
-127</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L521-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mod-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer" href="#Base.mod-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Integer"><code>Base.mod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mod(x, y)
rem(x, y, RoundDown)</code></pre><p>The reduction of <code>x</code> modulo <code>y</code>, or equivalently, the remainder of <code>x</code> after floored division by <code>y</code>, i.e. <code>x - y*fld(x,y)</code> if computed without intermediate rounding.</p><p>The result will have the same sign as <code>y</code>, and magnitude less than <code>abs(y)</code> (with some exceptions, see note below).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to <code>y</code>, then it may be rounded to <code>y</code>.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; mod(8, 3)
2

julia&gt; mod(9, 3)
0

julia&gt; mod(8.9, 3)
2.9000000000000004

julia&gt; mod(eps(), 3)
2.220446049250313e-16

julia&gt; mod(-eps(), 3)
3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L218-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mod1-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real" href="#Base.mod1-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>Base.mod1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mod1(x, y)</code></pre><p>Modulus after flooring division, returning a value <code>r</code> such that <code>mod(r, y) == mod(x, y)</code> in the range <span>$(0, y]$</span> for positive <code>y</code> and in the range <span>$[y,0)$</span> for negative <code>y</code>.</p><p>See also: <a href="#Base.fld1-Union{Tuple{T}, Tuple{T, T}} where T&lt;:Real"><code>fld1</code></a>, <a href="#Base.fldmod1-Tuple{Any, Any}"><code>fldmod1</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mod1(4, 2)
2

julia&gt; mod1(4, 3)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L764-L780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.moduleroot-Tuple{Module}" href="#Base.moduleroot-Tuple{Module}"><code>Base.moduleroot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">moduleroot(m::Module) -&gt; Module</code></pre><p>Find the root module of a given module. This is the first module in the chain of parent modules of <code>m</code> which is either a registered root module or which is its own parent module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L34-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mul12-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractFloat" href="#Base.mul12-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractFloat"><code>Base.mul12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zhi, zlo = mul12(x, y)</code></pre><p>A high-precision representation of <code>x * y</code> for floating-point numbers. Mathematically, <code>zhi + zlo = x * y</code>, where <code>zhi</code> contains the most significant bits and <code>zlo</code> the least significant.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; x = Float32(π)
3.1415927f0

julia&gt; x * x
9.869605f0

julia&gt; Float64(x) * Float64(x)
9.869604950382893

julia&gt; hi, lo = Base.mul12(x, x)
(9.869605f0, -1.140092f-7)

julia&gt; Float64(hi) + Float64(lo)
9.869604950382893</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/twiceprecision.jl#L89-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mul_prod-Tuple{Any, Any}" href="#Base.mul_prod-Tuple{Any, Any}"><code>Base.mul_prod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.mul_prod(x, y)</code></pre><p>The reduction operator used in <code>prod</code>. The main difference from <a href="#Base.:*-Tuple{Union{AbstractChar, AbstractString}, Vararg{Union{AbstractChar, AbstractString}, N} where N}"><code>*</code></a> is that small integers are promoted to <code>Int</code>/<code>UInt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nameof-Tuple{DataType}" href="#Base.nameof-Tuple{DataType}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nameof(t::DataType) -&gt; Symbol</code></pre><p>Get the name of a (potentially <code>UnionAll</code>-wrapped) <code>DataType</code> (without its parent module) as a symbol.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; module Foo
           struct S{T}
           end
       end
Foo

julia&gt; nameof(Foo.S{T} where T)
:S</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L196-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nameof-Tuple{Function}" href="#Base.nameof-Tuple{Function}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nameof(f::Function) -&gt; Symbol</code></pre><p>Get the name of a generic <code>Function</code> as a symbol. For anonymous functions, this is a compiler-generated name. For explicitly-declared subtypes of <code>Function</code>, it is the name of the function&#39;s type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1268-L1274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nameof-Tuple{Module}" href="#Base.nameof-Tuple{Module}"><code>Base.nameof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nameof(m::Module) -&gt; Symbol</code></pre><p>Get the name of a <code>Module</code> as a <a href="@ref"><code>Symbol</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nameof(Base.Broadcast)
:Broadcast</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.names-Tuple{Module}" href="#Base.names-Tuple{Module}"><code>Base.names</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">names(x::Module; all::Bool = false, imported::Bool = false)</code></pre><p>Get an array of the names exported by a <code>Module</code>, excluding deprecated names. If <code>all</code> is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If <code>imported</code> is true, then names explicitly imported from other modules are also included.</p><p>As a special case, all names defined in <code>Main</code> are considered &quot;exported&quot;, since it is not idiomatic to explicitly export names from <code>Main</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L86-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ncodeunits-Tuple{AbstractString}" href="#Base.ncodeunits-Tuple{AbstractString}"><code>Base.ncodeunits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ncodeunits(s::AbstractString) -&gt; Int</code></pre><p>Return the number of code units in a string. Indices that are in bounds to access this string must satisfy <code>1 ≤ i ≤ ncodeunits(s)</code>. Not all such indices are valid – they may not be the start of a character, but they will return a code unit value when calling <code>codeunit(s,i)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ncodeunits(&quot;The Julia Language&quot;)
18

julia&gt; ncodeunits(&quot;∫eˣ&quot;)
6

julia&gt; ncodeunits(&#39;∫&#39;), ncodeunits(&#39;e&#39;), ncodeunits(&#39;ˣ&#39;)
(3, 1, 2)</code></pre><p>See also: <a href="#Base.codeunit-Tuple{AbstractString, Integer}"><code>codeunit</code></a>, <a href="#Base.checkbounds-Tuple{AbstractArray, Vararg{Any, N} where N}"><code>checkbounds</code></a>, <a href="#Base.sizeof-Tuple{AbstractString}"><code>sizeof</code></a>, <a href="#Base.length"><code>length</code></a>, <a href="#Base.lastindex-Tuple{AbstractArray}"><code>lastindex</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L45-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ncodeunits-Tuple{Char}" href="#Base.ncodeunits-Tuple{Char}"><code>Base.ncodeunits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ncodeunits(c::Char) -&gt; Int</code></pre><p>Return the number of code units required to encode a character as UTF-8. This is the number of bytes which will be printed if the character is written to an output stream, or <code>ncodeunits(string(c))</code> but computed efficiently.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This method requires at least Julia 1.1. In Julia 1.0 consider using <code>ncodeunits(string(c))</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/char.jl#L53-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ndigits-Tuple{Integer}" href="#Base.ndigits-Tuple{Integer}"><code>Base.ndigits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ndigits(n::Integer; base::Integer=10, pad::Integer=1)</code></pre><p>Compute the number of digits in integer <code>n</code> written in base <code>base</code> (<code>base</code> must not be in <code>[-1, 0, 1]</code>), optionally padded with zeros to a specified size (the result will never be less than <code>pad</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ndigits(12345)
5

julia&gt; ndigits(1022, base=16)
3

julia&gt; string(1022, base=16)
&quot;3fe&quot;

julia&gt; ndigits(123, pad=5)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L609-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ndigits0z-Tuple{Integer, Integer}" href="#Base.ndigits0z-Tuple{Integer, Integer}"><code>Base.ndigits0z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ndigits0z(n::Integer, b::Integer=10)</code></pre><p>Return 0 if <code>n == 0</code>, otherwise compute the number of digits in integer <code>n</code> written in base <code>b</code> (i.e. equal to <code>ndigits(n, base=b)</code> in this case). The base <code>b</code> must not be in <code>[-1, 0, 1]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.ndigits0z(0, 16)
0

julia&gt; Base.ndigits(0, base=16)
1

julia&gt; Base.ndigits0z(0)
0

julia&gt; Base.ndigits0z(10, 2)
4

julia&gt; Base.ndigits0z(10)
2</code></pre><p>See also <a href="#Base.ndigits-Tuple{Integer}"><code>ndigits</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L571-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ndims-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#Base.ndims-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>Base.ndims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ndims(A::AbstractArray) -&gt; Integer</code></pre><p>Return the number of dimensions of <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (3,4,5));

julia&gt; ndims(A)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L199-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nextfloat-Tuple{AbstractFloat}" href="#Base.nextfloat-Tuple{AbstractFloat}"><code>Base.nextfloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextfloat(x::AbstractFloat)</code></pre><p>Return the smallest floating point number <code>y</code> of the same type as <code>x</code> such <code>x &lt; y</code>. If no such <code>y</code> exists (e.g. if <code>x</code> is <code>Inf</code> or <code>NaN</code>), then return <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L660-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nextfloat-Tuple{Union{Float16, Float32, Float64}, Integer}" href="#Base.nextfloat-Tuple{Union{Float16, Float32, Float64}, Integer}"><code>Base.nextfloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextfloat(x::AbstractFloat, n::Integer)</code></pre><p>The result of <code>n</code> iterative applications of <code>nextfloat</code> to <code>x</code> if <code>n &gt;= 0</code>, or <code>-n</code> applications of <code>prevfloat</code> if <code>n &lt; 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L616-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nextind-Tuple{AbstractString, Integer, Integer}" href="#Base.nextind-Tuple{AbstractString, Integer, Integer}"><code>Base.nextind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextind(str::AbstractString, i::Integer, n::Integer=1) -&gt; Int</code></pre><ul><li><p>Case <code>n == 1</code></p><p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding starts after index <code>i</code>. In other words, if <code>i</code> is the start of a character, return the start of the next character; if <code>i</code> is not the start of a character, move forward until the start of a character and return that index. If <code>i</code> is equal to <code>0</code> return <code>1</code>. If <code>i</code> is in bounds but greater or equal to <code>lastindex(str)</code> return <code>ncodeunits(str)+1</code>. Otherwise throw <code>BoundsError</code>.</p></li><li><p>Case <code>n &gt; 1</code></p><p>Behaves like applying <code>n</code> times <code>nextind</code> for <code>n==1</code>. The only difference is that if <code>n</code> is so large that applying <code>nextind</code> would reach <code>ncodeunits(str)+1</code> then each remaining iteration increases the returned value by <code>1</code>. This means that in this case <code>nextind</code> can return a value greater than <code>ncodeunits(str)+1</code>.</p></li><li><p>Case <code>n == 0</code></p><p>Return <code>i</code> only if <code>i</code> is a valid index in <code>s</code> or is equal to <code>0</code>. Otherwise <code>StringIndexError</code> or <code>BoundsError</code> is thrown.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nextind(&quot;α&quot;, 0)
1

julia&gt; nextind(&quot;α&quot;, 1)
3

julia&gt; nextind(&quot;α&quot;, 3)
ERROR: BoundsError: attempt to access 2-codeunit String at index [3]
[...]

julia&gt; nextind(&quot;α&quot;, 0, 2)
3

julia&gt; nextind(&quot;α&quot;, 1, 2)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L507-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nextpow-Tuple{Real, Real}" href="#Base.nextpow-Tuple{Real, Real}"><code>Base.nextpow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextpow(a, x)</code></pre><p>The smallest <code>a^n</code> not less than <code>x</code>, where <code>n</code> is a non-negative integer. <code>a</code> must be greater than 1, and <code>x</code> must be greater than 0.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nextpow(2, 7)
8

julia&gt; nextpow(2, 9)
16

julia&gt; nextpow(5, 20)
25

julia&gt; nextpow(4, 16)
16</code></pre><p>See also <a href="#Base.prevpow-Tuple{Real, Real}"><code>prevpow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L417-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nextprod-Tuple{Union{Tuple{Vararg{Integer, N} where N}, AbstractVector{var&quot;#s831&quot;} where var&quot;#s831&quot;&lt;:Integer}, Real}" href="#Base.nextprod-Tuple{Union{Tuple{Vararg{Integer, N} where N}, AbstractVector{var&quot;#s831&quot;} where var&quot;#s831&quot;&lt;:Integer}, Real}"><code>Base.nextprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextprod(factors::Union{Tuple,AbstractVector}, n)</code></pre><p>Next integer greater than or equal to <code>n</code> that can be written as <span>$\prod k_i^{p_i}$</span> for integers <span>$p_1$</span>, <span>$p_2$</span>, etcetera, for factors <span>$k_i$</span> in <code>factors</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nextprod((2, 3), 105)
108

julia&gt; 2^2 * 3^3
108</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>The method that accepts a tuple requires Julia 1.6 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/combinatorics.jl#L292-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nonmissingtype-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Base.nonmissingtype-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Base.nonmissingtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonmissingtype(T::Type)</code></pre><p>If <code>T</code> is a union of types containing <code>Missing</code>, return a new type with <code>Missing</code> removed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nonmissingtype(Union{Int64,Missing})
Int64

julia&gt; nonmissingtype(Any)
Any</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function is exported as of Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/missing.jl#L21-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.notify-Tuple{Base.GenericCondition, Any}" href="#Base.notify-Tuple{Base.GenericCondition, Any}"><code>Base.notify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">notify(condition, val=nothing; all=true, error=false)</code></pre><p>Wake up tasks waiting for a condition, passing them <code>val</code>. If <code>all</code> is <code>true</code> (the default), all waiting tasks are woken, otherwise only one is. If <code>error</code> is <code>true</code>, the passed value is raised as an exception in the woken tasks.</p><p>Return the count of tasks woken up. Return 0 if no tasks are waiting on <code>condition</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/condition.jl#L115-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.notnothing-Tuple{Any}" href="#Base.notnothing-Tuple{Any}"><code>Base.notnothing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">notnothing(x)</code></pre><p>Throw an error if <code>x === nothing</code>, and return <code>x</code> if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/some.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ntoh-Tuple{Any}" href="#Base.ntoh-Tuple{Any}"><code>Base.ntoh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ntoh(x)</code></pre><p>Convert the endianness of a value from Network byte order (big-endian) to that used by the Host.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L584-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ntuple-Union{Tuple{F}, Tuple{F, Integer}} where F" href="#Base.ntuple-Union{Tuple{F}, Tuple{F, Integer}} where F"><code>Base.ntuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ntuple(f::Function, n::Integer)</code></pre><p>Create a tuple of length <code>n</code>, computing each element as <code>f(i)</code>, where <code>i</code> is the index of the element.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ntuple(i -&gt; 2*i, 4)
(2, 4, 6, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ntuple.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ntuple-Union{Tuple{N}, Tuple{F}, Tuple{F, Val{N}}} where {F, N}" href="#Base.ntuple-Union{Tuple{N}, Tuple{F}, Tuple{F, Val{N}}} where {F, N}"><code>Base.ntuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ntuple(f, ::Val{N})</code></pre><p>Create a tuple of length <code>N</code>, computing each element as <code>f(i)</code>, where <code>i</code> is the index of the element. By taking a <code>Val(N)</code> argument, it is possible that this version of ntuple may generate more efficient code than the version taking the length as an integer. But <code>ntuple(f, N)</code> is preferable to <code>ntuple(f, Val(N))</code> in cases where <code>N</code> cannot be determined at compile time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ntuple(i -&gt; 2*i, Val(4))
(2, 4, 6, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/ntuple.jl#L52-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.numerator-Tuple{Integer}" href="#Base.numerator-Tuple{Integer}"><code>Base.numerator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">numerator(x)</code></pre><p>Numerator of the rational representation of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; numerator(2//3)
2

julia&gt; numerator(4)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/rational.jl#L220-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.objectid-Tuple{Any}" href="#Base.objectid-Tuple{Any}"><code>Base.objectid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objectid(x) -&gt; UInt</code></pre><p>Get a hash value for <code>x</code> based on object identity. <code>objectid(x)==objectid(y)</code> if <code>x === y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.occursin-Tuple{Any}" href="#Base.occursin-Tuple{Any}"><code>Base.occursin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">occursin(haystack)</code></pre><p>Create a function that checks whether its argument occurs in <code>haystack</code>, i.e. a function equivalent to <code>needle -&gt; occursin(needle, haystack)</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(occursin)}</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This method requires Julia 1.6 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L624-L634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.occursin-Tuple{Union{AbstractChar, AbstractString}, AbstractString}" href="#Base.occursin-Tuple{Union{AbstractChar, AbstractString}, AbstractString}"><code>Base.occursin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">occursin(needle::Union{AbstractString,AbstractPattern,AbstractChar}, haystack::AbstractString)</code></pre><p>Determine whether the first argument is a substring of the second. If <code>needle</code> is a regular expression, checks whether <code>haystack</code> contains a match.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; occursin(&quot;Julia&quot;, &quot;JuliaLang is pretty cool!&quot;)
true

julia&gt; occursin(&#39;a&#39;, &quot;JuliaLang is pretty cool!&quot;)
true

julia&gt; occursin(r&quot;a.a&quot;, &quot;aba&quot;)
true

julia&gt; occursin(r&quot;a.a&quot;, &quot;abba&quot;)
false</code></pre><p>See also: <a href="#Base.contains-Tuple{AbstractString, Any}"><code>contains</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/search.jl#L598-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.oftype-Tuple{Any, Any}" href="#Base.oftype-Tuple{Any, Any}"><code>Base.oftype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oftype(x, y)</code></pre><p>Convert <code>y</code> to the type of <code>x</code> (<code>convert(typeof(x), y)</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = 4;

julia&gt; y = 3.;

julia&gt; oftype(x, y)
3

julia&gt; oftype(y, x)
4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L357-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.one-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Number" href="#Base.one-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Number"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">one(x)
one(T::type)</code></pre><p>Return a multiplicative identity for <code>x</code>: a value such that <code>one(x)*x == x*one(x) == x</code>.  Alternatively <code>one(T)</code> can take a type <code>T</code>, in which case <code>one</code> returns a multiplicative identity for any <code>x</code> of type <code>T</code>.</p><p>If possible, <code>one(x)</code> returns a value of the same type as <code>x</code>, and <code>one(T)</code> returns a value of type <code>T</code>.  However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless.  In that case, <code>one(x)</code> should return an identity value of the same precision (and shape, for matrices) as <code>x</code>.</p><p>If you want a quantity that is of the same type as <code>x</code>, or of type <code>T</code>, even if <code>x</code> is dimensionful, use <a href="#Base.oneunit-Tuple{T} where T"><code>oneunit</code></a> instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; one(3.7)
1.0

julia&gt; one(Int)
1

julia&gt; import Dates; one(Dates.Day(1))
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L263-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ones" href="#Base.ones"><code>Base.ones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ones([T=Float64,] dims::Tuple)
ones([T=Float64,] dims...)</code></pre><p>Create an <code>Array</code>, with element type <code>T</code>, of all ones with size specified by <code>dims</code>. See also: <a href="#Base.fill"><code>fill</code></a>, <a href="#Base.zeros"><code>zeros</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ones(1,2)
1×2 Matrix{Float64}:
 1.0  1.0

julia&gt; ones(ComplexF64, 2, 3)
2×3 Matrix{ComplexF64}:
 1.0+0.0im  1.0+0.0im  1.0+0.0im
 1.0+0.0im  1.0+0.0im  1.0+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L475-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.oneunit-Tuple{T} where T" href="#Base.oneunit-Tuple{T} where T"><code>Base.oneunit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">oneunit(x::T)
oneunit(T::Type)</code></pre><p>Returns <code>T(one(x))</code>, where <code>T</code> is either the type of the argument or (if a type is passed) the argument.  This differs from <a href="#Base.one-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Number"><code>one</code></a> for dimensionful quantities: <code>one</code> is dimensionless (a multiplicative identity) while <code>oneunit</code> is dimensionful (of the same type as <code>x</code>, or of type <code>T</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; oneunit(3.7)
1.0

julia&gt; import Dates; oneunit(Dates.Day)
1 day</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L300-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.open" href="#Base.open"><code>Base.open</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">open(command, stdio=devnull; write::Bool = false, read::Bool = !write)</code></pre><p>Start running <code>command</code> asynchronously, and return a <code>process::IO</code> object.  If <code>read</code> is true, then reads from the process come from the process&#39;s standard output and <code>stdio</code> optionally specifies the process&#39;s standard input stream.  If <code>write</code> is true, then writes go to the process&#39;s standard input and <code>stdio</code> optionally specifies the process&#39;s standard output stream. The process&#39;s standard error stream is connected to the current global <code>stderr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L350-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.open" href="#Base.open"><code>Base.open</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">open(command, mode::AbstractString, stdio=devnull)</code></pre><p>Run <code>command</code> asynchronously. Like <code>open(command, stdio; read, write)</code> except specifying the read and write flags via a mode string instead of keyword arguments. Possible mode strings are:</p><table><tr><th style="text-align: left">Mode</th><th style="text-align: left">Description</th><th style="text-align: left">Keywords</th></tr><tr><td style="text-align: left"><code>r</code></td><td style="text-align: left">read</td><td style="text-align: left">none</td></tr><tr><td style="text-align: left"><code>w</code></td><td style="text-align: left">write</td><td style="text-align: left"><code>write = true</code></td></tr><tr><td style="text-align: left"><code>r+</code></td><td style="text-align: left">read, write</td><td style="text-align: left"><code>read = true, write = true</code></td></tr><tr><td style="text-align: left"><code>w+</code></td><td style="text-align: left">read, write</td><td style="text-align: left"><code>read = true, write = true</code></td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L323-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.open-Tuple{AbstractString, AbstractString}" href="#Base.open-Tuple{AbstractString, AbstractString}"><code>Base.open</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">open(filename::AbstractString, [mode::AbstractString]; lock = true) -&gt; IOStream</code></pre><p>Alternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of <code>mode</code> correspond to those from <code>fopen(3)</code> or Perl <code>open</code>, and are equivalent to setting the following boolean groups:</p><table><tr><th style="text-align: left">Mode</th><th style="text-align: left">Description</th><th style="text-align: left">Keywords</th></tr><tr><td style="text-align: left"><code>r</code></td><td style="text-align: left">read</td><td style="text-align: left">none</td></tr><tr><td style="text-align: left"><code>w</code></td><td style="text-align: left">write, create, truncate</td><td style="text-align: left"><code>write = true</code></td></tr><tr><td style="text-align: left"><code>a</code></td><td style="text-align: left">write, create, append</td><td style="text-align: left"><code>append = true</code></td></tr><tr><td style="text-align: left"><code>r+</code></td><td style="text-align: left">read, write</td><td style="text-align: left"><code>read = true, write = true</code></td></tr><tr><td style="text-align: left"><code>w+</code></td><td style="text-align: left">read, write, create, truncate</td><td style="text-align: left"><code>truncate = true, read = true</code></td></tr><tr><td style="text-align: left"><code>a+</code></td><td style="text-align: left">read, write, create, append</td><td style="text-align: left"><code>append = true, read = true</code></td></tr></table><p>The <code>lock</code> keyword argument controls whether operations will be locked for safe multi-threaded access.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = open(&quot;myfile.txt&quot;, &quot;w&quot;);

julia&gt; write(io, &quot;Hello world!&quot;);

julia&gt; close(io);

julia&gt; io = open(&quot;myfile.txt&quot;, &quot;r&quot;);

julia&gt; read(io, String)
&quot;Hello world!&quot;

julia&gt; write(io, &quot;This file is read only&quot;)
ERROR: ArgumentError: write failed, IOStream is not writeable
[...]

julia&gt; close(io)

julia&gt; io = open(&quot;myfile.txt&quot;, &quot;a&quot;);

julia&gt; write(io, &quot;This stream is not read only&quot;)
28

julia&gt; close(io)

julia&gt; rm(&quot;myfile.txt&quot;)</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The <code>lock</code> argument is available as of Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L303-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.open-Tuple{AbstractString}" href="#Base.open-Tuple{AbstractString}"><code>Base.open</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">open(filename::AbstractString; lock = true, keywords...) -&gt; IOStream</code></pre><p>Open a file in a mode specified by five boolean keyword arguments:</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr><tr><td style="text-align: left"><code>read</code></td><td style="text-align: left">open for reading</td><td style="text-align: left"><code>!write</code></td></tr><tr><td style="text-align: left"><code>write</code></td><td style="text-align: left">open for writing</td><td style="text-align: left"><code>truncate | append</code></td></tr><tr><td style="text-align: left"><code>create</code></td><td style="text-align: left">create if non-existent</td><td style="text-align: left"><code>!read &amp; write | truncate | append</code></td></tr><tr><td style="text-align: left"><code>truncate</code></td><td style="text-align: left">truncate to zero size</td><td style="text-align: left"><code>!read &amp; write</code></td></tr><tr><td style="text-align: left"><code>append</code></td><td style="text-align: left">seek to end</td><td style="text-align: left"><code>false</code></td></tr></table><p>The default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.</p><p>The <code>lock</code> keyword argument controls whether operations will be locked for safe multi-threaded access.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The <code>lock</code> argument is available as of Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L253-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.open-Tuple{Function, Base.AbstractCmd, Vararg{Any, N} where N}" href="#Base.open-Tuple{Function, Base.AbstractCmd, Vararg{Any, N} where N}"><code>Base.open</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">open(f::Function, command, args...; kwargs...)</code></pre><p>Similar to <code>open(command, args...; kwargs...)</code>, but calls <code>f(stream)</code> on the resulting process stream, then closes the input stream and waits for the process to complete. Returns the value returned by <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L383-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.open-Tuple{Function, Vararg{Any, N} where N}" href="#Base.open-Tuple{Function, Vararg{Any, N} where N}"><code>Base.open</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">open(f::Function, args...; kwargs....)</code></pre><p>Apply the function <code>f</code> to the result of <code>open(args...; kwargs...)</code> and close the resulting file descriptor upon completion.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; open(&quot;myfile.txt&quot;, &quot;w&quot;) do io
           write(io, &quot;Hello world!&quot;)
       end;

julia&gt; open(f-&gt;read(f, String), &quot;myfile.txt&quot;)
&quot;Hello world!&quot;

julia&gt; rm(&quot;myfile.txt&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L309-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.open-Tuple{RawFD}" href="#Base.open-Tuple{RawFD}"><code>Base.open</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">open(fd::OS_HANDLE) -&gt; IO</code></pre><p>Take a raw file descriptor wrap it in a Julia-aware IO type, and take ownership of the fd handle. Call <code>open(Libc.dup(fd))</code> to avoid the ownership capture of the original handle.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Do not call this on a handle that&#39;s already owned by some other part of the system.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L316-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.open_flags-Tuple{}" href="#Base.open_flags-Tuple{}"><code>Base.open_flags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">open_flags(; keywords...) -&gt; NamedTuple</code></pre><p>Compute the <code>read</code>, <code>write</code>, <code>create</code>, <code>truncate</code>, <code>append</code> flag value for a given set of keyword arguments to <a href="#Base.open"><code>open</code></a> a <a href="#Core.NamedTuple"><code>NamedTuple</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L271-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.operator_associativity-Tuple{Symbol}" href="#Base.operator_associativity-Tuple{Symbol}"><code>Base.operator_associativity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">operator_associativity(s::Symbol)</code></pre><p>Return a symbol representing the associativity of operator <code>s</code>. Left- and right-associative operators return <code>:left</code> and <code>:right</code>, respectively. Return <code>:none</code> if <code>s</code> is non-associative or an invalid operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)
(:left, :none, :right)

julia&gt; Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)
(:left, :none, :right)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L1331-L1346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.operator_precedence-Tuple{Symbol}" href="#Base.operator_precedence-Tuple{Symbol}"><code>Base.operator_precedence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">operator_precedence(s::Symbol)</code></pre><p>Return an integer representing the precedence of operator <code>s</code>, relative to other operators. Higher-numbered operators take precedence over lower-numbered operators. Return <code>0</code> if <code>s</code> is not a valid operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)
(11, 12, 17)

julia&gt; Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)
(0, 1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L1305-L1320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.padding-Tuple{Any}" href="#Base.padding-Tuple{Any}"><code>Base.padding</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Compute the location of padding in a type.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reinterpretarray.jl#L622-L624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pairs-Tuple{Any}" href="#Base.pairs-Tuple{Any}"><code>Base.pairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pairs(collection)</code></pre><p>Return an iterator over <code>key =&gt; value</code> pairs for any collection that maps a set of keys to a set of values. This includes arrays, where the keys are the array indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parent-Tuple{AbstractArray}" href="#Base.parent-Tuple{AbstractArray}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parent(A)</code></pre><p>Return the underlying &quot;parent array”. This parent array of objects of types <code>SubArray</code>, <code>ReshapedArray</code> or <code>LinearAlgebra.Transpose</code> is what was passed as an argument to <code>view</code>, <code>reshape</code>, <code>transpose</code>, etc. during object creation. If the input is not a wrapped object, return the input itself.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; V = view(A, 1:2, :)
2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:
 1  2
 3  4

julia&gt; parent(V)
2×2 Matrix{Int64}:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1306-L1330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parentindices-Tuple{AbstractArray}" href="#Base.parentindices-Tuple{AbstractArray}"><code>Base.parentindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parentindices(A)</code></pre><p>Return the indices in the <a href="#Base.parent-Tuple{AbstractArray}"><code>parent</code></a> which correspond to the array view <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4];

julia&gt; V = view(A, 1, :)
2-element view(::Matrix{Int64}, 1, :) with eltype Int64:
 1
 2

julia&gt; parentindices(V)
(1, Base.Slice(Base.OneTo(2)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/subarray.jl#L81-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parentmodule-Tuple{Any, Any}" href="#Base.parentmodule-Tuple{Any, Any}"><code>Base.parentmodule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parentmodule(f::Function, types) -&gt; Module</code></pre><p>Determine the module containing a given definition of a generic function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1298-L1302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parentmodule-Tuple{DataType}" href="#Base.parentmodule-Tuple{DataType}"><code>Base.parentmodule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parentmodule(t::DataType) -&gt; Module</code></pre><p>Determine the module containing the definition of a (potentially <code>UnionAll</code>-wrapped) <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; module Foo
           struct Int end
       end
Foo

julia&gt; parentmodule(Int)
Core

julia&gt; parentmodule(Foo.Int)
Foo</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L217-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parentmodule-Tuple{Function}" href="#Base.parentmodule-Tuple{Function}"><code>Base.parentmodule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parentmodule(f::Function) -&gt; Module</code></pre><p>Determine the module containing the (first) definition of a generic function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1290-L1295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parentmodule-Tuple{Module}" href="#Base.parentmodule-Tuple{Module}"><code>Base.parentmodule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parentmodule(m::Module) -&gt; Module</code></pre><p>Get a module&#39;s enclosing <code>Module</code>. <code>Main</code> is its own parent.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; parentmodule(Main)
Main

julia&gt; parentmodule(Base.Broadcast)
Base</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L18-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.parse-Tuple{Type, Any}" href="#Base.parse-Tuple{Type, Any}"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse(type, str; base)</code></pre><p>Parse a string as a number. For <code>Integer</code> types, a base can be specified (the default is 10). For floating-point types, the string is parsed as a decimal floating-point number.  <code>Complex</code> types are parsed from decimal strings of the form <code>&quot;R±Iim&quot;</code> as a <code>Complex(R,I)</code> of the requested type; <code>&quot;i&quot;</code> or <code>&quot;j&quot;</code> can also be used instead of <code>&quot;im&quot;</code>, and <code>&quot;R&quot;</code> or <code>&quot;Iim&quot;</code> are also permitted. If the string does not contain a valid number, an error is raised.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>parse(Bool, str)</code> requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; parse(Int, &quot;1234&quot;)
1234

julia&gt; parse(Int, &quot;1234&quot;, base = 5)
194

julia&gt; parse(Int, &quot;afc&quot;, base = 16)
2812

julia&gt; parse(Float64, &quot;1.2e-3&quot;)
0.0012

julia&gt; parse(Complex{Float64}, &quot;3.2e-1 + 4.5im&quot;)
0.32 + 4.5im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/parse.jl#L7-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pathof-Tuple{Module}" href="#Base.pathof-Tuple{Module}"><code>Base.pathof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pathof(m::Module)</code></pre><p>Return the path of the <code>m.jl</code> file that was used to <code>import</code> module <code>m</code>, or <code>nothing</code> if <code>m</code> was not imported from a package.</p><p>Use <a href="@ref"><code>dirname</code></a> to get the directory part and <a href="@ref"><code>basename</code></a> to get the file name part of the path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L301-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.peek" href="#Base.peek"><code>Base.peek</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">peek(stream[, T=UInt8])</code></pre><p>Read and return a value of type <code>T</code> from a stream without advancing the current position in the stream.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; b = IOBuffer(&quot;julia&quot;);

julia&gt; peek(b)
0x6a

julia&gt; position(b)
0

julia&gt; peek(b, Char)
&#39;j&#39;: ASCII/Unicode U+006A (category Ll: Letter, lowercase)</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The method which accepts a type requires Julia 1.5 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L819-L842">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.permute!-Tuple{Any, AbstractVector{T} where T}" href="#Base.permute!-Tuple{Any, AbstractVector{T} where T}"><code>Base.permute!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permute!(v, p)</code></pre><p>Permute vector <code>v</code> in-place, according to permutation <code>p</code>. No checking is done to verify that <code>p</code> is a permutation.</p><p>To return a new permutation, use <code>v[p]</code>. Note that this is generally faster than <code>permute!(v,p)</code> for large vectors.</p><p>See also <a href="#Base.invpermute!-Tuple{Any, AbstractVector{T} where T}"><code>invpermute!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 1, 3, 4];

julia&gt; perm = [2, 4, 3, 1];

julia&gt; permute!(A, perm);

julia&gt; A
4-element Vector{Int64}:
 1
 4
 3
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/combinatorics.jl#L149-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pipeline-Tuple{Any, Any, Any, Vararg{Any, N} where N}" href="#Base.pipeline-Tuple{Any, Any, Any, Vararg{Any, N} where N}"><code>Base.pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pipeline(from, to, ...)</code></pre><p>Create a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other <code>pipeline</code> calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example, <code>pipeline(a,b,c)</code> is equivalent to <code>pipeline(pipeline(a,b),c)</code>. This provides a more concise way to specify multi-stage pipelines.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">run(pipeline(`ls`, `grep xyz`))
run(pipeline(`ls`, &quot;out.txt&quot;))
run(pipeline(&quot;out.txt&quot;, `grep xyz`))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/cmd.jl#L334-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pipeline-Tuple{Base.AbstractCmd}" href="#Base.pipeline-Tuple{Base.AbstractCmd}"><code>Base.pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pipeline(command; stdin, stdout, stderr, append=false)</code></pre><p>Redirect I/O to or from the given <code>command</code>. Keyword arguments specify which of the command&#39;s streams should be redirected. <code>append</code> controls whether file output appends to the file. This is a more general version of the 2-argument <code>pipeline</code> function. <code>pipeline(from, to)</code> is equivalent to <code>pipeline(from, stdout=to)</code> when <code>from</code> is a command, and to <code>pipeline(to, stdin=from)</code> when <code>from</code> is another kind of data source.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">run(pipeline(`dothings`, stdout=&quot;out.txt&quot;, stderr=&quot;errs.txt&quot;))
run(pipeline(`update`, stdout=&quot;log.txt&quot;, append=true))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/cmd.jl#L299-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pkgdir-Tuple{Module}" href="#Base.pkgdir-Tuple{Module}"><code>Base.pkgdir</code></a> — <span class="docstring-category">Method</span></header><section><div><p>pkgdir(m::Module)</p><p>Return the root directory of the package that imported module <code>m</code>, or <code>nothing</code> if <code>m</code> was not imported from a package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L319-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pointer" href="#Base.pointer"><code>Base.pointer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pointer(array [, index])</code></pre><p>Get the native address of an array or string, optionally at a given location <code>index</code>.</p><p>This function is &quot;unsafe&quot;. Be careful to ensure that a Julia reference to <code>array</code> exists as long as this pointer will be used. The <a href="@ref"><code>GC.@preserve</code></a> macro should be used to protect the <code>array</code> argument from garbage collection within a given block of code.</p><p>Calling <a href="#Core.Ref"><code>Ref(array[, index])</code></a> is generally preferable to this function as it guarantees validity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L172-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pointer_from_objref-Tuple{Any}" href="#Base.pointer_from_objref-Tuple{Any}"><code>Base.pointer_from_objref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pointer_from_objref(x)</code></pre><p>Get the memory address of a Julia object as a <code>Ptr</code>. The existence of the resulting <code>Ptr</code> will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the <code>Ptr</code> will be used.</p><p>This function may not be called on immutable objects, since they do not have stable memory addresses.</p><p>See also: <a href="#Base.unsafe_pointer_to_objref-Tuple{Ptr}"><code>unsafe_pointer_to_objref</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/pointer.jl#L132-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pop!-Tuple{Any, Any, Any}" href="#Base.pop!-Tuple{Any, Any, Any}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pop!(collection, key[, default])</code></pre><p>Delete and return the mapping for <code>key</code> if it exists in <code>collection</code>, otherwise return <code>default</code>, or throw an error if <code>default</code> is not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; pop!(d, &quot;a&quot;)
1

julia&gt; pop!(d, &quot;d&quot;)
ERROR: KeyError: key &quot;d&quot; not found
Stacktrace:
[...]

julia&gt; pop!(d, &quot;e&quot;, 4)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/dict.jl#L588-L609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pop!-Tuple{Vector{T} where T}" href="#Base.pop!-Tuple{Vector{T} where T}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pop!(collection) -&gt; item</code></pre><p>Remove an item in <code>collection</code> and return it. If <code>collection</code> is an ordered container, the last item is returned; for unordered containers, an arbitrary element is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A=[1, 2, 3]
3-element Vector{Int64}:
 1
 2
 3

julia&gt; pop!(A)
3

julia&gt; A
2-element Vector{Int64}:
 1
 2

julia&gt; S = Set([1, 2])
Set{Int64} with 2 elements:
  2
  1

julia&gt; pop!(S)
2

julia&gt; S
Set{Int64} with 1 element:
  1

julia&gt; pop!(Dict(1=&gt;2))
1 =&gt; 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1139-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.popat!-Tuple{Vector{T} where T, Integer}" href="#Base.popat!-Tuple{Vector{T} where T, Integer}"><code>Base.popat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">popat!(a::Vector, i::Integer, [default])</code></pre><p>Remove the item at the given <code>i</code> and return it. Subsequent items are shifted to fill the resulting gap. When <code>i</code> is not a valid index for <code>a</code>, return <code>default</code>, or throw an error if <code>default</code> is not specified. See also <a href="#Base.deleteat!-Tuple{Vector{T} where T, Any}"><code>deleteat!</code></a> and <a href="#Base.splice!"><code>splice!</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function is available as of Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [4, 3, 2, 1]; popat!(a, 2)
3

julia&gt; a
3-element Vector{Int64}:
 4
 2
 1

julia&gt; popat!(a, 4, missing)
missing

julia&gt; popat!(a, 4)
ERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1187-L1217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.popfirst!-Tuple{Vector{T} where T}" href="#Base.popfirst!-Tuple{Vector{T} where T}"><code>Base.popfirst!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">popfirst!(collection) -&gt; item</code></pre><p>Remove the first <code>item</code> from <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1, 2, 3, 4, 5, 6]
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6

julia&gt; popfirst!(A)
1

julia&gt; A
5-element Vector{Int64}:
 2
 3
 4
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1258-L1285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.position-Tuple{IOStream}" href="#Base.position-Tuple{IOStream}"><code>Base.position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">position(s)</code></pre><p>Get the current position of a stream.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization.&quot;);

julia&gt; seek(io, 5);

julia&gt; position(io)
5

julia&gt; skip(io, 10);

julia&gt; position(io)
15

julia&gt; seekend(io);

julia&gt; position(io)
35</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L191-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.powermod-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T&lt;:Integer" href="#Base.powermod-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T&lt;:Integer"><code>Base.powermod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">powermod(x::Integer, p::Integer, m)</code></pre><p>Compute <span>$x^p \pmod m$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; powermod(2, 6, 5)
4

julia&gt; mod(2^6, 5)
4

julia&gt; powermod(5, 2, 20)
5

julia&gt; powermod(5, 2, 19)
6

julia&gt; powermod(5, 3, 19)
11</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L336-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.precision" href="#Base.precision"><code>Base.precision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">precision(num::AbstractFloat)</code></pre><p>Get the precision of a floating point number, as defined by the effective number of bits in the significand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L591-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.precompile-Tuple{Any, Tuple}" href="#Base.precompile-Tuple{Any, Tuple}"><code>Base.precompile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precompile(f, args::Tuple{Vararg{Any}})</code></pre><p>Compile the given function <code>f</code> for the argument tuple (of types) <code>args</code>, but do not execute it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L460-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prepend!(a::Vector, collections...) -&gt; collection</code></pre><p>Insert the elements of each <code>collections</code> to the beginning of <code>a</code>.</p><p>When <code>collections</code> specifies multiple collections, order is maintained: elements of <code>collections[1]</code> will appear leftmost in <code>a</code>, and so on.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Specifying multiple collections to be prepended requires at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prepend!([3], [1, 2])
3-element Vector{Int64}:
 1
 2
 3

julia&gt; prepend!([6], [1, 2], [3, 4, 5])
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1003-L1031">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prevfloat-Tuple{AbstractFloat, Integer}" href="#Base.prevfloat-Tuple{AbstractFloat, Integer}"><code>Base.prevfloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prevfloat(x::AbstractFloat, n::Integer)</code></pre><p>The result of <code>n</code> iterative applications of <code>prevfloat</code> to <code>x</code> if <code>n &gt;= 0</code>, or <code>-n</code> applications of <code>nextfloat</code> if <code>n &lt; 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L668-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prevfloat-Tuple{AbstractFloat}" href="#Base.prevfloat-Tuple{AbstractFloat}"><code>Base.prevfloat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prevfloat(x::AbstractFloat)</code></pre><p>Return the largest floating point number <code>y</code> of the same type as <code>x</code> such <code>y &lt; x</code>. If no such <code>y</code> exists (e.g. if <code>x</code> is <code>-Inf</code> or <code>NaN</code>), then return <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L676-L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prevind-Tuple{AbstractString, Integer, Integer}" href="#Base.prevind-Tuple{AbstractString, Integer, Integer}"><code>Base.prevind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prevind(str::AbstractString, i::Integer, n::Integer=1) -&gt; Int</code></pre><ul><li><p>Case <code>n == 1</code></p><p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding starts before index <code>i</code>. In other words, if <code>i</code> is the start of a character, return the start of the previous character; if <code>i</code> is not the start of a character, rewind until the start of a character and return that index. If <code>i</code> is equal to <code>1</code> return <code>0</code>. If <code>i</code> is equal to <code>ncodeunits(str)+1</code> return <code>lastindex(str)</code>. Otherwise throw <code>BoundsError</code>.</p></li><li><p>Case <code>n &gt; 1</code></p><p>Behaves like applying <code>n</code> times <code>prevind</code> for <code>n==1</code>. The only difference is that if <code>n</code> is so large that applying <code>prevind</code> would reach <code>0</code> then each remaining iteration decreases the returned value by <code>1</code>. This means that in this case <code>prevind</code> can return a negative value.</p></li><li><p>Case <code>n == 0</code></p><p>Return <code>i</code> only if <code>i</code> is a valid index in <code>str</code> or is equal to <code>ncodeunits(str)+1</code>. Otherwise <code>StringIndexError</code> or <code>BoundsError</code> is thrown.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prevind(&quot;α&quot;, 3)
1

julia&gt; prevind(&quot;α&quot;, 1)
0

julia&gt; prevind(&quot;α&quot;, 0)
ERROR: BoundsError: attempt to access 2-codeunit String at index [0]
[...]

julia&gt; prevind(&quot;α&quot;, 2, 2)
0

julia&gt; prevind(&quot;α&quot;, 2, 3)
-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L448-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prevpow-Tuple{Real, Real}" href="#Base.prevpow-Tuple{Real, Real}"><code>Base.prevpow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prevpow(a, x)</code></pre><p>The largest <code>a^n</code> not greater than <code>x</code>, where <code>n</code> is a non-negative integer. <code>a</code> must be greater than 1, and <code>x</code> must not be less than 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prevpow(2, 7)
4

julia&gt; prevpow(2, 9)
8

julia&gt; prevpow(5, 20)
5

julia&gt; prevpow(4, 16)
16</code></pre><p>See also <a href="#Base.nextpow-Tuple{Real, Real}"><code>nextpow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L454-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print-Tuple{IO, Any}" href="#Base.print-Tuple{IO, Any}"><code>Base.print</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print([io::IO], xs...)</code></pre><p>Write to <code>io</code> (or to the default output stream <a href="#Base.stdout"><code>stdout</code></a> if <code>io</code> is not given) a canonical (un-decorated) text representation. The representation used by <code>print</code> includes minimal formatting and tries to avoid Julia-specific details.</p><p><code>print</code> falls back to calling <code>show</code>, so most types should just define <code>show</code>. Define <code>print</code> if your type has a separate &quot;plain&quot; representation. For example, <code>show</code> displays strings with quotes, and <code>print</code> displays strings without quotes.</p><p><a href="#Base.string-Tuple"><code>string</code></a> returns the output of <code>print</code> as a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; print(&quot;Hello World!&quot;)
Hello World!
julia&gt; io = IOBuffer();

julia&gt; print(io, &quot;Hello&quot;, &#39; &#39;, :World!)

julia&gt; String(take!(io))
&quot;Hello World!&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L5-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print_matrix" href="#Base.print_matrix"><code>Base.print_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_matrix(io::IO, mat, pre, sep, post, hdots, vdots, ddots, hmod, vmod)</code></pre><p>Prints a matrix with limited output size. If <code>io</code> sets <code>:limit</code> to true, then only the corners of the matrix are printed, separated with vertical, horizontal, and diagonal ellipses as appropriate. Optional arguments are string pre (printed before the matrix, e.g. an opening bracket) which will cause a corresponding same-size indent on following rows, and string post (printed at the end of the last row of the matrix). Also options to use different ellipsis characters hdots, vdots, ddots. These are repeated every hmod or vmod elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arrayshow.jl#L149-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print_matrix_row-Tuple{IO, AbstractVecOrMat{T} where T, Vector{T} where T, Integer, AbstractVector{T} where T, AbstractString}" href="#Base.print_matrix_row-Tuple{IO, AbstractVecOrMat{T} where T, Vector{T} where T, Integer, AbstractVector{T} where T, AbstractString}"><code>Base.print_matrix_row</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>print_matrix_row(io, X, A, i, cols, sep)</code> produces the aligned output for a single matrix row X[i, cols] where the desired list of columns is given. The corresponding alignment A is used, and the separation between elements is specified as string sep. <code>print_matrix_row</code> will also respect compact output for elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arrayshow.jl#L89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print_matrix_vdots" href="#Base.print_matrix_vdots"><code>Base.print_matrix_vdots</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>print_matrix_vdots</code> is used to show a series of vertical ellipsis instead of a bunch of rows for long matrices. Not only is the string vdots shown but it also repeated every M elements if desired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arrayshow.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print_range" href="#Base.print_range"><code>Base.print_range</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>print_range(io, r)</code> prints out a nice looking range r in terms of its elements as if it were <code>collect(r)</code>, dependent on the size of the terminal, and taking into account whether compact numbers should be shown. It figures out the width in characters of each element, and if they end up too wide, it shows the first and last elements separated by a horizontal ellipsis. Typical output will look like <code>1.0,2.0,3.0,…,4.0,5.0,6.0</code>.</p><p><code>print_range(io, r, pre, sep, post, hdots)</code> uses optional parameters <code>pre</code> and <code>post</code> characters for each printed row, <code>sep</code> separator string between printed elements, <code>hdots</code> string for the horizontal ellipsis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L457-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print_statement_costs-Tuple{IO, Any, Any}" href="#Base.print_statement_costs-Tuple{IO, Any, Any}"><code>Base.print_statement_costs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_statement_costs(io::IO, f, types)</code></pre><p>Print type-inferred and optimized code for <code>f</code> given argument types <code>types</code>, prepending each line with its cost as estimated by the compiler&#39;s inlining engine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1186-L1191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.println-Tuple{IO, Vararg{Any, N} where N}" href="#Base.println-Tuple{IO, Vararg{Any, N} where N}"><code>Base.println</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">println([io::IO], xs...)</code></pre><p>Print (using <a href="#Base.print-Tuple{IO, Any}"><code>print</code></a>) <code>xs</code> followed by a newline. If <code>io</code> is not supplied, prints to <a href="#Base.stdout"><code>stdout</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(&quot;Hello, world&quot;)
Hello, world

julia&gt; io = IOBuffer();

julia&gt; println(io, &quot;Hello, world&quot;)

julia&gt; String(take!(io))
&quot;Hello, world\n&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L54-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.printstyled-Tuple{IO, Vararg{Any, N} where N}" href="#Base.printstyled-Tuple{IO, Vararg{Any, N} where N}"><code>Base.printstyled</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printstyled([io], xs...; bold::Bool=false, color::Union{Symbol,Int}=:normal)</code></pre><p>Print <code>xs</code> in a color specified as a symbol or integer, optionally in bold.</p><p><code>color</code> may take any of the values <code>:normal</code>, <code>:default</code>, <code>:bold</code>, <code>:black</code>, <code>:blink</code>, <code>:blue</code>, <code>:cyan</code>, <code>:green</code>, <code>:hidden</code>, <code>:light_black</code>, <code>:light_blue</code>, <code>:light_cyan</code>, <code>:light_green</code>, <code>:light_magenta</code>, <code>:light_red</code>, <code>:light_yellow</code>, <code>:magenta</code>, <code>:nothing</code>, <code>:red</code>, <code>:reverse</code>, <code>:underline</code>, <code>:white</code>, or  <code>:yellow</code> or an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors. If the keyword <code>bold</code> is given as <code>true</code>, the result will be printed in bold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/util.jl#L96-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.process_exited-Tuple{Base.Process}" href="#Base.process_exited-Tuple{Base.Process}"><code>Base.process_exited</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">process_exited(p::Process)</code></pre><p>Determine whether a process has exited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L595-L599">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.process_running-Tuple{Base.Process}" href="#Base.process_running-Tuple{Base.Process}"><code>Base.process_running</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">process_running(p::Process)</code></pre><p>Determine whether a process is currently running.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L586-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prod!-Tuple{Any, Any}" href="#Base.prod!-Tuple{Any, Any}"><code>Base.prod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prod!(r, A)</code></pre><p>Multiply elements of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; prod!([1; 1], A)
2-element Vector{Int64}:
  2
 12

julia&gt; prod!([1 1], A)
1×2 Matrix{Int64}:
 3  8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L550-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prod-Tuple{AbstractArray}" href="#Base.prod-Tuple{AbstractArray}"><code>Base.prod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prod(A::AbstractArray; dims)</code></pre><p>Multiply elements of an array over the given dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; prod(A, dims=1)
1×2 Matrix{Int64}:
 3  8

julia&gt; prod(A, dims=2)
2×1 Matrix{Int64}:
  2
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L501-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prod-Tuple{Any, AbstractArray}" href="#Base.prod-Tuple{Any, AbstractArray}"><code>Base.prod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prod(f, A::AbstractArray; dims)</code></pre><p>Multiply the results of calling the function <code>f</code> on each element of an array over the given dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; prod(abs2, A, dims=1)
1×2 Matrix{Int64}:
 9  64

julia&gt; prod(abs2, A, dims=2)
2×1 Matrix{Int64}:
   4
 144</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L525-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prod-Tuple{Any, Any}" href="#Base.prod-Tuple{Any, Any}"><code>Base.prod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prod(f, itr; [init])</code></pre><p>Returns the product of <code>f</code> applied to each element of <code>itr</code>.</p><p>The return type is <code>Int</code> for signed integers of less than system word size, and <code>UInt</code> for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.</p><p>The value returned for empty <code>itr</code> can be specified by <code>init</code>. It must be the multiplicative identity (i.e. one) as it is unspecified whether <code>init</code> is used for non-empty collections.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Keyword argument <code>init</code> requires Julia 1.6 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prod(abs2, [2; 3; 4])
576</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L533-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prod-Tuple{Any}" href="#Base.prod-Tuple{Any}"><code>Base.prod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prod(itr; [init])</code></pre><p>Returns the product of all elements of a collection.</p><p>The return type is <code>Int</code> for signed integers of less than system word size, and <code>UInt</code> for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.</p><p>The value returned for empty <code>itr</code> can be specified by <code>init</code>. It must be the multiplicative identity (i.e. one) as it is unspecified whether <code>init</code> is used for non-empty collections.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Keyword argument <code>init</code> requires Julia 1.6 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; prod(1:5)
120

julia&gt; prod(1:5; init = 1.0)
120.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L557-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote" href="#Base.promote"><code>Base.promote</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">promote(xs...)</code></pre><p>Convert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; promote(Int8(1), Float16(4.5), Float32(4.1))
(1.0f0, 4.5f0, 4.1f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/promotion.jl#L252-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote_op-Tuple{Any, Vararg{Type, N} where N}" href="#Base.promote_op-Tuple{Any, Vararg{Type, N} where N}"><code>Base.promote_op</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote_op(f, argtypes...)</code></pre><p>Guess what an appropriate container eltype would be for storing results of <code>f(::argtypes...)</code>. The guess is in part based on type inference, so can change any time.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Due to its fragility, use of <code>promote_op</code> should be avoided. It is preferable to base the container eltype on the type of the actual elements. Only in the absence of any elements (for an empty result container), it may be unavoidable to call <code>promote_op</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/promotion.jl#L380-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote_rule" href="#Base.promote_rule"><code>Base.promote_rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">promote_rule(type1, type2)</code></pre><p>Specifies what type should be used by <a href="#Base.promote"><code>promote</code></a> when given values of types <code>type1</code> and <code>type2</code>. This function should not be called directly, but should have definitions added to it for new types as appropriate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/promotion.jl#L236-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote_shape-Tuple{Tuple{Vararg{Int64, N}} where N, Tuple{Vararg{Int64, N}} where N}" href="#Base.promote_shape-Tuple{Tuple{Vararg{Int64, N}} where N, Tuple{Vararg{Int64, N}} where N}"><code>Base.promote_shape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote_shape(s1, s2)</code></pre><p>Check two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = fill(1, (3,4,1,1,1));

julia&gt; b = fill(1, (3,4));

julia&gt; promote_shape(a,b)
(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))

julia&gt; promote_shape((2,3,1,4), (2, 3, 1, 4, 1))
(2, 3, 1, 4, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L132-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote_type" href="#Base.promote_type"><code>Base.promote_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">promote_type(type1, type2)</code></pre><p>Promotion refers to converting values of mixed types to a single common type. <code>promote_type</code> represents the default promotion behavior in Julia when operators (usually mathematical) are given arguments of differing types. <code>promote_type</code> generally tries to return a type which can at least approximate most values of either input type without excessively widening.  Some loss is tolerated; for example, <code>promote_type(Int64, Float64)</code> returns <a href="@ref"><code>Float64</code></a> even though strictly, not all <a href="@ref"><code>Int64</code></a> values can be represented exactly as <code>Float64</code> values.</p><pre><code class="language-julia-repl hljs">julia&gt; promote_type(Int64, Float64)
Float64

julia&gt; promote_type(Int32, Int64)
Int64

julia&gt; promote_type(Float32, BigInt)
BigFloat

julia&gt; promote_type(Int16, Float16)
Float16

julia&gt; promote_type(Int64, Float16)
Float16

julia&gt; promote_type(Int8, UInt16)
UInt16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/promotion.jl#L183-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.promote_typejoin-Tuple{Any, Any}" href="#Base.promote_typejoin-Tuple{Any, Any}"><code>Base.promote_typejoin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote_typejoin(T, S)</code></pre><p>Compute a type that contains both <code>T</code> and <code>S</code>, which could be either a parent of both types, or a <code>Union</code> if appropriate. Falls back to <a href="#Base.typejoin-Tuple{}"><code>typejoin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/promotion.jl#L141-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prompt-Tuple{IO, IO, AbstractString}" href="#Base.prompt-Tuple{IO, IO, AbstractString}"><code>Base.prompt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prompt(message; default=&quot;&quot;) -&gt; Union{String, Nothing}</code></pre><p>Displays the <code>message</code> then waits for user input. Input is terminated when a newline (\n) is encountered or EOF (^D) character is entered on a blank line. If a <code>default</code> is provided then the user can enter just a newline character to select the <code>default</code>.</p><p>See also <code>Base.getpass</code> and <code>Base.winprompt</code> for secure entry of passwords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/util.jl#L260-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.propertynames-Tuple{Any}" href="#Base.propertynames-Tuple{Any}"><code>Base.propertynames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propertynames(x, private=false)</code></pre><p>Get a tuple or a vector of the properties (<code>x.property</code>) of an object <code>x</code>. This is typically the same as <a href="#Base.fieldnames-Tuple{DataType}"><code>fieldnames(typeof(x))</code></a>, but types that overload <a href="@ref"><code>getproperty</code></a> should generally overload <code>propertynames</code> as well to get the properties of an instance of the type.</p><p><code>propertynames(x)</code> may return only &quot;public&quot; property names that are part of the documented interface of <code>x</code>.   If you want it to also return &quot;private&quot; fieldnames intended for internal use, pass <code>true</code> for the optional second argument. REPL tab completion on <code>x.</code> shows only the <code>private=false</code> properties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1566-L1578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push!(collection, items...) -&gt; collection</code></pre><p>Insert one or more <code>items</code> in <code>collection</code>. If <code>collection</code> is an ordered container, the items are inserted at the end (in the given order).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; push!([1, 2, 3], 4, 5, 6)
6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre><p>If <code>collection</code> is ordered, use <a href="#Base.append!-Tuple{Vector{T} where T, AbstractVector{T} where T}"><code>append!</code></a> to add all the elements of another collection to it. The result of the preceding example is equivalent to <code>append!([1, 2, 3], [4, 5, 6])</code>. For <code>AbstractSet</code> objects, <a href="#Base.union!-Tuple{AbstractSet, Vararg{Any, N} where N}"><code>union!</code></a> can be used instead.</p><p>See <a href="#Base.sizehint!"><code>sizehint!</code></a> for notes about the performance model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L900-L923">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pushfirst!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T" href="#Base.pushfirst!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pushfirst!(collection, items...) -&gt; collection</code></pre><p>Insert one or more <code>items</code> at the beginning of <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pushfirst!([1, 2, 3, 4], 5, 6)
6-element Vector{Int64}:
 5
 6
 1
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1234-L1250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.put!-Union{Tuple{T}, Tuple{Channel{T}, Any}} where T" href="#Base.put!-Union{Tuple{T}, Tuple{Channel{T}, Any}} where T"><code>Base.put!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">put!(c::Channel, v)</code></pre><p>Append an item <code>v</code> to the channel <code>c</code>. Blocks if the channel is full.</p><p>For unbuffered channels, blocks until a <a href="#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a> is performed by a different task.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>v</code> now gets converted to the channel&#39;s type with <a href="#Base.convert"><code>convert</code></a> as <code>put!</code> is called.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/channels.jl#L302-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.range-Tuple{Any}" href="#Base.range-Tuple{Any}"><code>Base.range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">range(start[, stop]; length, stop, step=1)</code></pre><p>Given a starting value, construct a range either by length or from <code>start</code> to <code>stop</code>, optionally with a given step (defaults to 1, a <a href="#Base.UnitRange"><code>UnitRange</code></a>). One of <code>length</code> or <code>stop</code> is required.  If <code>length</code>, <code>stop</code>, and <code>step</code> are all specified, they must agree.</p><p>If <code>length</code> and <code>stop</code> are provided and <code>step</code> is not, the step size will be computed automatically such that there are <code>length</code> linearly spaced elements in the range.</p><p>If <code>step</code> and <code>stop</code> are provided and <code>length</code> is not, the overall range length will be computed automatically such that the elements are <code>step</code> spaced.</p><p>Special care is taken to ensure intermediate values are computed rationally. To avoid this induced overhead, see the <a href="#Base.LinRange"><code>LinRange</code></a> constructor.</p><p><code>stop</code> may be specified as either a positional or keyword argument.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>stop</code> as a positional argument requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; range(1, length=100)
1:100

julia&gt; range(1, stop=100)
1:100

julia&gt; range(1, step=5, length=100)
1:5:496

julia&gt; range(1, step=5, stop=100)
1:5:96

julia&gt; range(1, 10, length=101)
1.0:0.09:10.0

julia&gt; range(1, 100, step=5)
1:5:96</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L49-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rationalize-Union{Tuple{T}, Tuple{Type{T}, AbstractFloat, Real}} where T&lt;:Integer" href="#Base.rationalize-Union{Tuple{T}, Tuple{Type{T}, AbstractFloat, Real}} where T&lt;:Integer"><code>Base.rationalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rationalize([T&lt;:Integer=Int,] x; tol::Real=eps(x))</code></pre><p>Approximate floating point number <code>x</code> as a <a href="#Base.Rational"><code>Rational</code></a> number with components of the given integer type. The result will differ from <code>x</code> by no more than <code>tol</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rationalize(5.6)
28//5

julia&gt; a = rationalize(BigInt, 10.3)
103//10

julia&gt; typeof(numerator(a))
BigInt</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/rational.jl#L139-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read" href="#Base.read"><code>Base.read</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read(s::IO, nb=typemax(Int))</code></pre><p>Read at most <code>nb</code> bytes from <code>s</code>, returning a <code>Vector{UInt8}</code> of the bytes read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L953-L957">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read!" href="#Base.read!"><code>Base.read!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read!(stream::IO, array::AbstractArray)
read!(filename::AbstractString, array::AbstractArray)</code></pre><p>Read binary data from an I/O stream or file, filling in <code>array</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L436-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{AbstractString, Vararg{Any, N} where N}" href="#Base.read-Tuple{AbstractString, Vararg{Any, N} where N}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read(filename::AbstractString, args...)</code></pre><p>Open a file and read its contents. <code>args</code> is passed to <code>read</code>: this is equivalent to <code>open(io-&gt;read(io, args...), filename)</code>.</p><pre><code class="nohighlight hljs">read(filename::AbstractString, String)</code></pre><p>Read the entire contents of a file as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L422-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{Any, Any}" href="#Base.read-Tuple{Any, Any}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read(io::IO, T)</code></pre><p>Read a single value of type <code>T</code> from <code>io</code>, in canonical binary representation.</p><p>Note that Julia does not convert the endianness for you. Use <a href="#Base.ntoh-Tuple{Any}"><code>ntoh</code></a> or <a href="#Base.ltoh-Tuple{Any}"><code>ltoh</code></a> for this purpose.</p><pre><code class="nohighlight hljs">read(io::IO, String)</code></pre><p>Read the entirety of <code>io</code>, as a <code>String</code> (see also <a href="#Base.readchomp-Tuple{Any}"><code>readchomp</code></a>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization&quot;);

julia&gt; read(io, Char)
&#39;J&#39;: ASCII/Unicode U+004A (category Lu: Letter, uppercase)

julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization&quot;);

julia&gt; read(io, String)
&quot;JuliaLang is a GitHub organization&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L129-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{Base.AbstractCmd, Type{String}}" href="#Base.read-Tuple{Base.AbstractCmd, Type{String}}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read(command::Cmd, String)</code></pre><p>Run <code>command</code> and return the resulting output as a <code>String</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L416-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{Base.AbstractCmd}" href="#Base.read-Tuple{Base.AbstractCmd}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read(command::Cmd)</code></pre><p>Run <code>command</code> and return the resulting output as an array of bytes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L404-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.read-Tuple{IOStream, Integer}" href="#Base.read-Tuple{IOStream, Integer}"><code>Base.read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read(s::IOStream, nb::Integer; all=true)</code></pre><p>Read at most <code>nb</code> bytes from <code>s</code>, returning a <code>Vector{UInt8}</code> of the bytes read.</p><p>If <code>all</code> is <code>true</code> (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If <code>all</code> is <code>false</code>, at most one <code>read</code> call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the <code>all</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L547-L556">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.readavailable" href="#Base.readavailable"><code>Base.readavailable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readavailable(stream)</code></pre><p>Read available buffered data from a stream. Actual I/O is performed only if no data has already been buffered. The result is a <code>Vector{UInt8}</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The amount of data returned is implementation-dependent; for example it can depend on the internal choice of buffer size. Other functions such as <a href="#Base.read"><code>read</code></a> should generally be used instead.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.readbytes!" href="#Base.readbytes!"><code>Base.readbytes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))</code></pre><p>Read at most <code>nb</code> bytes from <code>stream</code> into <code>b</code>, returning the number of bytes read. The size of <code>b</code> will be increased if needed (i.e. if <code>nb</code> is greater than <code>length(b)</code> and enough bytes could be read), but it will never be decreased.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L927-L933">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.readbytes!" href="#Base.readbytes!"><code>Base.readbytes!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)</code></pre><p>Read at most <code>nb</code> bytes from <code>stream</code> into <code>b</code>, returning the number of bytes read. The size of <code>b</code> will be increased if needed (i.e. if <code>nb</code> is greater than <code>length(b)</code> and enough bytes could be read), but it will never be decreased.</p><p>If <code>all</code> is <code>true</code> (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If <code>all</code> is <code>false</code>, at most one <code>read</code> call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the <code>all</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L497-L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.readchomp-Tuple{Any}" href="#Base.readchomp-Tuple{Any}"><code>Base.readchomp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readchomp(x)</code></pre><p>Read the entirety of <code>x</code> as a string and remove a single trailing newline if there is one. Equivalent to <code>chomp(read(x, String))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; open(&quot;my_file.txt&quot;, &quot;w&quot;) do io
           write(io, &quot;JuliaLang is a GitHub organization.\nIt has many members.\n&quot;);
       end;

julia&gt; readchomp(&quot;my_file.txt&quot;)
&quot;JuliaLang is a GitHub organization.\nIt has many members.&quot;

julia&gt; rm(&quot;my_file.txt&quot;);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L905-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.readeach-Union{Tuple{IOT}, Tuple{IOT, Type}} where IOT&lt;:IO" href="#Base.readeach-Union{Tuple{IOT}, Tuple{IOT, Type}} where IOT&lt;:IO"><code>Base.readeach</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readeach(io::IO, T)</code></pre><p>Return an iterable object yielding <a href="#Base.read-Tuple{Any, Any}"><code>read(io, T)</code></a>.</p><p>See also: <a href="#Base.skipchars-Tuple{Any, IO}"><code>skipchars</code></a>, <a href="#Base.eachline"><code>eachline</code></a>, <a href="#Base.readuntil-Tuple{AbstractString, Vararg{Any, N} where N}"><code>readuntil</code></a></p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p><code>readeach</code> requires Julia 1.6 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization.\n It has many members.\n&quot;);

julia&gt; for c in readeach(io, Char)
           c == &#39;\n&#39; &amp;&amp; break
           print(c)
       end
JuliaLang is a GitHub organization.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L1026-L1046">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.readline-Tuple{AbstractString}" href="#Base.readline-Tuple{AbstractString}"><code>Base.readline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readline(io::IO=stdin; keep::Bool=false)
readline(filename::AbstractString; keep::Bool=false)</code></pre><p>Read a single line of text from the given I/O stream or file (defaults to <code>stdin</code>). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with <code>&#39;\n&#39;</code> or <code>&quot;\r\n&quot;</code> or the end of an input stream. When <code>keep</code> is false (as it is by default), these trailing newline characters are removed from the line before it is returned. When <code>keep</code> is true, they are returned as part of the line.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; open(&quot;my_file.txt&quot;, &quot;w&quot;) do io
           write(io, &quot;JuliaLang is a GitHub organization.\nIt has many members.\n&quot;);
       end
57

julia&gt; readline(&quot;my_file.txt&quot;)
&quot;JuliaLang is a GitHub organization.&quot;

julia&gt; readline(&quot;my_file.txt&quot;, keep=true)
&quot;JuliaLang is a GitHub organization.\n&quot;

julia&gt; rm(&quot;my_file.txt&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L473-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.readlines-Tuple{AbstractString}" href="#Base.readlines-Tuple{AbstractString}"><code>Base.readlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readlines(io::IO=stdin; keep::Bool=false)
readlines(filename::AbstractString; keep::Bool=false)</code></pre><p>Read all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading <a href="#Base.readline-Tuple{AbstractString}"><code>readline</code></a> repeatedly with the same arguments and saving the resulting lines as a vector of strings.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; open(&quot;my_file.txt&quot;, &quot;w&quot;) do io
           write(io, &quot;JuliaLang is a GitHub organization.\nIt has many members.\n&quot;);
       end
57

julia&gt; readlines(&quot;my_file.txt&quot;)
2-element Vector{String}:
 &quot;JuliaLang is a GitHub organization.&quot;
 &quot;It has many members.&quot;

julia&gt; readlines(&quot;my_file.txt&quot;, keep=true)
2-element Vector{String}:
 &quot;JuliaLang is a GitHub organization.\n&quot;
 &quot;It has many members.\n&quot;

julia&gt; rm(&quot;my_file.txt&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L518-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.readuntil-Tuple{AbstractString, Vararg{Any, N} where N}" href="#Base.readuntil-Tuple{AbstractString, Vararg{Any, N} where N}"><code>Base.readuntil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readuntil(stream::IO, delim; keep::Bool = false)
readuntil(filename::AbstractString, delim; keep::Bool = false)</code></pre><p>Read a string from an I/O stream or a file, up to the given delimiter. The delimiter can be a <code>UInt8</code>, <code>AbstractChar</code>, string, or vector. Keyword argument <code>keep</code> controls whether the delimiter is included in the result. The text is assumed to be encoded in UTF-8.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; open(&quot;my_file.txt&quot;, &quot;w&quot;) do io
           write(io, &quot;JuliaLang is a GitHub organization.\nIt has many members.\n&quot;);
       end
57

julia&gt; readuntil(&quot;my_file.txt&quot;, &#39;L&#39;)
&quot;Julia&quot;

julia&gt; readuntil(&quot;my_file.txt&quot;, &#39;.&#39;, keep = true)
&quot;JuliaLang is a GitHub organization.&quot;

julia&gt; rm(&quot;my_file.txt&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L446-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.real-Tuple{Complex}" href="#Base.real-Tuple{Complex}"><code>Base.real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real(z)</code></pre><p>Return the real part of the complex number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; real(1 + 3im)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L52-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.real-Tuple{Type}" href="#Base.real-Tuple{Type}"><code>Base.real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">real(T::Type)</code></pre><p>Return the type that represents the real part of a value of type <code>T</code>. e.g: for <code>T == Complex{R}</code>, returns <code>R</code>. Equivalent to <code>typeof(real(zero(T)))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; real(Complex{Int})
Int64

julia&gt; real(Float64)
Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L93-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.recursive_prefs_merge-Tuple{Dict{String, Any}, Vararg{Dict{String, Any}, N} where N}" href="#Base.recursive_prefs_merge-Tuple{Dict{String, Any}, Vararg{Dict{String, Any}, N} where N}"><code>Base.recursive_prefs_merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recursive_prefs_merge(base::Dict, overrides::Dict...)</code></pre><p>Helper function to merge preference dicts recursively, honoring overrides in nested dictionaries properly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L1630-L1635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.redirect_stderr" href="#Base.redirect_stderr"><code>Base.redirect_stderr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">redirect_stderr([stream]) -&gt; (rd, wr)</code></pre><p>Like <a href="#Base.redirect_stdout"><code>redirect_stdout</code></a>, but for <a href="#Base.stderr"><code>stderr</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>stream</code> must be an <code>IOStream</code>, a <code>TTY</code>, a <code>Pipe</code>, a socket, or <code>devnull</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L1196-L1203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.redirect_stderr-Tuple{Function, Any}" href="#Base.redirect_stderr-Tuple{Function, Any}"><code>Base.redirect_stderr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">redirect_stderr(f::Function, stream)</code></pre><p>Run the function <code>f</code> while redirecting <a href="#Base.stderr"><code>stderr</code></a> to <code>stream</code>. Upon completion, <a href="#Base.stderr"><code>stderr</code></a> is restored to its prior setting.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>stream</code> must be a <code>TTY</code>, a <code>Pipe</code>, or a socket.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L1243-L1251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.redirect_stdin" href="#Base.redirect_stdin"><code>Base.redirect_stdin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">redirect_stdin([stream]) -&gt; (rd, wr)</code></pre><p>Like <a href="#Base.redirect_stdout"><code>redirect_stdout</code></a>, but for <a href="#Base.stdin"><code>stdin</code></a>. Note that the order of the return tuple is still <code>(rd, wr)</code>, i.e. data to be read from <a href="#Base.stdin"><code>stdin</code></a> may be written to <code>wr</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>stream</code> must be an <code>IOStream</code>, a <code>TTY</code>, a <code>Pipe</code>, a socket, or <code>devnull</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L1206-L1215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.redirect_stdin-Tuple{Function, Any}" href="#Base.redirect_stdin-Tuple{Function, Any}"><code>Base.redirect_stdin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">redirect_stdin(f::Function, stream)</code></pre><p>Run the function <code>f</code> while redirecting <a href="#Base.stdin"><code>stdin</code></a> to <code>stream</code>. Upon completion, <a href="#Base.stdin"><code>stdin</code></a> is restored to its prior setting.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>stream</code> must be a <code>TTY</code>, a <code>Pipe</code>, or a socket.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L1254-L1262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.redirect_stdout" href="#Base.redirect_stdout"><code>Base.redirect_stdout</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">redirect_stdout([stream]) -&gt; (rd, wr)</code></pre><p>Create a pipe to which all C and Julia level <a href="#Base.stdout"><code>stdout</code></a> output will be redirected. Returns a tuple <code>(rd, wr)</code> representing the pipe ends. Data written to <a href="#Base.stdout"><code>stdout</code></a> may now be read from the <code>rd</code> end of the pipe. The <code>wr</code> end is given for convenience in case the old <a href="#Base.stdout"><code>stdout</code></a> object was cached by the user and needs to be replaced elsewhere.</p><p>If called with the optional <code>stream</code> argument, then returns <code>stream</code> itself.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>stream</code> must be an <code>IOStream</code>, a <code>TTY</code>, a <code>Pipe</code>, a socket, or <code>devnull</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L1178-L1193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.redirect_stdout-Tuple{Function, Any}" href="#Base.redirect_stdout-Tuple{Function, Any}"><code>Base.redirect_stdout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">redirect_stdout(f::Function, stream)</code></pre><p>Run the function <code>f</code> while redirecting <a href="#Base.stdout"><code>stdout</code></a> to <code>stream</code>. Upon completion, <a href="#Base.stdout"><code>stdout</code></a> is restored to its prior setting.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>stream</code> must be a <code>TTY</code>, a <code>Pipe</code>, or a socket.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/stream.jl#L1232-L1240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reduce-Tuple{Any, AbstractArray}" href="#Base.reduce-Tuple{Any, AbstractArray}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(f, A; dims=:, [init])</code></pre><p>Reduce 2-argument function <code>f</code> along dimensions of <code>A</code>. <code>dims</code> is a vector specifying the dimensions to reduce, and the keyword argument <code>init</code> is the initial value to use in the reductions. For <code>+</code>, <code>*</code>, <code>max</code> and <code>min</code> the <code>init</code> argument is optional.</p><p>The associativity of the reduction is implementation-dependent; if you need a particular associativity, e.g. left-to-right, you should write your own loop or consider using <a href="#Base.foldl-Tuple{Any, Any}"><code>foldl</code></a> or <a href="#Base.foldr-Tuple{Any, Any}"><code>foldr</code></a>. See documentation for <a href="#Base.reduce-Tuple{Any, AbstractArray}"><code>reduce</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = reshape(Vector(1:16), (4,4))
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; reduce(max, a, dims=2)
4×1 Matrix{Int64}:
 13
 14
 15
 16

julia&gt; reduce(max, a, dims=1)
1×4 Matrix{Int64}:
 4  8  12  16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L327-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reduce-Tuple{Any, Any}" href="#Base.reduce-Tuple{Any, Any}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce(op, itr; [init])</code></pre><p>Reduce the given collection <code>itr</code> with the given binary operator <code>op</code>. If provided, the initial value <code>init</code> must be a neutral element for <code>op</code> that will be returned for empty collections. It is unspecified whether <code>init</code> is used for non-empty collections.</p><p>For empty collections, providing <code>init</code> will be necessary, except for some special cases (e.g. when <code>op</code> is one of <code>+</code>, <code>*</code>, <code>max</code>, <code>min</code>, <code>&amp;</code>, <code>|</code>) when Julia can determine the neutral element of <code>op</code>.</p><p>Reductions for certain commonly-used operators may have special implementations, and should be used instead: <code>maximum(itr)</code>, <code>minimum(itr)</code>, <code>sum(itr)</code>, <code>prod(itr)</code>,  <code>any(itr)</code>, <code>all(itr)</code>.</p><p>The associativity of the reduction is implementation dependent. This means that you can&#39;t use non-associative operations like <code>-</code> because it is undefined whether <code>reduce(-,[1,2,3])</code> should be evaluated as <code>(1-2)-3</code> or <code>1-(2-3)</code>. Use <a href="#Base.foldl-Tuple{Any, Any}"><code>foldl</code></a> or <a href="#Base.foldr-Tuple{Any, Any}"><code>foldr</code></a> instead for guaranteed left or right associativity.</p><p>Some operations accumulate error. Parallelism will be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reduce(*, [2; 3; 4])
24

julia&gt; reduce(*, [2; 3; 4]; init=-1)
-24</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L423-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reduce_empty-Union{Tuple{T}, Tuple{Any, Type{T}}} where T" href="#Base.reduce_empty-Union{Tuple{T}, Tuple{Any, Type{T}}} where T"><code>Base.reduce_empty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.reduce_empty(op, T)</code></pre><p>The value to be returned when calling <a href="#Base.reduce-Tuple{Any, AbstractArray}"><code>reduce</code></a>, <a href="#Base.foldl-Tuple{Any, Any}"><code>foldl</code></a> or <a href="#Base.foldr-Tuple{Any, Any}"><code>foldr</code></a> with reduction <code>op</code> over an empty array with element type of <code>T</code>.</p><p>If not defined, this will throw an <code>ArgumentError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L301-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reduce_first-Tuple{Any, Any}" href="#Base.reduce_first-Tuple{Any, Any}"><code>Base.reduce_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.reduce_first(op, x)</code></pre><p>The value to be returned when calling <a href="#Base.reduce-Tuple{Any, AbstractArray}"><code>reduce</code></a>, <a href="@ref`"><code>foldl</code></a> or <a href="#Base.foldr-Tuple{Any, Any}"><code>foldr</code></a> with reduction <code>op</code> over an iterator which contains a single element <code>x</code>. This value may also used to initialise the recursion, so that <code>reduce(op, [x, y])</code> may call <code>op(reduce_first(op, x), y)</code>.</p><p>The default is <code>x</code> for most types. The main purpose is to ensure type stability, so additional methods should only be defined for cases where <code>op</code> gives a result with different types than its inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L359-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reenable_sigint-Tuple{Function}" href="#Base.reenable_sigint-Tuple{Function}"><code>Base.reenable_sigint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reenable_sigint(f::Function)</code></pre><p>Re-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of <a href="#Base.disable_sigint-Tuple{Function}"><code>disable_sigint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L464-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reim-Tuple{Any}" href="#Base.reim-Tuple{Any}"><code>Base.reim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reim(z)</code></pre><p>Return both the real and imaginary parts of the complex number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reim(1 + 3im)
(1, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L80-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reinterpret-Tuple{typeof(reshape), Type, AbstractArray}" href="#Base.reinterpret-Tuple{typeof(reshape), Type, AbstractArray}"><code>Base.reinterpret</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinterpret(reshape, T, A::AbstractArray{S}) -&gt; B</code></pre><p>Change the type-interpretation of <code>A</code> while consuming or adding a &quot;channel dimension.&quot;</p><p>If <code>sizeof(T) = n*sizeof(S)</code> for <code>n&gt;1</code>, <code>A</code>&#39;s first dimension must be of size <code>n</code> and <code>B</code> lacks <code>A</code>&#39;s first dimension. Conversely, if <code>sizeof(S) = n*sizeof(T)</code> for <code>n&gt;1</code>, <code>B</code> gets a new first dimension of size <code>n</code>. The dimensionality is unchanged if <code>sizeof(T) == sizeof(S)</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>This method requires at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; reinterpret(reshape, Complex{Int}, A)    # the result is a vector
2-element reinterpret(reshape, Complex{Int64}, ::Matrix{Int64}) with eltype Complex{Int64}:
 1 + 3im
 2 + 4im

julia&gt; a = [(1,2,3), (4,5,6)]
2-element Vector{Tuple{Int64, Int64, Int64}}:
 (1, 2, 3)
 (4, 5, 6)

julia&gt; reinterpret(reshape, Int, a)             # the result is a matrix
3×2 reinterpret(reshape, Int64, ::Vector{Tuple{Int64, Int64, Int64}}) with eltype Int64:
 1  4
 2  5
 3  6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reinterpretarray.jl#L84-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reinterpret-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#Base.reinterpret-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>Base.reinterpret</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinterpret(type, A)</code></pre><p>Change the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, <code>reinterpret(Float32, UInt32(7))</code> interprets the 4 bytes corresponding to <code>UInt32(7)</code> as a <a href="@ref"><code>Float32</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reinterpret(Float32, UInt32(7))
1.0f-44

julia&gt; reinterpret(Float32, UInt32[1 2 3 4 5])
1×5 reinterpret(Float32, ::Matrix{UInt32}):
 1.0f-45  3.0f-45  4.0f-45  6.0f-45  7.0f-45</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L402-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.release-Tuple{Base.Semaphore}" href="#Base.release-Tuple{Base.Semaphore}"><code>Base.release</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">release(s::Semaphore)</code></pre><p>Return one permit to the pool, possibly allowing another task to acquire it and resume execution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/lock.jl#L298-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rem" href="#Base.rem"><code>Base.rem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rem(x, y)
%(x, y)</code></pre><p>Remainder from Euclidean division, returning a value of the same sign as <code>x</code>, and smaller in magnitude than <code>y</code>. This value is always exact.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = 15; y = 4;

julia&gt; x % y
3

julia&gt; x == div(x, y) * y + rem(x, y)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L722-L739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rem-Tuple{Any, Any, RoundingMode}" href="#Base.rem-Tuple{Any, Any, RoundingMode}"><code>Base.rem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem(x, y, r::RoundingMode=RoundToZero)</code></pre><p>Compute the remainder of <code>x</code> after integer division by <code>y</code>, with the quotient rounded according to the rounding mode <code>r</code>. In other words, the quantity</p><pre><code class="nohighlight hljs">x - y*round(x/y,r)</code></pre><p>without any intermediate rounding.</p><ul><li><p>if <code>r == RoundNearest</code>, then the result is exact, and in the interval <span>$[-|y|/2, |y|/2]$</span>. See also <a href="@ref"><code>RoundNearest</code></a>.</p></li><li><p>if <code>r == RoundToZero</code> (default), then the result is exact, and in the interval <span>$[0, |y|)$</span> if <code>x</code> is positive, or <span>$(-|y|, 0]$</span> otherwise. See also <a href="@ref"><code>RoundToZero</code></a>.</p></li><li><p>if <code>r == RoundDown</code>, then the result is in the interval <span>$[0, y)$</span> if <code>y</code> is positive, or <span>$(y, 0]$</span> otherwise. The result may not be exact if <code>x</code> and <code>y</code> have different signs, and <code>abs(x) &lt; abs(y)</code>. See also <a href="@ref"><code>RoundDown</code></a>.</p></li><li><p>if <code>r == RoundUp</code>, then the result is in the interval <code>(-y,0]</code> if <code>y</code> is positive, or <code>[0,-y)</code> otherwise. The result may not be exact if <code>x</code> and <code>y</code> have the same sign, and <code>abs(x) &lt; abs(y)</code>. See also <a href="@ref"><code>RoundUp</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/div.jl#L39-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rem-Tuple{Integer, Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Integer}" href="#Base.rem-Tuple{Integer, Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:Integer}"><code>Base.rem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rem(x::Integer, T::Type{&lt;:Integer}) -&gt; T
mod(x::Integer, T::Type{&lt;:Integer}) -&gt; T
%(x::Integer, T::Type{&lt;:Integer}) -&gt; T</code></pre><p>Find <code>y::T</code> such that <code>x</code> ≡ <code>y</code> (mod n), where n is the number of integers representable in <code>T</code>, and <code>y</code> is an integer in <code>[typemin(T),typemax(T)]</code>. If <code>T</code> can represent any integer (e.g. <code>T == BigInt</code>), then this operation corresponds to a conversion to <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 129 % Int8
-127</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L521-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repeat-Tuple{AbstractArray, Vararg{Any, N} where N}" href="#Base.repeat-Tuple{AbstractArray, Vararg{Any, N} where N}"><code>Base.repeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat(A::AbstractArray, counts::Integer...)</code></pre><p>Construct an array by repeating array <code>A</code> a given number of times in each dimension, specified by <code>counts</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; repeat([1, 2, 3], 2)
6-element Vector{Int64}:
 1
 2
 3
 1
 2
 3

julia&gt; repeat([1, 2, 3], 2, 3)
6×3 Matrix{Int64}:
 1  1  1
 2  2  2
 3  3  3
 1  1  1
 2  2  2
 3  3  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarraymath.jl#L197-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repeat-Tuple{AbstractArray}" href="#Base.repeat-Tuple{AbstractArray}"><code>Base.repeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat(A::AbstractArray; inner=ntuple(x-&gt;1, ndims(A)), outer=ntuple(x-&gt;1, ndims(A)))</code></pre><p>Construct an array by repeating the entries of <code>A</code>. The i-th element of <code>inner</code> specifies the number of times that the individual entries of the i-th dimension of <code>A</code> should be repeated. The i-th element of <code>outer</code> specifies the number of times that a slice along the i-th dimension of <code>A</code> should be repeated. If <code>inner</code> or <code>outer</code> are omitted, no repetition is performed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; repeat(1:2, inner=2)
4-element Vector{Int64}:
 1
 1
 2
 2

julia&gt; repeat(1:2, outer=2)
4-element Vector{Int64}:
 1
 2
 1
 2

julia&gt; repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))
4×6 Matrix{Int64}:
 1  2  1  2  1  2
 1  2  1  2  1  2
 3  4  3  4  3  4
 3  4  3  4  3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarraymath.jl#L227-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repeat-Tuple{AbstractChar, Integer}" href="#Base.repeat-Tuple{AbstractChar, Integer}"><code>Base.repeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat(c::AbstractChar, r::Integer) -&gt; String</code></pre><p>Repeat a character <code>r</code> times. This can equivalently be accomplished by calling <a href="#Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}"><code>c^r</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; repeat(&#39;A&#39;, 3)
&quot;AAA&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/string.jl#L321-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repeat-Tuple{AbstractString, Integer}" href="#Base.repeat-Tuple{AbstractString, Integer}"><code>Base.repeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat(s::AbstractString, r::Integer)</code></pre><p>Repeat a string <code>r</code> times. This can be written as <code>s^r</code>.</p><p>See also: <a href="#Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}"><code>^</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; repeat(&quot;ha&quot;, 3)
&quot;hahaha&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L690-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace!-Tuple{Any, Vararg{Pair, N} where N}" href="#Base.replace!-Tuple{Any, Vararg{Pair, N} where N}"><code>Base.replace!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace!(A, old_new::Pair...; [count::Integer])</code></pre><p>For each pair <code>old=&gt;new</code> in <code>old_new</code>, replace all occurrences of <code>old</code> in collection <code>A</code> by <code>new</code>. Equality is determined using <a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a>. If <code>count</code> is specified, then replace at most <code>count</code> occurrences in total. See also <a href="#Base.replace-Tuple{Any, Vararg{Pair, N} where N}"><code>replace</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; replace!([1, 2, 1, 3], 1=&gt;0, 2=&gt;4, count=2)
4-element Vector{Int64}:
 0
 4
 1
 3

julia&gt; replace!(Set([1, 2, 3]), 1=&gt;0)
Set{Int64} with 3 elements:
  0
  2
  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/set.jl#L453-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace!-Tuple{Union{Function, Type}, Any}" href="#Base.replace!-Tuple{Union{Function, Type}, Any}"><code>Base.replace!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace!(new::Function, A; [count::Integer])</code></pre><p>Replace each element <code>x</code> in collection <code>A</code> by <code>new(x)</code>. If <code>count</code> is specified, then replace at most <code>count</code> values in total (replacements being defined as <code>new(x) !== x</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; replace!(x -&gt; isodd(x) ? 2x : x, [1, 2, 3, 4])
4-element Vector{Int64}:
 2
 2
 6
 4

julia&gt; replace!(Dict(1=&gt;2, 3=&gt;4)) do kv
           first(kv) &lt; 3 ? first(kv)=&gt;3 : kv
       end
Dict{Int64, Int64} with 2 entries:
  3 =&gt; 4
  1 =&gt; 3

julia&gt; replace!(x-&gt;2x, Set([3, 6]))
Set{Int64} with 2 elements:
  6
  12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/set.jl#L491-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace-Tuple{AbstractString, Pair}" href="#Base.replace-Tuple{AbstractString, Pair}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace(s::AbstractString, pat=&gt;r; [count::Integer])</code></pre><p>Search for the given pattern <code>pat</code> in <code>s</code>, and replace each occurrence with <code>r</code>. If <code>count</code> is provided, replace at most <code>count</code> occurrences. <code>pat</code> may be a single character, a vector or a set of characters, a string, or a regular expression. If <code>r</code> is a function, each occurrence is replaced with <code>r(s)</code> where <code>s</code> is the matched substring (when <code>pat</code> is a <code>AbstractPattern</code> or <code>AbstractString</code>) or character (when <code>pat</code> is an <code>AbstractChar</code> or a collection of <code>AbstractChar</code>). If <code>pat</code> is a regular expression and <code>r</code> is a <a href="#Base.SubstitutionString"><code>SubstitutionString</code></a>, then capture group references in <code>r</code> are replaced with the corresponding matched text. To remove instances of <code>pat</code> from <code>string</code>, set <code>r</code> to the empty <code>String</code> (<code>&quot;&quot;</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; replace(&quot;Python is a programming language.&quot;, &quot;Python&quot; =&gt; &quot;Julia&quot;)
&quot;Julia is a programming language.&quot;

julia&gt; replace(&quot;The quick foxes run quickly.&quot;, &quot;quick&quot; =&gt; &quot;slow&quot;, count=1)
&quot;The slow foxes run quickly.&quot;

julia&gt; replace(&quot;The quick foxes run quickly.&quot;, &quot;quick&quot; =&gt; &quot;&quot;, count=1)
&quot;The  foxes run quickly.&quot;

julia&gt; replace(&quot;The quick foxes run quickly.&quot;, r&quot;fox(es)?&quot; =&gt; s&quot;bus\1&quot;)
&quot;The quick buses run quickly.&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L561-L589">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace-Tuple{Any, Vararg{Pair, N} where N}" href="#Base.replace-Tuple{Any, Vararg{Pair, N} where N}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace(A, old_new::Pair...; [count::Integer])</code></pre><p>Return a copy of collection <code>A</code> where, for each pair <code>old=&gt;new</code> in <code>old_new</code>, all occurrences of <code>old</code> are replaced by <code>new</code>. Equality is determined using <a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a>. If <code>count</code> is specified, then replace at most <code>count</code> occurrences in total.</p><p>The element type of the result is chosen using promotion (see <a href="#Base.promote_type"><code>promote_type</code></a>) based on the element type of <code>A</code> and on the types of the <code>new</code> values in pairs. If <code>count</code> is omitted and the element type of <code>A</code> is a <code>Union</code>, the element type of the result will not include singleton types which are replaced with values of a different type: for example, <code>Union{T,Missing}</code> will become <code>T</code> if <code>missing</code> is replaced.</p><p>See also <a href="#Base.replace!-Tuple{Any, Vararg{Pair, N} where N}"><code>replace!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; replace([1, 2, 1, 3], 1=&gt;0, 2=&gt;4, count=2)
4-element Vector{Int64}:
 0
 4
 1
 3

julia&gt; replace([1, missing], missing=&gt;0)
2-element Vector{Int64}:
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/set.jl#L523-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace-Tuple{Union{Function, Type}, Any}" href="#Base.replace-Tuple{Union{Function, Type}, Any}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace(new::Function, A; [count::Integer])</code></pre><p>Return a copy of <code>A</code> where each value <code>x</code> in <code>A</code> is replaced by <code>new(x)</code>. If <code>count</code> is specified, then replace at most <code>count</code> values in total (replacements being defined as <code>new(x) !== x</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; replace(x -&gt; isodd(x) ? 2x : x, [1, 2, 3, 4])
4-element Vector{Int64}:
 2
 2
 6
 4

julia&gt; replace(Dict(1=&gt;2, 3=&gt;4)) do kv
           first(kv) &lt; 3 ? first(kv)=&gt;3 : kv
       end
Dict{Int64, Int64} with 2 entries:
  3 =&gt; 4
  1 =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/set.jl#L581-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace_ref_begin_end!-Tuple{Any}" href="#Base.replace_ref_begin_end!-Tuple{Any}"><code>Base.replace_ref_begin_end!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_ref_begin_end!(ex)</code></pre><p>Recursively replace occurrences of the symbols <code>:begin</code> and <code>:end</code> in a &quot;ref&quot; expression (i.e. <code>A[...]</code>) <code>ex</code> with the appropriate function calls (<code>firstindex</code> or <code>lastindex</code>). Replacement uses the closest enclosing ref, so</p><pre><code class="nohighlight hljs">A[B[end]]</code></pre><p>should transform to</p><pre><code class="nohighlight hljs">A[B[lastindex(B)]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/views.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace_with_centered_mark-Tuple{AbstractString}" href="#Base.replace_with_centered_mark-Tuple{AbstractString}"><code>Base.replace_with_centered_mark</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Unexported convenience function used in body of <code>replace_in_print_matrix</code> methods. By default returns a string of the same width as original with a centered cdot, used in printing of structural zeros of structured matrices. Accept keyword args <code>c</code> for alternate single character marker.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arrayshow.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repr-Tuple{Any}" href="#Base.repr-Tuple{Any}"><code>Base.repr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repr(x; context=nothing)</code></pre><p>Create a string from any value using the <a href="#Base.show-Tuple{IO, Any}"><code>show</code></a> function. You should not add methods to <code>repr</code>; define a <code>show</code> method instead.</p><p>The optional keyword argument <code>context</code> can be set to an <code>IO</code> or <a href="#Base.IOContext"><code>IOContext</code></a> object whose attributes are used for the I/O stream passed to <code>show</code>.</p><p>Note that <code>repr(x)</code> is usually similar to how the value of <code>x</code> would be entered in Julia.  See also <a href="#Base.repr-Tuple{Any}"><code>repr(MIME(&quot;text/plain&quot;), x)</code></a> to instead return a &quot;pretty-printed&quot; version of <code>x</code> designed more for human consumption, equivalent to the REPL display of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; repr(1)
&quot;1&quot;

julia&gt; repr(zeros(3))
&quot;[0.0, 0.0, 0.0]&quot;

julia&gt; repr(big(1/3))
&quot;0.333333333333333314829616256247390992939472198486328125&quot;

julia&gt; repr(big(1/3), context=:compact =&gt; true)
&quot;0.333333&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L189-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.require-Tuple{Module, Symbol}" href="#Base.require-Tuple{Module, Symbol}"><code>Base.require</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">require(into::Module, module::Symbol)</code></pre><p>This function is part of the implementation of <a href="@ref"><code>using</code></a> / <a href="@ref"><code>import</code></a>, if a module is not already defined in <code>Main</code>. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).</p><p>Loads a source file, in the context of the <code>Main</code> module, on every active node, searching standard locations for files. <code>require</code> is considered a top-level operation, so it sets the current <code>include</code> path but does not use it to search for files (see help for <a href="#Base.include"><code>include</code></a>). This function is typically used to load library code, and is implicitly called by <code>using</code> to load packages.</p><p>When searching for files, <code>require</code> first looks for package code in the global array <a href="#Base.LOAD_PATH"><code>LOAD_PATH</code></a>. <code>require</code> is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.</p><p>For more details regarding code loading, see the manual sections on <a href="@ref modules">modules</a> and <a href="@ref code-availability">parallel computing</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L866-L886">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reset-Tuple{T} where T&lt;:IO" href="#Base.reset-Tuple{T} where T&lt;:IO"><code>Base.reset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset(s)</code></pre><p>Reset a stream <code>s</code> to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked.</p><p>See also <a href="#Base.mark-Tuple{IO}"><code>mark</code></a>, <a href="#Base.unmark-Tuple{IO}"><code>unmark</code></a>, <a href="#Base.ismarked-Tuple{IO}"><code>ismarked</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L1085-L1092">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reshape" href="#Base.reshape"><code>Base.reshape</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reshape(A, dims...) -&gt; AbstractArray
reshape(A, dims) -&gt; AbstractArray</code></pre><p>Return an array with the same data as <code>A</code>, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that the result is mutable if and only if <code>A</code> is mutable, and setting elements of one alters the values of the other.</p><p>The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a <code>:</code>, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array <code>A</code>. The total number of elements must not change.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Vector(1:16)
16-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16

julia&gt; reshape(A, (4, 4))
4×4 Matrix{Int64}:
 1  5   9  13
 2  6  10  14
 3  7  11  15
 4  8  12  16

julia&gt; reshape(A, 2, :)
2×8 Matrix{Int64}:
 1  3  5  7   9  11  13  15
 2  4  6  8  10  12  14  16

julia&gt; reshape(1:6, 2, 3)
2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:
 1  3  5
 2  4  6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reshapedarray.jl#L54-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.resize!-Tuple{Vector{T} where T, Integer}" href="#Base.resize!-Tuple{Vector{T} where T, Integer}"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize!(a::Vector, n::Integer) -&gt; Vector</code></pre><p>Resize <code>a</code> to contain <code>n</code> elements. If <code>n</code> is smaller than the current collection length, the first <code>n</code> elements will be retained. If <code>n</code> is larger, the new elements are not guaranteed to be initialized.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; resize!([6, 5, 4, 3, 2, 1], 3)
3-element Vector{Int64}:
 6
 5
 4

julia&gt; a = resize!([6, 5, 4, 3, 2, 1], 8);

julia&gt; length(a)
8

julia&gt; a[1:6]
6-element Vector{Int64}:
 6
 5
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1071-L1100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rest" href="#Base.rest"><code>Base.rest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.rest(collection[, itr_state])</code></pre><p>Generic function for taking the tail of <code>collection</code>, starting from a specific iteration state <code>itr_state</code>. Return a <code>Tuple</code>, if <code>collection</code> itself is a <code>Tuple</code>, a subtype of <code>AbstractVector</code>, if <code>collection</code> is an <code>AbstractArray</code>, a subtype of <code>AbstractString</code> if <code>collection</code> is an <code>AbstractString</code>, and an arbitrary iterator, falling back to <code>Iterators.rest(collection[, itr_state])</code>, otherwise. Can be overloaded for user-defined collection types to customize the behavior of slurping in assignments, like <code>a, b... = collection</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p><code>Base.rest</code> requires at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; first, state = iterate(a)
(1, 2)

julia&gt; first, Base.rest(a, state)
(1, [3, 2, 4])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/tuple.jl#L99-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rethrow-Tuple{}" href="#Base.rethrow-Tuple{}"><code>Base.rethrow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rethrow()</code></pre><p>Rethrow the current exception from within a <code>catch</code> block. The rethrown exception will continue propagation as if it had not been caught.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The alternative form <code>rethrow(e)</code> allows you to associate an alternative exception object <code>e</code> with the current backtrace. However this misrepresents the program state at the time of the error so you&#39;re encouraged to instead throw a new exception using <code>throw(e)</code>. In Julia 1.1 and above, using <code>throw(e)</code> will preserve the root cause exception on the stack, as described in <a href="#Base.catch_stack"><code>catch_stack</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L45-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.retry-Tuple{Any}" href="#Base.retry-Tuple{Any}"><code>Base.retry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retry(f;  delays=ExponentialBackOff(), check=nothing) -&gt; Function</code></pre><p>Return an anonymous function that calls function <code>f</code>.  If an exception arises, <code>f</code> is repeatedly called again, each time <code>check</code> returns <code>true</code>, after waiting the number of seconds specified in <code>delays</code>.  <code>check</code> should input <code>delays</code>&#39;s current state and the <code>Exception</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>Before Julia 1.2 this signature was restricted to <code>f::Function</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">retry(f, delays=fill(5.0, 3))
retry(f, delays=rand(5:10, 2))
retry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))
retry(http_get, check=(s,e)-&gt;e.status == &quot;503&quot;)(url)
retry(read, check=(s,e)-&gt;isa(e, IOError))(io, 128; all=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L262-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse" href="#Base.reverse"><code>Base.reverse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse(v [, start=1 [, stop=length(v) ]] )</code></pre><p>Return a copy of <code>v</code> reversed from start to stop.  See also <a href="@ref"><code>Iterators.reverse</code></a> for reverse-order iteration without making a copy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Vector(1:5)
5-element Vector{Int64}:
 1
 2
 3
 4
 5

julia&gt; reverse(A)
5-element Vector{Int64}:
 5
 4
 3
 2
 1

julia&gt; reverse(A, 1, 4)
5-element Vector{Int64}:
 4
 3
 2
 1
 5

julia&gt; reverse(A, 3, 5)
5-element Vector{Int64}:
 1
 2
 5
 4
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1584-L1624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse!" href="#Base.reverse!"><code>Base.reverse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reverse!(v [, start=1 [, stop=length(v) ]]) -&gt; v</code></pre><p>In-place version of <a href="#Base.reverse"><code>reverse</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Vector(1:5)
5-element Vector{Int64}:
 1
 2
 3
 4
 5

julia&gt; reverse!(A);

julia&gt; A
5-element Vector{Int64}:
 5
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1658-L1683">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse!-Tuple{AbstractArray}" href="#Base.reverse!-Tuple{AbstractArray}"><code>Base.reverse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse!(A; dims=:)</code></pre><p>Like <a href="#Base.reverse"><code>reverse</code></a>, but operates in-place in <code>A</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Multidimensional <code>reverse!</code> requires Julia 1.6.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arraymath.jl#L93-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse-Tuple{AbstractArray}" href="#Base.reverse-Tuple{AbstractArray}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse(A; dims=:)</code></pre><p>Reverse <code>A</code> along dimension <code>dims</code>, which can be an integer (a single dimension), a tuple of integers (a tuple of dimensions) or <code>:</code> (reverse along all the dimensions, the default).  See also <a href="#Base.reverse!"><code>reverse!</code></a> for in-place reversal.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; b = Int64[1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; reverse(b, dims=2)
2×2 Matrix{Int64}:
 2  1
 4  3

julia&gt; reverse(b)
2×2 Matrix{Int64}:
 4  3
 2  1</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Prior to Julia 1.6, only single-integer <code>dims</code> are supported in <code>reverse</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arraymath.jl#L61-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse-Tuple{Union{SubString{String}, String}}" href="#Base.reverse-Tuple{Union{SubString{String}, String}}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse(s::AbstractString) -&gt; AbstractString</code></pre><p>Reverses a string. Technically, this function reverses the codepoints in a string and its main utility is for reversed-order string processing, especially for reversed regular-expression searches. See also <a href="#Base.reverseind-Tuple{AbstractString, Integer}"><code>reverseind</code></a> to convert indices in <code>s</code> to indices in <code>reverse(s)</code> and vice-versa, and <code>graphemes</code> from module <code>Unicode</code> to operate on user-visible &quot;characters&quot; (graphemes) rather than codepoints. See also <a href="@ref"><code>Iterators.reverse</code></a> for reverse-order iteration without making a copy. Custom string types must implement the <code>reverse</code> function themselves and should typically return a string with the same type and encoding. If they return a string with a different encoding, they must also override <code>reverseind</code> for that string type to satisfy <code>s[reverseind(s,i)] == reverse(s)[i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reverse(&quot;JuliaLang&quot;)
&quot;gnaLailuJ&quot;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The examples below may be rendered differently on different systems. The comments indicate how they&#39;re supposed to be rendered</p></div></div><p>Combining characters can lead to surprising results:</p><pre><code class="language-julia-repl hljs">julia&gt; reverse(&quot;ax̂e&quot;) # hat is above x in the input, above e in the output
&quot;êxa&quot;

julia&gt; using Unicode

julia&gt; join(reverse(collect(graphemes(&quot;ax̂e&quot;)))) # reverses graphemes; hat is above x in both in- and output
&quot;ex̂a&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/substring.jl#L130-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverseind-Tuple{AbstractString, Integer}" href="#Base.reverseind-Tuple{AbstractString, Integer}"><code>Base.reverseind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverseind(v, i)</code></pre><p>Given an index <code>i</code> in <a href="#Base.reverse"><code>reverse(v)</code></a>, return the corresponding index in <code>v</code> so that <code>v[reverseind(v,i)] == reverse(v)[i]</code>. (This can be nontrivial in cases where <code>v</code> contains non-ASCII characters.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; r = reverse(&quot;Julia&quot;)
&quot;ailuJ&quot;

julia&gt; for i in 1:length(r)
           print(r[reverseind(&quot;Julia&quot;, i)])
       end
Julia</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L670-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rot180-Tuple{AbstractMatrix{T} where T, Integer}" href="#Base.rot180-Tuple{AbstractMatrix{T} where T, Integer}"><code>Base.rot180</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rot180(A, k)</code></pre><p>Rotate matrix <code>A</code> 180 degrees an integer <code>k</code> number of times. If <code>k</code> is even, this is equivalent to a <code>copy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rot180(a,1)
2×2 Matrix{Int64}:
 4  3
 2  1

julia&gt; rot180(a,2)
2×2 Matrix{Int64}:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arraymath.jl#L291-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rot180-Tuple{AbstractMatrix{T} where T}" href="#Base.rot180-Tuple{AbstractMatrix{T} where T}"><code>Base.rot180</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rot180(A)</code></pre><p>Rotate matrix <code>A</code> 180 degrees.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rot180(a)
2×2 Matrix{Int64}:
 4  3
 2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arraymath.jl#L189-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rotl90-Tuple{AbstractMatrix{T} where T, Integer}" href="#Base.rotl90-Tuple{AbstractMatrix{T} where T, Integer}"><code>Base.rotl90</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotl90(A, k)</code></pre><p>Left-rotate matrix <code>A</code> 90 degrees counterclockwise an integer <code>k</code> number of times. If <code>k</code> is a multiple of four (including zero), this is equivalent to a <code>copy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rotl90(a,1)
2×2 Matrix{Int64}:
 2  4
 1  3

julia&gt; rotl90(a,2)
2×2 Matrix{Int64}:
 4  3
 2  1

julia&gt; rotl90(a,3)
2×2 Matrix{Int64}:
 3  1
 4  2

julia&gt; rotl90(a,4)
2×2 Matrix{Int64}:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arraymath.jl#L216-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rotl90-Tuple{AbstractMatrix{T} where T}" href="#Base.rotl90-Tuple{AbstractMatrix{T} where T}"><code>Base.rotl90</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotl90(A)</code></pre><p>Rotate matrix <code>A</code> left 90 degrees.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rotl90(a)
2×2 Matrix{Int64}:
 2  4
 1  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arraymath.jl#L134-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rotr90-Tuple{AbstractMatrix{T} where T, Integer}" href="#Base.rotr90-Tuple{AbstractMatrix{T} where T, Integer}"><code>Base.rotr90</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotr90(A, k)</code></pre><p>Right-rotate matrix <code>A</code> 90 degrees clockwise an integer <code>k</code> number of times. If <code>k</code> is a multiple of four (including zero), this is equivalent to a <code>copy</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rotr90(a,1)
2×2 Matrix{Int64}:
 3  1
 4  2

julia&gt; rotr90(a,2)
2×2 Matrix{Int64}:
 4  3
 2  1

julia&gt; rotr90(a,3)
2×2 Matrix{Int64}:
 2  4
 1  3

julia&gt; rotr90(a,4)
2×2 Matrix{Int64}:
 1  2
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arraymath.jl#L256-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rotr90-Tuple{AbstractMatrix{T} where T}" href="#Base.rotr90-Tuple{AbstractMatrix{T} where T}"><code>Base.rotr90</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotr90(A)</code></pre><p>Rotate matrix <code>A</code> right 90 degrees.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; rotr90(a)
2×2 Matrix{Int64}:
 3  1
 4  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/arraymath.jl#L162-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.round" href="#Base.round"><code>Base.round</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]])
round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; digits=, base=10)
round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; sigdigits=, base=10)</code></pre><p>Return the nearest integral value of the same type as the complex-valued <code>z</code> to <code>z</code>, breaking ties using the specified <a href="@ref"><code>RoundingMode</code></a>s. The first <a href="@ref"><code>RoundingMode</code></a> is used for rounding the real components while the second is used for rounding the imaginary components.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; round(3.14 + 4.5im)
3.0 + 4.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/complex.jl#L1022-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.round-Tuple{Type, Any}" href="#Base.round-Tuple{Type, Any}"><code>Base.round</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">round([T,] x, [r::RoundingMode])
round(x, [r::RoundingMode]; digits::Integer=0, base = 10)
round(x, [r::RoundingMode]; sigdigits::Integer, base = 10)</code></pre><p>Rounds the number <code>x</code>.</p><p>Without keyword arguments, <code>x</code> is rounded to an integer value, returning a value of type <code>T</code>, or of the same type of <code>x</code> if no <code>T</code> is provided. An <a href="@ref"><code>InexactError</code></a> will be thrown if the value is not representable by <code>T</code>, similar to <a href="#Base.convert"><code>convert</code></a>.</p><p>If the <code>digits</code> keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base <code>base</code>.</p><p>If the <code>sigdigits</code> keyword argument is provided, it rounds to the specified number of significant digits, in base <code>base</code>.</p><p>The <a href="@ref"><code>RoundingMode</code></a> <code>r</code> controls the direction of the rounding; the default is <a href="@ref"><code>RoundNearest</code></a>, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that <code>round</code> may give incorrect results if the global rounding mode is changed (see <a href="@ref"><code>rounding</code></a>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; round(1.7)
2.0

julia&gt; round(Int, 1.7)
2

julia&gt; round(1.5)
2.0

julia&gt; round(2.5)
2.0

julia&gt; round(pi; digits=2)
3.14

julia&gt; round(pi; digits=3, base=2)
3.125

julia&gt; round(123.456; sigdigits=2)
120.0

julia&gt; round(357.913; sigdigits=4, base=2)
352.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Rounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the <a href="@ref"><code>Float64</code></a> value represented by <code>1.15</code> is actually <em>less</em> than 1.15, yet will be rounded to 1.2.</p><h1>Examples</h1><pre><code class="language-julia-repl hljs">julia&gt; x = 1.15
1.15

julia&gt; @sprintf &quot;%.20f&quot; x
&quot;1.14999999999999991118&quot;

julia&gt; x &lt; 115//100
true

julia&gt; round(x, digits=1)
1.2</code></pre></div></div><p><strong>Extensions</strong></p><p>To extend <code>round</code> to new numeric types, it is typically sufficient to define <code>Base.round(x::NewType, r::RoundingMode)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/floatfuncs.jl#L47-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rpad" href="#Base.rpad"><code>Base.rpad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=&#39; &#39;) -&gt; String</code></pre><p>Stringify <code>s</code> and pad the resulting string on the right with <code>p</code> to make it <code>n</code> characters (code points) long. If <code>s</code> is already <code>n</code> characters long, an equal string is returned. Pad with spaces by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rpad(&quot;March&quot;, 20)
&quot;March               &quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L342-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rsplit" href="#Base.rsplit"><code>Base.rsplit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)
rsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)</code></pre><p>Similar to <a href="#Base.split"><code>split</code></a>, but starting from the end of the string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = &quot;M.a.r.c.h&quot;
&quot;M.a.r.c.h&quot;

julia&gt; rsplit(a, &quot;.&quot;)
5-element Vector{SubString{String}}:
 &quot;M&quot;
 &quot;a&quot;
 &quot;r&quot;
 &quot;c&quot;
 &quot;h&quot;

julia&gt; rsplit(a, &quot;.&quot;; limit=1)
1-element Vector{SubString{String}}:
 &quot;M.a.r.c.h&quot;

julia&gt; rsplit(a, &quot;.&quot;; limit=2)
2-element Vector{SubString{String}}:
 &quot;M.a.r.c&quot;
 &quot;h&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L446-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rstrip-Tuple{Any, AbstractString}" href="#Base.rstrip-Tuple{Any, AbstractString}"><code>Base.rstrip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rstrip([pred=isspace,] str::AbstractString) -&gt; SubString
rstrip(str::AbstractString, chars) -&gt; SubString</code></pre><p>Remove trailing characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p><p>The default behaviour is to remove trailing whitespace and delimiters: see <a href="@ref"><code>isspace</code></a> for precise details.</p><p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = rpad(&quot;March&quot;, 20)
&quot;March               &quot;

julia&gt; rstrip(a)
&quot;March&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L255-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.run-Tuple{Base.AbstractCmd, Vararg{Any, N} where N}" href="#Base.run-Tuple{Base.AbstractCmd, Vararg{Any, N} where N}"><code>Base.run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run(command, args...; wait::Bool = true)</code></pre><p>Run a command object, constructed with backticks (see the <a href="@ref">Running External Programs</a> section in the manual). Throws an error if anything goes wrong, including the process exiting with a non-zero status (when <code>wait</code> is true).</p><p>If <code>wait</code> is false, the process runs asynchronously. You can later wait for it and check its exit status by calling <code>success</code> on the returned process object.</p><p>When <code>wait</code> is false, the process&#39; I/O streams are directed to <code>devnull</code>. When <code>wait</code> is true, I/O streams are shared with the parent process. Use <a href="#Base.pipeline-Tuple{Any, Any, Any, Vararg{Any, N} where N}"><code>pipeline</code></a> to control I/O redirection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L423-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.runtests" href="#Base.runtests"><code>Base.runtests</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.runtests(tests=[&quot;all&quot;]; ncores=ceil(Int, Sys.CPU_THREADS / 2),
              exit_on_error=false, revise=false, [seed])</code></pre><p>Run the Julia unit tests listed in <code>tests</code>, which can be either a string or an array of strings, using <code>ncores</code> processors. If <code>exit_on_error</code> is <code>false</code>, when one test fails, all remaining tests in other files will still be run; they are otherwise discarded, when <code>exit_on_error == true</code>. If <code>revise</code> is <code>true</code>, the <code>Revise</code> package is used to load any modifications to <code>Base</code> or to the standard libraries before running the tests. If a seed is provided via the keyword argument, it is used to seed the global RNG in the context where the tests are run; otherwise the seed is chosen randomly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/util.jl#L546-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.schedule-Tuple{Task, Any}" href="#Base.schedule-Tuple{Task, Any}"><code>Base.schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">schedule(t::Task, [val]; error=false)</code></pre><p>Add a <a href="@ref"><code>Task</code></a> to the scheduler&#39;s queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as <a href="#Base.wait-Tuple{Base.GenericCondition}"><code>wait</code></a>.</p><p>If a second argument <code>val</code> is provided, it will be passed to the task (via the return value of <a href="#Base.yieldto-Tuple{Task, Any}"><code>yieldto</code></a>) when it runs again. If <code>error</code> is <code>true</code>, the value is raised as an exception in the woken task.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a5() = sum(i for i in 1:1000);

julia&gt; b = Task(a5);

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskstarted(b)
true

julia&gt; istaskdone(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L606-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.securezero!" href="#Base.securezero!"><code>Base.securezero!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">securezero!(o)</code></pre><p><code>securezero!</code> fills the memory associated with an object <code>o</code> with zeros. Unlike <code>fill!(o,0)</code> and similar code, which might be optimized away by the compiler for objects about to be discarded, the <code>securezero!</code> function will always be called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/util.jl#L201-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.seek-Tuple{IOStream, Integer}" href="#Base.seek-Tuple{IOStream, Integer}"><code>Base.seek</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seek(s, pos)</code></pre><p>Seek a stream to the given position.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization.&quot;);

julia&gt; seek(io, 5);

julia&gt; read(io, Char)
&#39;L&#39;: ASCII/Unicode U+004C (category Lu: Letter, uppercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L112-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.seekend-Tuple{IOStream}" href="#Base.seekend-Tuple{IOStream}"><code>Base.seekend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seekend(s)</code></pre><p>Seek a stream to its end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.seekstart-Tuple{IO}" href="#Base.seekstart-Tuple{IO}"><code>Base.seekstart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">seekstart(s)</code></pre><p>Seek a stream to its beginning.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization.&quot;);

julia&gt; seek(io, 5);

julia&gt; read(io, Char)
&#39;L&#39;: ASCII/Unicode U+004C (category Lu: Letter, uppercase)

julia&gt; seekstart(io);

julia&gt; read(io, Char)
&#39;J&#39;: ASCII/Unicode U+004A (category Lu: Letter, uppercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L134-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.selectdim-Tuple{AbstractArray, Integer, Any}" href="#Base.selectdim-Tuple{AbstractArray, Integer, Any}"><code>Base.selectdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selectdim(A, d::Integer, i)</code></pre><p>Return a view of all the data of <code>A</code> where the index for dimension <code>d</code> equals <code>i</code>.</p><p>Equivalent to <code>view(A,:,:,...,i,:,:,...)</code> where <code>i</code> is in position <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2 3 4; 5 6 7 8]
2×4 Matrix{Int64}:
 1  2  3  4
 5  6  7  8

julia&gt; selectdim(A, 2, 3)
2-element view(::Matrix{Int64}, :, 3) with eltype Int64:
 3
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarraymath.jl#L102-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setdiff!-Tuple{AbstractSet, Vararg{Any, N} where N}" href="#Base.setdiff!-Tuple{AbstractSet, Vararg{Any, N} where N}"><code>Base.setdiff!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setdiff!(s, itrs...)</code></pre><p>Remove from set <code>s</code> (in-place) each element of each iterable from <code>itrs</code>. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Set([1, 3, 4, 5]);

julia&gt; setdiff!(a, 1:2:6);

julia&gt; a
Set{Int64} with 1 element:
  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L163-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setdiff-Tuple{AbstractSet, Vararg{Any, N} where N}" href="#Base.setdiff-Tuple{AbstractSet, Vararg{Any, N} where N}"><code>Base.setdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setdiff(s, itrs...)</code></pre><p>Construct the set of elements in <code>s</code> but not in any of the iterables in <code>itrs</code>. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; setdiff([1,2,3], [3,4,5])
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L146-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setenv-Tuple{Cmd, Any}" href="#Base.setenv-Tuple{Cmd, Any}"><code>Base.setenv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setenv(command::Cmd, env; dir=&quot;&quot;)</code></pre><p>Set environment variables to use when running the given <code>command</code>. <code>env</code> is either a dictionary mapping strings to strings, an array of strings of the form <code>&quot;var=val&quot;</code>, or zero or more <code>&quot;var&quot;=&gt;val</code> pair arguments. In order to modify (rather than replace) the existing environment, create <code>env</code> through <code>copy(ENV)</code> and then setting <code>env[&quot;var&quot;]=val</code> as desired, or use <code>addenv</code>.</p><p>The <code>dir</code> keyword argument can be used to specify a working directory for the command.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/cmd.jl#L232-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!" href="#Base.setindex!"><code>Base.setindex!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setindex!(collection, value, key...)</code></pre><p>Store the given value at the given key or index within a collection. The syntax <code>a[i,j,...] = x</code> is converted by the compiler to <code>(setindex!(a, x, i, j, ...); x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L831-L836">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractArray, Any, Vararg{Any, N} where N}" href="#Base.setindex!-Tuple{AbstractArray, Any, Vararg{Any, N} where N}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(A, X, inds...)
A[inds...] = X</code></pre><p>Store values from array <code>X</code> within some subset of <code>A</code> as specified by <code>inds</code>. The syntax <code>A[inds...] = X</code> is equivalent to <code>(setindex!(A, X, inds...); X)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(2,2);

julia&gt; setindex!(A, [10, 20], [1, 2]);

julia&gt; A[[3, 4]] = [30, 40];

julia&gt; A
2×2 Matrix{Float64}:
 10.0  30.0
 20.0  40.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1243-L1263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex-Tuple{NamedTuple, Any, Symbol}" href="#Base.setindex-Tuple{NamedTuple, Any, Symbol}"><code>Base.setindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex(nt::NamedTuple, val, key::Symbol)</code></pre><p>Constructs a new <code>NamedTuple</code> with the key <code>key</code> set to <code>val</code>. If <code>key</code> is already in the keys of <code>nt</code>, <code>val</code> replaces the old value.</p><pre><code class="language-julia-repl hljs">julia&gt; nt = (a = 3,)
(a = 3,)

julia&gt; Base.setindex(nt, 33, :b)
(a = 3, b = 33)

julia&gt; Base.setindex(nt, 4, :a)
(a = 4,)

julia&gt; Base.setindex(nt, &quot;a&quot;, :a)
(a = &quot;a&quot;,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/namedtuple.jl#L335-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex-Tuple{Tuple, Any, Integer}" href="#Base.setindex-Tuple{Tuple, Any, Integer}"><code>Base.setindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex(c::Tuple, v, i::Integer)</code></pre><p>Creates a new tuple similar to <code>x</code> with the value at index <code>i</code> set to <code>v</code>. Throws a <code>BoundsError</code> when out of bounds.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.setindex((1, 2, 6), 2, 3) == (1, 2, 2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/tuple.jl#L37-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.shell_escape-Tuple{Vararg{AbstractString, N} where N}" href="#Base.shell_escape-Tuple{Vararg{AbstractString, N} where N}"><code>Base.shell_escape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shell_escape(args::Union{Cmd,AbstractString...}; special::AbstractString=&quot;&quot;)</code></pre><p>The unexported <code>shell_escape</code> function is the inverse of the unexported <code>shell_split</code> function: it takes a string or command object and escapes any special characters in such a way that calling <code>shell_split</code> on it would give back the array of words in the original command. The <code>special</code> keyword argument controls what characters in addition to whitespace, backslashes, quotes and dollar signs are considered to be special (default: none).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.shell_escape(&quot;cat&quot;, &quot;/foo/bar baz&quot;, &quot;&amp;&amp;&quot;, &quot;echo&quot;, &quot;done&quot;)
&quot;cat &#39;/foo/bar baz&#39; &amp;&amp; echo done&quot;

julia&gt; Base.shell_escape(&quot;echo&quot;, &quot;this&quot;, &quot;&amp;&amp;&quot;, &quot;that&quot;)
&quot;echo this &amp;&amp; that&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/shell.jl#L174-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.shell_escape_posixly-Tuple{Vararg{AbstractString, N} where N}" href="#Base.shell_escape_posixly-Tuple{Vararg{AbstractString, N} where N}"><code>Base.shell_escape_posixly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shell_escape_posixly(args::Union{Cmd,AbstractString...})</code></pre><p>The unexported <code>shell_escape_posixly</code> function takes a string or command object and escapes any special characters in such a way that it is safe to pass it as an argument to a posix shell.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.shell_escape_posixly(&quot;cat&quot;, &quot;/foo/bar baz&quot;, &quot;&amp;&amp;&quot;, &quot;echo&quot;, &quot;done&quot;)
&quot;cat &#39;/foo/bar baz&#39; &#39;&amp;&amp;&#39; echo done&quot;

julia&gt; Base.shell_escape_posixly(&quot;echo&quot;, &quot;this&quot;, &quot;&amp;&amp;&quot;, &quot;that&quot;)
&quot;echo this &#39;&amp;&amp;&#39; that&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/shell.jl#L235-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.shell_escape_wincmd-Tuple{IO, AbstractString}" href="#Base.shell_escape_wincmd-Tuple{IO, AbstractString}"><code>Base.shell_escape_wincmd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shell_escape_wincmd(s::AbstractString)
shell_escape_wincmd(io::IO, s::AbstractString)</code></pre><p>The unexported <code>shell_escape_wincmd</code> function escapes Windows <code>cmd.exe</code> shell meta characters. It escapes <code>()!^&lt;&gt;&amp;|</code> by placing a <code>^</code> in front. An <code>@</code> is only escaped at the start of the string. Pairs of <code>&quot;</code> characters and the strings they enclose are passed through unescaped. Any remaining <code>&quot;</code> is escaped with <code>^</code> to ensure that the number of unescaped <code>&quot;</code> characters in the result remains even.</p><p>Since <code>cmd.exe</code> substitutes variable references (like <code>%USER%</code>) <em>before</em> processing the escape characters <code>^</code> and <code>&quot;</code>, this function makes no attempt to escape the percent sign (<code>%</code>), the presence of <code>%</code> in the input may cause severe breakage, depending on where the result is used.</p><p>Input strings with ASCII control characters that cannot be escaped (NUL, CR, LF) will cause an <code>ArgumentError</code> exception.</p><p>The result is safe to pass as an argument to a command call being processed by <code>CMD.exe /S /C &quot; ... &quot;</code> (with surrounding double-quote pair) and will be received verbatim by the target application if the input does not contain <code>%</code> (else this function will fail with an ArgumentError). The presence of <code>%</code> in the input string may result in command injection vulnerabilities and may invalidate any claim of suitability of the output of this function for use as an argument to cmd (due to the ordering described above), so use caution when assembling a string from various sources.</p><p>This function may be useful in concert with the <code>windows_verbatim</code> flag to <a href="#Base.Cmd"><code>Cmd</code></a> when constructing process pipelines.</p><pre><code class="language-julia hljs">wincmd(c::String) =
   run(Cmd(Cmd([&quot;cmd.exe&quot;, &quot;/s /c &quot; $c &quot;&quot;]);
           windows_verbatim=true))
wincmd_echo(s::String) =
   wincmd(&quot;echo &quot; * Base.shell_escape_wincmd(s))
wincmd_echo(&quot;hello $(ENV[&quot;USERNAME&quot;]) &amp; the &quot;whole&quot; world! (=^I^=)&quot;)</code></pre><p>But take note that if the input string <code>s</code> contains a <code>%</code>, the argument list and echo&#39;ed text may get corrupted, resulting in arbitrary command execution. The argument can alternatively be passed as an environment variable, which avoids the problem with <code>%</code> and the need for the <code>windows_verbatim</code> flag:</p><pre><code class="language-julia hljs">cmdargs = Base.shell_escape_wincmd(&quot;Passing args with %cmdargs% works 100%!&quot;)
run(setenv(`cmd /C echo %cmdargs%`, &quot;cmdargs&quot; =&gt; cmdargs))</code></pre><p>!warning     The argument parsing done by CMD when calling batch files (either inside     <code>.bat</code> files or as arguments to them) is not fully compatible with the     output of this function. In particular, the processing of <code>%</code> is different.</p><p>!important     Due to a peculiar behavior of the CMD parser/interpreter, each command     after a literal <code>|</code> character (indicating a command pipeline) must have     <code>shell_escape_wincmd</code> applied twice since it will be parsed twice by CMD.     This implies ENV variables would also be expanded twice!     For example:</p><pre><code class="language-julia hljs">    to_print = &quot;All for 1 &amp; 1 for all!&quot;
    to_print_esc = Base.shell_escape_wincmd(Base.shell_escape_wincmd(to_print))
    run(Cmd(Cmd([&quot;cmd&quot;, &quot;/S /C &quot; break | echo $(to_print_esc) &quot;&quot;]), windows_verbatim=true))
    ```

With an I/O stream parameter `io`, the result will be written there,
rather than returned as a string.

See also: [`escape_microsoft_c_args`](@ref), [`shell_escape_posixly`](@ref)

# Example</code></pre><p>jldoctest julia&gt; Base.shell<em>escape</em>wincmd(&quot;a^\&quot;^o\&quot;^u\&quot;&quot;) &quot;a^^\&quot;^o\&quot;^^u^\&quot;&quot; ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/shell.jl#L255-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, Any}" href="#Base.show-Tuple{IO, Any}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show([io::IO = stdout], x)</code></pre><p>Write a text representation of a value <code>x</code> to the output stream <code>io</code>. New types <code>T</code> should overload <code>show(io::IO, x::T)</code>. The representation used by <code>show</code> generally includes Julia-specific formatting and type information, and should be parseable Julia code when possible.</p><p><a href="#Base.repr-Tuple{Any}"><code>repr</code></a> returns the output of <code>show</code> as a string.</p><p>To customize human-readable text output for objects of type <code>T</code>, define <code>show(io::IO, ::MIME&quot;text/plain&quot;, ::T)</code> instead. Checking the <code>:compact</code> <a href="#Base.IOContext"><code>IOContext</code></a> property of <code>io</code> in such methods is recommended, since some containers show their elements by calling this method with <code>:compact =&gt; true</code>.</p><p>See also <a href="#Base.print-Tuple{IO, Any}"><code>print</code></a>, which writes un-decorated representations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; show(&quot;Hello World!&quot;)
&quot;Hello World!&quot;
julia&gt; print(&quot;Hello World!&quot;)
Hello World!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L364-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show_invalid" href="#Base.show_invalid"><code>Base.show_invalid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">show_invalid(io::IO, c::AbstractChar)</code></pre><p>Called by <code>show(io, c)</code> when <a href="#Base.isoverlong-Tuple{AbstractChar}"><code>isoverlong(c)</code></a> or <a href="#Base.ismalformed-Tuple{AbstractChar}"><code>ismalformed(c)</code></a> return <code>true</code>.   Subclasses of <code>AbstractChar</code> should define <code>Base.show_invalid</code> methods if they support storing invalid character data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/char.jl#L249-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.showarg-Tuple{IO, Type, Any}" href="#Base.showarg-Tuple{IO, Type, Any}"><code>Base.showarg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">showarg(io::IO, x, toplevel)</code></pre><p>Show <code>x</code> as if it were an argument to a function. This function is used by <a href="#Base.summary-Tuple{IO, Any}"><code>summary</code></a> to display type information in terms of sequences of function calls on objects. <code>toplevel</code> is <code>true</code> if this is the direct call from <code>summary</code> and <code>false</code> for nested (recursive) calls.</p><p>The fallback definition is to print <code>x</code> as &quot;::<span>$</span>(typeof(x))&quot;, representing argument <code>x</code> in terms of its type. (The double-colon is omitted if <code>toplevel=true</code>.) However, you can specialize this function for specific types to customize printing.</p><p><strong>Example</strong></p><p>A SubArray created as <code>view(a, :, 3, 2:5)</code>, where <code>a</code> is a 3-dimensional Float64 array, has type</p><pre><code class="nohighlight hljs">SubArray{Float64, 2, Array{Float64, 3}, Tuple{Colon, Int64, UnitRange{Int64}}, false}</code></pre><p>The default <code>show</code> printing would display this full type. However, the summary for SubArrays actually prints as</p><pre><code class="nohighlight hljs">2×4 view(::Array{Float64, 3}, :, 3, 2:5) with eltype Float64</code></pre><p>because of a definition similar to</p><pre><code class="nohighlight hljs">function Base.showarg(io::IO, v::SubArray, toplevel)
    print(io, &quot;view(&quot;)
    showarg(io, parent(v), false)
    print(io, &quot;, &quot;, join(v.indices, &quot;, &quot;))
    print(io, &#39;)&#39;)
    toplevel &amp;&amp; print(io, &quot; with eltype &quot;, eltype(v))
end</code></pre><p>Note that we&#39;re calling <code>showarg</code> recursively for the parent array type, indicating that any recursed calls are not at the top level. Printing the parent as <code>::Array{Float64,3}</code> is the fallback (non-toplevel) behavior, because no specialized method for <code>Array</code> has been defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L2662-L2701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.showerror-Tuple{IO, Any}" href="#Base.showerror-Tuple{IO, Any}"><code>Base.showerror</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">showerror(io, e)</code></pre><p>Show a descriptive representation of an exception object <code>e</code>. This method is used to display the exception after a call to <a href="#Core.throw"><code>throw</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct MyException &lt;: Exception
           msg::AbstractString
       end

julia&gt; function Base.showerror(io::IO, err::MyException)
           print(io, &quot;MyException: &quot;)
           print(io, err.msg)
       end

julia&gt; err = MyException(&quot;test exception&quot;)
MyException(&quot;test exception&quot;)

julia&gt; sprint(showerror, err)
&quot;MyException: test exception&quot;

julia&gt; throw(MyException(&quot;test exception&quot;))
ERROR: MyException: test exception</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/errorshow.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Tuple{Number}" href="#Base.sign-Tuple{Number}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(x)</code></pre><p>Return zero if <code>x==0</code> and <span>$x/|x|$</span> otherwise (i.e., ±1 for real <code>x</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.signbit-Tuple{Real}" href="#Base.signbit-Tuple{Real}"><code>Base.signbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signbit(x)</code></pre><p>Returns <code>true</code> if the value of the sign of <code>x</code> is negative, otherwise <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; signbit(-4)
true

julia&gt; signbit(5)
false

julia&gt; signbit(5.5)
false

julia&gt; signbit(-4.1)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L108-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.signed-Tuple{Any}" href="#Base.signed-Tuple{Any}"><code>Base.signed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signed(x)</code></pre><p>Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L192-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.signed-Tuple{Type{Bool}}" href="#Base.signed-Tuple{Type{Bool}}"><code>Base.signed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signed(T::Integer)</code></pre><p>Convert an integer bitstype to the signed type of the same size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; signed(UInt16)
Int16
julia&gt; signed(UInt64)
Int64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T" href="#Base.similar-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T"><code>Base.similar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">similar(array, [element_type=eltype(array)], [dims=size(array)])</code></pre><p>Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array&#39;s <code>eltype</code> and <code>size</code>. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.</p><p>Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an <code>Array{element_type}(undef, dims...)</code>.</p><p>For example, <code>similar(1:10, 1, 4)</code> returns an uninitialized <code>Array{Int,2}</code> since ranges are neither mutable nor support 2 dimensions:</p><pre><code class="language-julia-repl hljs">julia&gt; similar(1:10, 1, 4)
1×4 Array{Int64,2}:
 4419743872  4374413872  4419743888  0</code></pre><p>Conversely, <code>similar(trues(10,10), 2)</code> returns an uninitialized <code>BitVector</code> with two elements since <code>BitArray</code>s are both mutable and can support 1-dimensional arrays:</p><pre><code class="language-julia-repl hljs">julia&gt; similar(trues(10,10), 2)
2-element BitVector:
 0
 0</code></pre><p>Since <code>BitArray</code>s can only store elements of type <a href="@ref"><code>Bool</code></a>, however, if you request a different element type it will create a regular <code>Array</code> instead:</p><pre><code class="language-julia-repl hljs">julia&gt; similar(falses(10), Float64, 2, 4)
2×4 Array{Float64,2}:
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L696-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar-Union{Tuple{T}, Tuple{Type{T}, Vararg{Union{Integer, AbstractUnitRange}, N} where N}} where T&lt;:AbstractArray" href="#Base.similar-Union{Tuple{T}, Tuple{Type{T}, Vararg{Union{Integer, AbstractUnitRange}, N} where N}} where T&lt;:AbstractArray"><code>Base.similar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">similar(storagetype, axes)</code></pre><p>Create an uninitialized mutable array analogous to that specified by <code>storagetype</code>, but with <code>axes</code> specified by the last argument.</p><p><strong>Examples</strong>:</p><pre><code class="nohighlight hljs">similar(Array{Int}, axes(A))</code></pre><p>creates an array that &quot;acts like&quot; an <code>Array{Int}</code> (and might indeed be backed by one), but which is indexed identically to <code>A</code>. If <code>A</code> has conventional indexing, this will be identical to <code>Array{Int}(undef, size(A))</code>, but if <code>A</code> has unconventional indexing then the indices of the result will match <code>A</code>.</p><pre><code class="nohighlight hljs">similar(BitArray, (axes(A, 2),))</code></pre><p>would create a 1-dimensional logical array whose indices match those of the columns of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L761-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}" href="#Base.size-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(A::AbstractArray, [dim])</code></pre><p>Return a tuple containing the dimensions of <code>A</code>. Optionally you can specify a dimension to just get the length of that dimension.</p><p>Note that <code>size</code> may not be defined for arrays with non-standard indices, in which case <a href="#Base.axes-Tuple{Any}"><code>axes</code></a> may be useful. See the manual chapter on <a href="@ref man-custom-indices">arrays with custom indices</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (2,3,4));

julia&gt; size(A)
(2, 3, 4)

julia&gt; size(A, 2)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L18-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sizehint!" href="#Base.sizehint!"><code>Base.sizehint!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sizehint!(s, n)</code></pre><p>Suggest that collection <code>s</code> reserve capacity for at least <code>n</code> elements. This can improve performance.</p><p><strong>Notes on the performance model</strong></p><p>For types that support <code>sizehint!</code>,</p><ol><li><code>push!</code> and <code>append!</code> methods generally may (but are not required to) preallocate extra</li></ol><p>storage. For types implemented in <code>Base</code>, they typically do, using a heuristic optimized for a general use case.</p><ol><li><code>sizehint!</code> may control this preallocation. Again, it typically does this for types in</li></ol><p><code>Base</code>.</p><ol><li><code>empty!</code> is nearly costless (and O(1)) for types that support this kind of preallocation.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1114-L1131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sizeof-Tuple{AbstractString}" href="#Base.sizeof-Tuple{AbstractString}"><code>Base.sizeof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sizeof(str::AbstractString)</code></pre><p>Size, in bytes, of the string <code>str</code>. Equal to the number of code units in <code>str</code> multiplied by the size, in bytes, of one code unit in <code>str</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sizeof(&quot;&quot;)
0

julia&gt; sizeof(&quot;∀&quot;)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L164-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sizeof-Tuple{Any}" href="#Base.sizeof-Tuple{Any}"><code>Base.sizeof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sizeof(T::DataType)
sizeof(obj)</code></pre><p>Size, in bytes, of the canonical binary representation of the given <code>DataType</code> <code>T</code>, if any. Size, in bytes, of object <code>obj</code> if it is not <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sizeof(Float32)
4

julia&gt; sizeof(ComplexF64)
16

julia&gt; sizeof(1.0)
8

julia&gt; sizeof([1.0:10.0;])
80</code></pre><p>If <code>DataType</code> <code>T</code> does not have a specific size, an error is thrown.</p><pre><code class="language-julia-repl hljs">julia&gt; sizeof(AbstractArray)
ERROR: Abstract type AbstractArray does not have a definite size.
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L424-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.skip-Tuple{IOStream, Integer}" href="#Base.skip-Tuple{IOStream, Integer}"><code>Base.skip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">skip(s, offset)</code></pre><p>Seek a stream relative to the current position.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer(&quot;JuliaLang is a GitHub organization.&quot;);

julia&gt; seek(io, 5);

julia&gt; skip(io, 10);

julia&gt; read(io, Char)
&#39;G&#39;: ASCII/Unicode U+0047 (category Lu: Letter, uppercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L167-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.skipchars-Tuple{Any, IO}" href="#Base.skipchars-Tuple{Any, IO}"><code>Base.skipchars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">skipchars(predicate, io::IO; linecomment=nothing)</code></pre><p>Advance the stream <code>io</code> such that the next-read character will be the first remaining for which <code>predicate</code> returns <code>false</code>. If the keyword argument <code>linecomment</code> is specified, all characters from that character until the start of the next line are ignored.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; buf = IOBuffer(&quot;    text&quot;)
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=1, mark=-1)

julia&gt; skipchars(isspace, buf)
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=5, mark=-1)

julia&gt; String(readavailable(buf))
&quot;text&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L1120-L1138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.skipmissing-Tuple{Any}" href="#Base.skipmissing-Tuple{Any}"><code>Base.skipmissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">skipmissing(itr)</code></pre><p>Return an iterator over the elements in <code>itr</code> skipping <a href="#Base.missing"><code>missing</code></a> values. The returned object can be indexed using indices of <code>itr</code> if the latter is indexable. Indices corresponding to missing values are not valid: they are skipped by <a href="#Base.keys"><code>keys</code></a> and <a href="#Base.eachindex-Tuple{AbstractArray}"><code>eachindex</code></a>, and a <code>MissingException</code> is thrown when trying to use them.</p><p>Use <a href="#Base.collect-Tuple{Any}"><code>collect</code></a> to obtain an <code>Array</code> containing the non-<code>missing</code> values in <code>itr</code>. Note that even if <code>itr</code> is a multidimensional array, the result will always be a <code>Vector</code> since it is not possible to remove missings while preserving dimensions of the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = skipmissing([1, missing, 2])
skipmissing(Union{Missing, Int64}[1, missing, 2])

julia&gt; sum(x)
3

julia&gt; x[1]
1

julia&gt; x[2]
ERROR: MissingException: the value at index (2,) is missing
[...]

julia&gt; argmax(x)
3

julia&gt; collect(keys(x))
2-element Vector{Int64}:
 1
 3

julia&gt; collect(skipmissing([1, missing, 2]))
2-element Vector{Int64}:
 1
 2

julia&gt; collect(skipmissing([1 missing; 2 missing]))
2-element Vector{Int64}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/missing.jl#L184-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sleep-Tuple{Real}" href="#Base.sleep-Tuple{Real}"><code>Base.sleep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sleep(seconds)</code></pre><p>Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of <code>0.001</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/asyncevent.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.something" href="#Base.something"><code>Base.something</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">something(x, y...)</code></pre><p>Return the first value in the arguments which is not equal to <a href="@ref"><code>nothing</code></a>, if any. Otherwise throw an error. Arguments of type <a href="#Base.Some"><code>Some</code></a> are unwrapped.</p><p>See also <a href="#Base.coalesce"><code>coalesce</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; something(nothing, 1)
1

julia&gt; something(Some(1), nothing)
1

julia&gt; something(missing, nothing)
missing

julia&gt; something(nothing, nothing)
ERROR: ArgumentError: No value arguments present</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/some.jl#L70-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sortslices-Tuple{AbstractArray}" href="#Base.sortslices-Tuple{AbstractArray}"><code>Base.sortslices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)</code></pre><p>Sort slices of an array <code>A</code>. The required keyword argument <code>dims</code> must be either an integer or a tuple of integers. It specifies the dimension(s) over which the slices are sorted.</p><p>E.g., if <code>A</code> is a matrix, <code>dims=1</code> will sort rows, <code>dims=2</code> will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.</p><p>For the remaining keyword arguments, see the documentation of <a href="@ref"><code>sort!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows
3×3 Matrix{Int64}:
 -1   6  4
  7   3  5
  9  -2  8

julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)-&gt;isless(x[2],y[2]))
3×3 Matrix{Int64}:
  9  -2  8
  7   3  5
 -1   6  4

julia&gt; sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)
3×3 Matrix{Int64}:
  9  -2  8
  7   3  5
 -1   6  4

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns
3×3 Matrix{Int64}:
  3   5  7
 -1  -4  6
 -2   8  9

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)-&gt;isless(x[2],y[2]))
3×3 Matrix{Int64}:
  5   3  7
 -4  -1  6
  8  -2  9

julia&gt; sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)
3×3 Matrix{Int64}:
 7   5   3
 6  -4  -1
 9   8  -2</code></pre><p><strong>Higher dimensions</strong></p><p><code>sortslices</code> extends naturally to higher dimensions. E.g., if <code>A</code> is a a 2x2x2 array, <code>sortslices(A, dims=3)</code> will sort slices within the 3rd dimension, passing the 2x2 slices <code>A[:, :, 1]</code> and <code>A[:, :, 2]</code> to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the <code>by</code> or <code>lt</code> keyword argument to specify such an order.</p><p>If <code>dims</code> is a tuple, the order of the dimensions in <code>dims</code> is relevant and specifies the linear order of the slices. E.g., if <code>A</code> is three dimensional and <code>dims</code> is <code>(1, 2)</code>, the orderings of the first two dimensions are re-arranged such that the slices (of the remaining third dimension) are sorted. If <code>dims</code> is <code>(2, 1)</code> instead, the same slices will be taken, but the result order will be row-major instead.</p><p><strong>Higher dimensional examples</strong></p><pre><code class="nohighlight hljs">julia&gt; A = permutedims(reshape([4 3; 2 1; &#39;A&#39; &#39;B&#39;; &#39;C&#39; &#39;D&#39;], (2, 2, 2)), (1, 3, 2))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 4  3
 2  1

[:, :, 2] =
 &#39;A&#39;  &#39;B&#39;
 &#39;C&#39;  &#39;D&#39;

julia&gt; sortslices(A, dims=(1,2))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 1  3
 2  4

[:, :, 2] =
 &#39;D&#39;  &#39;B&#39;
 &#39;C&#39;  &#39;A&#39;

julia&gt; sortslices(A, dims=(2,1))
2×2×2 Array{Any, 3}:
[:, :, 1] =
 1  2
 3  4

[:, :, 2] =
 &#39;D&#39;  &#39;C&#39;
 &#39;B&#39;  &#39;A&#39;

julia&gt; sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x-&gt;x[1,1])
1×1×5 Array{Int64, 3}:
[:, :, 1] =
 1

[:, :, 2] =
 2

[:, :, 3] =
 3

[:, :, 4] =
 4

[:, :, 5] =
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/multidimensional.jl#L1747-L1863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.splat-Tuple{Any}" href="#Base.splat-Tuple{Any}"><code>Base.splat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splat(f)</code></pre><p>Defined as</p><pre><code class="language-julia hljs">    splat(f) = args-&gt;f(args...)</code></pre><p>i.e. given a function returns a new function that takes one argument and splats its argument into the original function. This is useful as an adaptor to pass a multi-argument function in a context that expects a single argument, but passes a tuple as that single argument.</p><p><strong>Example usage:</strong></p><pre><code class="language-julia-repl hljs">julia&gt; map(Base.splat(+), zip(1:3,4:6))
3-element Vector{Int64}:
 5
 7
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L1091-L1111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.splice!" href="#Base.splice!"><code>Base.splice!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splice!(a::Vector, index::Integer, [replacement]) -&gt; item</code></pre><p>Remove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)
2

julia&gt; A
5-element Vector{Int64}:
 6
 5
 4
 3
 1

julia&gt; splice!(A, 5, -1)
1

julia&gt; A
5-element Vector{Int64}:
  6
  5
  4
  3
 -1

julia&gt; splice!(A, 1, [-1, -2, -3])
6

julia&gt; A
7-element Vector{Int64}:
 -1
 -2
 -3
  5
  4
  3
 -1</code></pre><p>To insert <code>replacement</code> before an index <code>n</code> without removing any items, use <code>splice!(collection, n:n-1, replacement)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1431-L1479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.splice!" href="#Base.splice!"><code>Base.splice!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">splice!(a::Vector, indices, [replacement]) -&gt; items</code></pre><p>Remove items at specified indices, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gaps. If specified, replacement values from an ordered collection will be spliced in place of the removed items; in this case, <code>indices</code> must be a <code>UnitRange</code>.</p><p>To insert <code>replacement</code> before an index <code>n</code> without removing any items, use <code>splice!(collection, n:n-1, replacement)</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Prior to Julia 1.5, <code>indices</code> must always be a <code>UnitRange</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [-1, -2, -3, 5, 4, 3, -1]; splice!(A, 4:3, 2)
Int64[]

julia&gt; A
8-element Vector{Int64}:
 -1
 -2
 -3
  2
  5
  4
  3
 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L1498-L1529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.split" href="#Base.split"><code>Base.split</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)
split(str::AbstractString; limit::Integer=0, keepempty::Bool=false)</code></pre><p>Split <code>str</code> into an array of substrings on occurrences of the delimiter(s) <code>dlm</code>.  <code>dlm</code> can be any of the formats allowed by <a href="#Base.findnext-Tuple{AbstractChar, AbstractString, Integer}"><code>findnext</code></a>&#39;s first argument (i.e. as a string, regular expression or a function), or as a single character or collection of characters.</p><p>If <code>dlm</code> is omitted, it defaults to <a href="@ref"><code>isspace</code></a>.</p><p>The optional keyword arguments are:</p><ul><li><code>limit</code>: the maximum size of the result. <code>limit=0</code> implies no maximum (default)</li><li><code>keepempty</code>: whether empty fields should be kept in the result. Default is <code>false</code> without a <code>dlm</code> argument, <code>true</code> with a <code>dlm</code> argument.</li></ul><p>See also <a href="#Base.rsplit"><code>rsplit</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = &quot;Ma.rch&quot;
&quot;Ma.rch&quot;

julia&gt; split(a, &quot;.&quot;)
2-element Vector{SubString{String}}:
 &quot;Ma&quot;
 &quot;rch&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L370-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.splitprec-Union{Tuple{F}, Tuple{Type{F}, Integer}} where F&lt;:AbstractFloat" href="#Base.splitprec-Union{Tuple{F}, Tuple{Type{F}, Integer}} where F&lt;:AbstractFloat"><code>Base.splitprec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hi, lo = splitprec(F::Type{&lt;:AbstractFloat}, i::Integer)</code></pre><p>Represent an integer <code>i</code> as a pair of floating-point numbers <code>hi</code> and <code>lo</code> (of type <code>F</code>) such that:</p><ul><li><code>widen(hi) + widen(lo) ≈ i</code>. It is exact if 1.5 * (number of precision bits in <code>F</code>) is greater than the number of bits in <code>i</code>.</li><li>all bits in <code>hi</code> are more significant than any of the bits in <code>lo</code></li><li><code>hi</code> can be exactly multiplied by the <code>hi</code> component of another call to <code>splitprec</code>.</li></ul><p>In particular, while <code>convert(Float64, i)</code> can be lossy since Float64 has only 53 bits of precision, <code>splitprec(Float64, i)</code> is exact for any Int64/UInt64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/twiceprecision.jl#L9-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sprint-Tuple{Function, Vararg{Any, N} where N}" href="#Base.sprint-Tuple{Function, Vararg{Any, N} where N}"><code>Base.sprint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sprint(f::Function, args...; context=nothing, sizehint=0)</code></pre><p>Call the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. <code>context</code> can be either an <a href="#Base.IOContext"><code>IOContext</code></a> whose properties will be used, or a <code>Pair</code> specifying a property and its value. <code>sizehint</code> suggests the capacity of the buffer (in bytes).</p><p>The optional keyword argument <code>context</code> can be set to <code>:key=&gt;value</code> pair or an <code>IO</code> or <a href="#Base.IOContext"><code>IOContext</code></a> object whose attributes are used for the I/O stream passed to <code>f</code>.  The optional <code>sizehint</code> is a suggested size (in bytes) to allocate for the buffer used to write the string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sprint(show, 66.66666; context=:compact =&gt; true)
&quot;66.6667&quot;

julia&gt; sprint(showerror, BoundsError([1], 100))
&quot;BoundsError: attempt to access 1-element Vector{Int64} at index [100]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L77-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.startswith-Tuple{AbstractString, AbstractString}" href="#Base.startswith-Tuple{AbstractString, AbstractString}"><code>Base.startswith</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">startswith(s::AbstractString, prefix::AbstractString)</code></pre><p>Return <code>true</code> if <code>s</code> starts with <code>prefix</code>. If <code>prefix</code> is a vector or set of characters, test whether the first character of <code>s</code> belongs to that set.</p><p>See also <a href="#Base.endswith-Tuple{AbstractString, AbstractString}"><code>endswith</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; startswith(&quot;JuliaLang&quot;, &quot;Julia&quot;)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L7-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.startswith-Tuple{AbstractString, Regex}" href="#Base.startswith-Tuple{AbstractString, Regex}"><code>Base.startswith</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">startswith(s::AbstractString, prefix::Regex)</code></pre><p>Return <code>true</code> if <code>s</code> starts with the regex pattern, <code>prefix</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>startswith</code> does not compile the anchoring into the regular expression, but instead passes the anchoring as <code>match_option</code> to PCRE. If compile time is amortized, <code>occursin(r&quot;^...&quot;, s)</code> is faster than <code>startswith(s, r&quot;...&quot;)</code>.</p></div></div><p>See also <a href="#Base.occursin-Tuple{Any}"><code>occursin</code></a> and <a href="#Base.endswith-Tuple{AbstractString, AbstractString}"><code>endswith</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This method requires at least Julia 1.2.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; startswith(&quot;JuliaLang&quot;, r&quot;Julia|Romeo&quot;)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L202-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.startswith-Tuple{Any}" href="#Base.startswith-Tuple{Any}"><code>Base.startswith</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">startswith(prefix)</code></pre><p>Create a function that checks whether its argument starts with <code>prefix</code>, i.e. a function equivalent to <code>y -&gt; startswith(y, prefix)</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(startswith)}</code>, which can be used to implement specialized methods.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The single argument <code>startswith(prefix)</code> requires at least Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; startswith_julia = startswith(&quot;Julia&quot;);

julia&gt; startswith_julia(&quot;Julia&quot;)
true

julia&gt; startswith_julia(&quot;NotJulia&quot;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L125-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.step-Tuple{StepRange}" href="#Base.step-Tuple{StepRange}"><code>Base.step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step(r)</code></pre><p>Get the step size of an <a href="#Base.AbstractRange"><code>AbstractRange</code></a> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; step(1:10)
1

julia&gt; step(1:2:10)
2

julia&gt; step(2.5:0.3:10.9)
0.3

julia&gt; step(range(2.5, stop=10.9, length=85))
0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/range.jl#L523-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.stride-Tuple{AbstractArray, Integer}" href="#Base.stride-Tuple{AbstractArray, Integer}"><code>Base.stride</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stride(A, k::Integer)</code></pre><p>Return the distance in memory (in number of elements) between adjacent elements in dimension <code>k</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (3,4,5));

julia&gt; stride(A,2)
3

julia&gt; stride(A,3)
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L484-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.strides" href="#Base.strides"><code>Base.strides</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strides(A)</code></pre><p>Return a tuple of the memory strides in each dimension.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = fill(1, (3,4,5));

julia&gt; strides(A)
(1, 3, 12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L469-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.string-Tuple" href="#Base.string-Tuple"><code>Base.string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">string(xs...)</code></pre><p>Create a string from any values using the <a href="#Base.print-Tuple{IO, Any}"><code>print</code></a> function.</p><p><code>string</code> should usually not be defined directly. Instead, define a method <code>print(io::IO, x::MyType)</code>. If <code>string(x)</code> for a certain type needs to be highly efficient, then it may make sense to add a method to <code>string</code> and define <code>print(io::IO, x::MyType) = print(io, string(x))</code> to ensure the functions are consistent.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; string(&quot;a&quot;, 1, true)
&quot;a1true&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L157-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.string-Tuple{Integer}" href="#Base.string-Tuple{Integer}"><code>Base.string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">string(n::Integer; base::Integer = 10, pad::Integer = 1)</code></pre><p>Convert an integer <code>n</code> to a string in the given <code>base</code>, optionally specifying a number of digits to pad to.</p><pre><code class="language-julia-repl hljs">julia&gt; string(5, base = 13, pad = 4)
&quot;0005&quot;

julia&gt; string(13, base = 5, pad = 4)
&quot;0023&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/intfuncs.jl#L747-L760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.strip-Tuple{AbstractString}" href="#Base.strip-Tuple{AbstractString}"><code>Base.strip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strip([pred=isspace,] str::AbstractString) -&gt; SubString
strip(str::AbstractString, chars) -&gt; SubString</code></pre><p>Remove leading and trailing characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p><p>The default behaviour is to remove leading whitespace and delimiters: see <a href="@ref"><code>isspace</code></a> for precise details.</p><p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, vector or set of characters.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>The method which accepts a predicate function requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; strip(&quot;{3, 5}\n&quot;, [&#39;{&#39;, &#39;}&#39;, &#39;\n&#39;])
&quot;3, 5&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/util.jl#L286-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.structdiff-Union{Tuple{bn}, Tuple{an}, Tuple{NamedTuple{an, T} where T&lt;:Tuple, Union{Type{NamedTuple{bn, T} where T&lt;:Tuple}, NamedTuple{bn, T} where T&lt;:Tuple}}} where {an, bn}" href="#Base.structdiff-Union{Tuple{bn}, Tuple{an}, Tuple{NamedTuple{an, T} where T&lt;:Tuple, Union{Type{NamedTuple{bn, T} where T&lt;:Tuple}, NamedTuple{bn, T} where T&lt;:Tuple}}} where {an, bn}"><code>Base.structdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">structdiff(a::NamedTuple{an}, b::Union{NamedTuple{bn},Type{NamedTuple{bn}}}) where {an,bn}</code></pre><p>Construct a copy of named tuple <code>a</code>, except with fields that exist in <code>b</code> removed. <code>b</code> can be a named tuple, or a type of the form <code>NamedTuple{field_names}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/namedtuple.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.success-Tuple{Base.AbstractCmd}" href="#Base.success-Tuple{Base.AbstractCmd}"><code>Base.success</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">success(command)</code></pre><p>Run a command object, constructed with backticks (see the <a href="@ref">Running External Programs</a> section in the manual), and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/process.jl#L489-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum!-Tuple{Any, Any}" href="#Base.sum!-Tuple{Any, Any}"><code>Base.sum!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum!(r, A)</code></pre><p>Sum elements of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; sum!([1; 1], A)
2-element Vector{Int64}:
 3
 7

julia&gt; sum!([1 1], A)
1×2 Matrix{Int64}:
 4  6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L477-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{AbstractArray}" href="#Base.sum-Tuple{AbstractArray}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(A::AbstractArray; dims)</code></pre><p>Sum elements of an array over the given dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; sum(A, dims=1)
1×2 Matrix{Int64}:
 4  6

julia&gt; sum(A, dims=2)
2×1 Matrix{Int64}:
 3
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L428-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{Any, AbstractArray}" href="#Base.sum-Tuple{Any, AbstractArray}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(f, A::AbstractArray; dims)</code></pre><p>Sum the results of calling function <code>f</code> on each element of an array over the given dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; sum(abs2, A, dims=1)
1×2 Matrix{Int64}:
 10  20

julia&gt; sum(abs2, A, dims=2)
2×1 Matrix{Int64}:
  5
 25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reducedim.jl#L452-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{Any, Any}" href="#Base.sum-Tuple{Any, Any}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(f, itr; [init])</code></pre><p>Sum the results of calling function <code>f</code> on each element of <code>itr</code>.</p><p>The return type is <code>Int</code> for signed integers of less than system word size, and <code>UInt</code> for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.</p><p>The value returned for empty <code>itr</code> can be specified by <code>init</code>. It must be the additive identity (i.e. zero) as it is unspecified whether <code>init</code> is used for non-empty collections.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Keyword argument <code>init</code> requires Julia 1.6 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sum(abs2, [2; 3; 4])
29</code></pre><p>Note the important difference between <code>sum(A)</code> and <code>reduce(+, A)</code> for arrays with small integer eltype:</p><pre><code class="language-julia-repl hljs">julia&gt; sum(Int8[100, 28])
128

julia&gt; reduce(+, Int8[100, 28])
-128</code></pre><p>In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L464-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum-Tuple{Any}" href="#Base.sum-Tuple{Any}"><code>Base.sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum(itr; [init])</code></pre><p>Returns the sum of all elements in a collection.</p><p>The return type is <code>Int</code> for signed integers of less than system word size, and <code>UInt</code> for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.</p><p>The value returned for empty <code>itr</code> can be specified by <code>init</code>. It must be the additive identity (i.e. zero) as it is unspecified whether <code>init</code> is used for non-empty collections.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Keyword argument <code>init</code> requires Julia 1.6 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sum(1:20)
210

julia&gt; sum(1:20; init = 0.0)
210.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reduce.jl#L503-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.summary-Tuple{IO, Any}" href="#Base.summary-Tuple{IO, Any}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">summary(io::IO, x)
str = summary(x)</code></pre><p>Print to a stream <code>io</code>, or return a string <code>str</code>, giving a brief description of a value. By default returns <code>string(typeof(x))</code>, e.g. <a href="@ref"><code>Int64</code></a>.</p><p>For arrays, returns a string of size and type info, e.g. <code>10-element Array{Int64,1}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; summary(1)
&quot;Int64&quot;

julia&gt; summary(zeros(2))
&quot;2-element Vector{Float64}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L2614-L2632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.summarysize-Tuple{Any}" href="#Base.summarysize-Tuple{Any}"><code>Base.summarysize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -&gt; Int</code></pre><p>Compute the amount of memory, in bytes, used by all unique objects reachable from the argument.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>exclude</code>: specifies the types of objects to exclude from the traversal.</li><li><code>chargeall</code>: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/summarysize.jl#L11-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.supertype-Tuple{DataType}" href="#Base.supertype-Tuple{DataType}"><code>Base.supertype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">supertype(T::DataType)</code></pre><p>Return the supertype of DataType <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; supertype(Int32)
Signed</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L32-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.symdiff!-Tuple{AbstractSet, Vararg{Any, N} where N}" href="#Base.symdiff!-Tuple{AbstractSet, Vararg{Any, N} where N}"><code>Base.symdiff!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>Construct the symmetric difference of the passed in sets, and overwrite <code>s</code> with the result. When <code>s</code> is an array, the order is maintained. Note that in this case the multiplicity of elements matters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L221-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.symdiff-Tuple{Any, Vararg{Any, N} where N}" href="#Base.symdiff-Tuple{Any, Vararg{Any, N} where N}"><code>Base.symdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symdiff(s, itrs...)</code></pre><p>Construct the symmetric difference of elements in the passed in sets. When <code>s</code> is not an <code>AbstractSet</code>, the order is maintained. Note that in this case the multiplicity of elements matters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; symdiff([1,2,3], [3,4,5], [4,5,6])
3-element Vector{Int64}:
 1
 2
 6

julia&gt; symdiff([1,2,1], [2, 1, 2])
2-element Vector{Int64}:
 1
 2

julia&gt; symdiff(unique([1,2,1]), unique([2, 1, 2]))
Int64[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L194-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.systemerror-Tuple{Any, Bool}" href="#Base.systemerror-Tuple{Any, Bool}"><code>Base.systemerror</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">systemerror(sysfunc[, errno::Cint=Libc.errno()])
systemerror(sysfunc, iftrue::Bool)</code></pre><p>Raises a <code>SystemError</code> for <code>errno</code> with the descriptive string <code>sysfunc</code> if <code>iftrue</code> is <code>true</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L161-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.tail-Tuple{Tuple}" href="#Base.tail-Tuple{Tuple}"><code>Base.tail</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tail(x::Tuple)::Tuple</code></pre><p>Return a <code>Tuple</code> consisting of all but the first component of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.tail((1,2,3))
(2, 3)

julia&gt; Base.tail(())
ERROR: ArgumentError: Cannot call tail on an empty tuple.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L227-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.take!-Tuple{Base.GenericIOBuffer}" href="#Base.take!-Tuple{Base.GenericIOBuffer}"><code>Base.take!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">take!(b::IOBuffer)</code></pre><p>Obtain the contents of an <code>IOBuffer</code> as an array, without copying. Afterwards, the <code>IOBuffer</code> is reset to its initial state.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer();

julia&gt; write(io, &quot;JuliaLang is a GitHub organization.&quot;, &quot; It has many members.&quot;)
56

julia&gt; String(take!(io))
&quot;JuliaLang is a GitHub organization. It has many members.&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iobuffer.jl#L353-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.take!-Tuple{Channel}" href="#Base.take!-Tuple{Channel}"><code>Base.take!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">take!(c::Channel)</code></pre><p>Remove and return a value from a <a href="#Base.Channel"><code>Channel</code></a>. Blocks until data is available.</p><p>For unbuffered channels, blocks until a <a href="#Base.put!-Union{Tuple{T}, Tuple{Channel{T}, Any}} where T"><code>put!</code></a> is performed by a different task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/channels.jl#L375-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.task_local_storage-Tuple{Any, Any}" href="#Base.task_local_storage-Tuple{Any, Any}"><code>Base.task_local_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">task_local_storage(key, value)</code></pre><p>Assign a value to a key in the current task&#39;s task-local storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.task_local_storage-Tuple{Any}" href="#Base.task_local_storage-Tuple{Any}"><code>Base.task_local_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">task_local_storage(key)</code></pre><p>Look up the value of a key in the current task&#39;s task-local storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.task_local_storage-Tuple{Function, Any, Any}" href="#Base.task_local_storage-Tuple{Function, Any, Any}"><code>Base.task_local_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">task_local_storage(body, key, value)</code></pre><p>Call the function <code>body</code> with a modified task-local storage, in which <code>value</code> is assigned to <code>key</code>; the previous value of <code>key</code>, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L268-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.thisind-Tuple{AbstractString, Integer}" href="#Base.thisind-Tuple{AbstractString, Integer}"><code>Base.thisind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thisind(s::AbstractString, i::Integer) -&gt; Int</code></pre><p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding code unit <code>i</code> is part of. In other words, if <code>i</code> is the start of a character, return <code>i</code>; if <code>i</code> is not the start of a character, rewind until the start of a character and return that index. If <code>i</code> is equal to 0 or <code>ncodeunits(s)+1</code> return <code>i</code>. In all other cases throw <code>BoundsError</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; thisind(&quot;α&quot;, 0)
0

julia&gt; thisind(&quot;α&quot;, 1)
1

julia&gt; thisind(&quot;α&quot;, 2)
1

julia&gt; thisind(&quot;α&quot;, 3)
3

julia&gt; thisind(&quot;α&quot;, 4)
ERROR: BoundsError: attempt to access 2-codeunit String at index [4]
[...]

julia&gt; thisind(&quot;α&quot;, -1)
ERROR: BoundsError: attempt to access 2-codeunit String at index [-1]
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/basic.jl#L404-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.time_ns-Tuple{}" href="#Base.time_ns-Tuple{}"><code>Base.time_ns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_ns()</code></pre><p>Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/Base.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.timedwait-Tuple{Function, Real}" href="#Base.timedwait-Tuple{Function, Real}"><code>Base.timedwait</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timedwait(callback::Function, timeout::Real; pollint::Real=0.1)</code></pre><p>Waits until <code>callback</code> returns <code>true</code> or <code>timeout</code> seconds have passed, whichever is earlier. <code>callback</code> is polled every <code>pollint</code> seconds. The minimum value for <code>timeout</code> and <code>pollint</code> is <code>0.001</code>, that is, 1 millisecond.</p><p>Returns :ok or :timed_out</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/asyncevent.jl#L258-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.to_index-Tuple{Any, Any}" href="#Base.to_index-Tuple{Any, Any}"><code>Base.to_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_index(A, i)</code></pre><p>Convert index <code>i</code> to an <code>Int</code> or array of indices to be used as an index into array <code>A</code>.</p><p>Custom array types may specialize <code>to_index(::CustomArray, i)</code> to provide special indexing behaviors. Note that some index types (like <code>Colon</code>) require more context in order to transform them into an array of indices; those get converted in the more complicated <code>to_indices</code> function. By default, this simply calls the generic <code>to_index(i)</code>. This must return either an <code>Int</code> or an <code>AbstractArray</code> of scalar indices that are supported by <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L265-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.to_index-Tuple{Integer}" href="#Base.to_index-Tuple{Integer}"><code>Base.to_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_index(i)</code></pre><p>Convert index <code>i</code> to an <code>Int</code> or array of <code>Int</code>s to be used as an index for all arrays.</p><p>Custom index types may specialize <code>to_index(::CustomIndex)</code> to provide special indexing behaviors. This must return either an <code>Int</code> or an <code>AbstractArray</code> of <code>Int</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L283-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.to_indices-Tuple{Any, Tuple}" href="#Base.to_indices-Tuple{Any, Tuple}"><code>Base.to_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_indices(A, I::Tuple)</code></pre><p>Convert the tuple <code>I</code> to a tuple of indices for use in indexing into array <code>A</code>.</p><p>The returned tuple must only contain either <code>Int</code>s or <code>AbstractArray</code>s of scalar indices that are supported by array <code>A</code>. It will error upon encountering a novel index type that it does not know how to process.</p><p>For simple index types, it defers to the unexported <code>Base.to_index(A, i)</code> to process each index <code>i</code>. While this internal function is not intended to be called directly, <code>Base.to_index</code> may be extended by custom array or index types to provide custom indexing behaviors.</p><p>More complicated index types may require more context about the dimension into which they index. To support those cases, <code>to_indices(A, I)</code> calls <code>to_indices(A, axes(A), I)</code>, which then recursively walks through both the given tuple of indices and the dimensional indices of <code>A</code> in tandem. As such, not all index types are guaranteed to propagate to <code>Base.to_index</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/indices.jl#L304-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.trailing_ones-Tuple{Integer}" href="#Base.trailing_ones-Tuple{Integer}"><code>Base.trailing_ones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trailing_ones(x::Integer) -&gt; Integer</code></pre><p>Number of ones trailing the binary representation of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trailing_ones(3)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L426-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.trailing_zeros-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}" href="#Base.trailing_zeros-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}"><code>Base.trailing_zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trailing_zeros(x::Integer) -&gt; Integer</code></pre><p>Number of zeros trailing the binary representation of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trailing_zeros(2)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L387-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.transcode" href="#Base.transcode"><code>Base.transcode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transcode(T, src)</code></pre><p>Convert string data between Unicode encodings. <code>src</code> is either a <code>String</code> or a <code>Vector{UIntXX}</code> of UTF-XX code units, where <code>XX</code> is 8, 16, or 32. <code>T</code> indicates the encoding of the return value: <code>String</code> to return a (UTF-8 encoded) <code>String</code> or <code>UIntXX</code> to return a <code>Vector{UIntXX}</code> of UTF-<code>XX</code> data. (The alias <a href="#Base.Cwchar_t"><code>Cwchar_t</code></a> can also be used as the integer type, for converting <code>wchar_t*</code> strings used by external C libraries.)</p><p>The <code>transcode</code> function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</p><p>Only conversion to/from UTF-8 is currently supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L257-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.trues-Tuple{Vararg{Union{Integer, AbstractUnitRange}, N} where N}" href="#Base.trues-Tuple{Vararg{Union{Integer, AbstractUnitRange}, N} where N}"><code>Base.trues</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trues(dims)</code></pre><p>Create a <code>BitArray</code> with all values set to <code>true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; trues(2,3)
2×3 BitMatrix:
 1  1  1
 1  1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bitarray.jl#L408-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.trunc" href="#Base.trunc"><code>Base.trunc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trunc([T,] x)
trunc(x; digits::Integer= [, base = 10])
trunc(x; sigdigits::Integer= [, base = 10])</code></pre><p><code>trunc(x)</code> returns the nearest integral value of the same type as <code>x</code> whose absolute value is less than or equal to <code>x</code>.</p><p><code>trunc(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p><p><code>digits</code>, <code>sigdigits</code> and <code>base</code> work as for <a href="#Base.round"><code>round</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L549-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.truncate-Tuple{IOStream, Integer}" href="#Base.truncate-Tuple{IOStream, Integer}"><code>Base.truncate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncate(file, n)</code></pre><p>Resize the file or buffer given by the first argument to exactly <code>n</code> bytes, filling previously unallocated space with &#39;\0&#39; if the file or buffer is grown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer();

julia&gt; write(io, &quot;JuliaLang is a GitHub organization.&quot;)
35

julia&gt; truncate(io, 15)
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=15, maxsize=Inf, ptr=16, mark=-1)

julia&gt; String(take!(io))
&quot;JuliaLang is a &quot;

julia&gt; io = IOBuffer();

julia&gt; write(io, &quot;JuliaLang is a GitHub organization.&quot;);

julia&gt; truncate(io, 40);

julia&gt; String(take!(io))
&quot;JuliaLang is a GitHub organization.\0\0\0\0\0&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/iostream.jl#L77-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.trylock-Tuple{ReentrantLock}" href="#Base.trylock-Tuple{ReentrantLock}"><code>Base.trylock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trylock(lock) -&gt; Success (Boolean)</code></pre><p>Acquire the lock if it is available, and return <code>true</code> if successful. If the lock is already locked by a different task/thread, return <code>false</code>.</p><p>Each successful <code>trylock</code> must be matched by an <a href="#Base.unlock-Tuple{ReentrantLock}"><code>unlock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/lock.jl#L48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.tryparse-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T&lt;:Integer" href="#Base.tryparse-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T&lt;:Integer"><code>Base.tryparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tryparse(type, str; base)</code></pre><p>Like <a href="#Base.parse-Tuple{Type, Any}"><code>parse</code></a>, but returns either a value of the requested type, or <a href="@ref"><code>nothing</code></a> if the string does not contain a valid number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/parse.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.typeintersect-Tuple{Any, Any}" href="#Base.typeintersect-Tuple{Any, Any}"><code>Base.typeintersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typeintersect(T, S)</code></pre><p>Compute a type that contains the intersection of <code>T</code> and <code>S</code>. Usually this will be the smallest such type or one close to it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L603-L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.typejoin-Tuple{}" href="#Base.typejoin-Tuple{}"><code>Base.typejoin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">typejoin(T, S)</code></pre><p>Return the closest common ancestor of <code>T</code> and <code>S</code>, i.e. the narrowest type from which they both inherit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/promotion.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.typemax" href="#Base.typemax"><code>Base.typemax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">typemax(T)</code></pre><p>The highest value representable by the given (real) numeric <code>DataType</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; typemax(Int8)
127

julia&gt; typemax(UInt32)
0xffffffff</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L698-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.typemin" href="#Base.typemin"><code>Base.typemin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">typemin(T)</code></pre><p>The lowest value representable by the given (real) numeric DataType <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; typemin(Float16)
-Inf16

julia&gt; typemin(Float32)
-Inf32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L682-L695">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.uabs-Tuple{Integer}" href="#Base.uabs-Tuple{Integer}"><code>Base.uabs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">uabs(x::Integer)</code></pre><p>Return the absolute value of <code>x</code>, possibly returning a different type should the operation be susceptible to overflow. This typically arises when <code>x</code> is a two&#39;s complement signed integer, so that <code>abs(typemin(x)) == typemin(x) &lt; 0</code>, in which case the result of <code>uabs(x)</code> will be an unsigned integer of the same size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L604-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unalias-Tuple{Any, AbstractArray}" href="#Base.unalias-Tuple{Any, AbstractArray}"><code>Base.unalias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.unalias(dest, A)</code></pre><p>Return either <code>A</code> or a copy of <code>A</code> in a rough effort to prevent modifications to <code>dest</code> from affecting the returned object. No guarantees are provided.</p><p>Custom arrays that wrap or use fields containing arrays that might alias against other external objects should provide a <a href="#Base.dataids-Tuple{AbstractArray}"><code>Base.dataids</code></a> implementation.</p><p>This function must return an object of exactly the same type as <code>A</code> for performance and type stability. Mutable custom arrays for which <a href="#Base.copy"><code>copy(A)</code></a> is not <code>typeof(A)</code> should provide a <a href="#Base.unaliascopy-Tuple{Array}"><code>Base.unaliascopy</code></a> implementation.</p><p>See also <a href="#Base.mightalias-Tuple{AbstractArray, AbstractArray}"><code>Base.mightalias</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1334-L1348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unaliascopy-Tuple{Array}" href="#Base.unaliascopy-Tuple{Array}"><code>Base.unaliascopy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.unaliascopy(A)</code></pre><p>Make a preventative copy of <code>A</code> in an operation where <code>A</code> <a href="#Base.mightalias-Tuple{AbstractArray, AbstractArray}"><code>Base.mightalias</code></a> against another array in order to preserve consistent semantics as that other array is mutated.</p><p>This must return an object of the same type as <code>A</code> to preserve optimal performance in the much more common case where aliasing does not occur. By default, <code>unaliascopy(A::AbstractArray)</code> will attempt to use <a href="#Base.copy"><code>copy(A)</code></a>, but in cases where <code>copy(A)</code> is not a <code>typeof(A)</code>, then the array should provide a custom implementation of <code>Base.unaliascopy(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1353-L1364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unescape_string" href="#Base.unescape_string"><code>Base.unescape_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unescape_string(str::AbstractString, keep = ())::AbstractString
unescape_string(io, s::AbstractString, keep = ())::Nothing</code></pre><p>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to <code>io</code>. The argument <code>keep</code> specifies a collection of characters which (along with backlashes) are to be kept as they are.</p><p>The following escape sequences are recognised:</p><ul><li>Escaped backslash (<code>\\</code>)</li><li>Escaped double-quote (<code>\&quot;</code>)</li><li>Standard C escape sequences (<code>\a</code>, <code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\v</code>, <code>\f</code>, <code>\r</code>, <code>\e</code>)</li><li>Unicode BMP code points (<code>\u</code> with 1-4 trailing hex digits)</li><li>All Unicode code points (<code>\U</code> with 1-8 trailing hex digits; max value = 0010ffff)</li><li>Hex bytes (<code>\x</code> with 1-2 trailing hex digits)</li><li>Octal bytes (<code>\</code> with 1-3 trailing octal digits)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unescape_string(&quot;aaa\\nbbb&quot;) # C escape sequence
&quot;aaa\nbbb&quot;

julia&gt; unescape_string(&quot;\\u03c0&quot;) # unicode
&quot;π&quot;

julia&gt; unescape_string(&quot;\\101&quot;) # octal
&quot;A&quot;

julia&gt; unescape_string(&quot;aaa \\g \\n&quot;, [&#39;g&#39;]) # using `keep` argument
&quot;aaa \\g \n&quot;</code></pre><p><strong>See also</strong></p><p><a href="#Base.escape_string"><code>escape_string</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L372-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unindent-Tuple{AbstractString, Int64}" href="#Base.unindent-Tuple{AbstractString, Int64}"><code>Base.unindent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unindent(str::AbstractString, indent::Int; tabwidth=8)</code></pre><p>Remove leading indentation from string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.unindent(&quot;   a\n   b&quot;, 2)
&quot; a\n b&quot;

julia&gt; Base.unindent(&quot;\ta\n\tb&quot;, 2, tabwidth=8)
&quot;      a\n      b&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L601-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">union(s, itrs...)
∪(s, itrs...)</code></pre><p>Construct the union of sets. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; union([1, 2], [3, 4])
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; union([1, 2], [2, 4])
3-element Vector{Int64}:
 1
 2
 4

julia&gt; union([4, 2], 1:2)
3-element Vector{Int64}:
 4
 2
 1

julia&gt; union(Set([1, 2]), 2:3)
Set{Int64} with 3 elements:
  2
  3
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L10-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union!-Tuple{AbstractSet, Vararg{Any, N} where N}" href="#Base.union!-Tuple{AbstractSet, Vararg{Any, N} where N}"><code>Base.union!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">union!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>Construct the union of passed in sets and overwrite <code>s</code> with the result. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Set([1, 3, 4, 5]);

julia&gt; union!(a, 1:2:8);

julia&gt; a
Set{Int64} with 5 elements:
  5
  4
  7
  3
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractset.jl#L53-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique!-Tuple{Any, AbstractVector{T} where T}" href="#Base.unique!-Tuple{Any, AbstractVector{T} where T}"><code>Base.unique!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique!(f, A::AbstractVector)</code></pre><p>Selects one value from <code>A</code> for each unique value produced by <code>f</code> applied to elements of <code>A</code>, then return the modified A.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This method is available as of Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unique!(x -&gt; x^2, [1, -1, 3, -3, 4])
3-element Vector{Int64}:
 1
 3
 4

julia&gt; unique!(n -&gt; n%3, [5, 1, 8, 9, 3, 4, 10, 7, 2, 6])
3-element Vector{Int64}:
 5
 1
 9

julia&gt; unique!(iseven, [2, 3, 5, 7, 9])
2-element Vector{Int64}:
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/set.jl#L233-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique!-Tuple{Any}" href="#Base.unique!-Tuple{Any}"><code>Base.unique!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique!(A::AbstractVector)</code></pre><p>Remove duplicate items as determined by <a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a>, then return the modified <code>A</code>. <code>unique!</code> will return the elements of <code>A</code> in the order that they occur. If you do not care about the order of the returned data, then calling <code>(sort!(A); unique!(A))</code> will be much more efficient as long as the elements of <code>A</code> can be sorted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unique!([1, 1, 1])
1-element Vector{Int64}:
 1

julia&gt; A = [7, 3, 2, 3, 7, 5];

julia&gt; unique!(A)
4-element Vector{Int64}:
 7
 3
 2
 5

julia&gt; B = [7, 6, 42, 6, 7, 42];

julia&gt; sort!(B);  # unique! is able to process sorted data much more efficiently.

julia&gt; unique!(B)
3-element Vector{Int64}:
  6
  7
 42</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/set.jl#L323-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique-Tuple{AbstractArray}" href="#Base.unique-Tuple{AbstractArray}"><code>Base.unique</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique(A::AbstractArray; dims::Int)</code></pre><p>Return unique regions of <code>A</code> along dimension <code>dims</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = map(isodd, reshape(Vector(1:8), (2,2,2)))
2×2×2 Array{Bool, 3}:
[:, :, 1] =
 1  1
 0  0

[:, :, 2] =
 1  1
 0  0

julia&gt; unique(A)
2-element Vector{Bool}:
 1
 0

julia&gt; unique(A, dims=2)
2×1×2 Array{Bool, 3}:
[:, :, 1] =
 1
 0

[:, :, 2] =
 1
 0

julia&gt; unique(A, dims=3)
2×2×1 Array{Bool, 3}:
[:, :, 1] =
 1  1
 0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/multidimensional.jl#L1546-L1584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique-Tuple{Any, Any}" href="#Base.unique-Tuple{Any, Any}"><code>Base.unique</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique(f, itr)</code></pre><p>Returns an array containing one value from <code>itr</code> for each unique value produced by <code>f</code> applied to elements of <code>itr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unique(x -&gt; x^2, [1, -1, 3, -3, 4])
3-element Vector{Int64}:
 1
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/set.jl#L171-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique-Tuple{Any}" href="#Base.unique-Tuple{Any}"><code>Base.unique</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique(itr)</code></pre><p>Return an array containing only the unique elements of collection <code>itr</code>, as determined by <a href="#Base.isequal-Tuple{Any, Any}"><code>isequal</code></a>, in the order that the first of each set of equivalent elements originally appears. The element type of the input is preserved.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unique([1, 2, 6, 2])
3-element Vector{Int64}:
 1
 2
 6

julia&gt; unique(Real[1, 1.0, 2])
2-element Vector{Real}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/set.jl#L100-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unlock-Tuple{ReentrantLock}" href="#Base.unlock-Tuple{ReentrantLock}"><code>Base.unlock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unlock(lock)</code></pre><p>Releases ownership of the <code>lock</code>.</p><p>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/lock.jl#L111-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unmark-Tuple{IO}" href="#Base.unmark-Tuple{IO}"><code>Base.unmark</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unmark(s)</code></pre><p>Remove a mark from stream <code>s</code>. Return <code>true</code> if the stream was marked, <code>false</code> otherwise.</p><p>See also <a href="#Base.mark-Tuple{IO}"><code>mark</code></a>, <a href="#Base.reset-Tuple{T} where T&lt;:IO"><code>reset</code></a>, <a href="#Base.ismarked-Tuple{IO}"><code>ismarked</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L1072-L1078">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_convert" href="#Base.unsafe_convert"><code>Base.unsafe_convert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_convert(T, x)</code></pre><p>Convert <code>x</code> to a C argument of type <code>T</code> where the input <code>x</code> must be the return value of <code>cconvert(T, ...)</code>.</p><p>In cases where <a href="#Base.convert"><code>convert</code></a> would need to take a Julia object and turn it into a <code>Ptr</code>, this function should be used to define and perform that conversion.</p><p>Be careful to ensure that a Julia reference to <code>x</code> exists as long as the result of this function will be used. Accordingly, the argument <code>x</code> to this function should never be an expression, only a variable name or field reference. For example, <code>x=a.b.c</code> is acceptable, but <code>x=[a,b,c]</code> is not.</p><p>The <code>unsafe</code> prefix on this function indicates that using the result of this function after the <code>x</code> argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.</p><p>See also <a href="#Base.cconvert"><code>cconvert</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/pointer.jl#L34-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Array{T, N} where N, Any, Array{T, N} where N, Any, Any}} where T" href="#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Array{T, N} where N, Any, Array{T, N} where N, Any, Any}} where T"><code>Base.unsafe_copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_copyto!(dest::Array, do, src::Array, so, N)</code></pre><p>Copy <code>N</code> elements from a source array to a destination, starting at offset <code>so</code> in the source and <code>do</code> in the destination (1-indexed).</p><p>The <code>unsafe</code> prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L252-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Ptr{T}, Ptr{T}, Any}} where T" href="#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Ptr{T}, Ptr{T}, Any}} where T"><code>Base.unsafe_copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, N)</code></pre><p>Copy <code>N</code> elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.</p><p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointers <code>dest</code> and <code>src</code> to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L210-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_load" href="#Base.unsafe_load"><code>Base.unsafe_load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_load(p::Ptr{T}, i::Integer=1)</code></pre><p>Load a value of type <code>T</code> from the address of the <code>i</code>th element (1-indexed) starting at <code>p</code>. This is equivalent to the C expression <code>p[i-1]</code>.</p><p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointer <code>p</code> to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/pointer.jl#L95-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_pointer_to_objref-Tuple{Ptr}" href="#Base.unsafe_pointer_to_objref-Tuple{Ptr}"><code>Base.unsafe_pointer_to_objref</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_pointer_to_objref(p::Ptr)</code></pre><p>Convert a <code>Ptr</code> to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered &quot;unsafe&quot; and should be used with care.</p><p>See also: <a href="#Base.pointer_from_objref-Tuple{Any}"><code>pointer_from_objref</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/pointer.jl#L121-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_read-Tuple{IO, Ptr{UInt8}, UInt64}" href="#Base.unsafe_read-Tuple{IO, Ptr{UInt8}, UInt64}"><code>Base.unsafe_read</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_read(io::IO, ref, nbytes::UInt)</code></pre><p>Copy <code>nbytes</code> from the <code>IO</code> stream object into <code>ref</code> (converted to a pointer).</p><p>It is recommended that subtypes <code>T&lt;:IO</code> override the following method signature to provide more efficient implementations: <code>unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L243-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_store!" href="#Base.unsafe_store!"><code>Base.unsafe_store!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_store!(p::Ptr{T}, x, i::Integer=1)</code></pre><p>Store a value of type <code>T</code> to the address of the <code>i</code>th element (1-indexed) starting at <code>p</code>. This is equivalent to the C expression <code>p[i-1] = x</code>.</p><p>The <code>unsafe</code> prefix on this function indicates that no validation is performed on the pointer <code>p</code> to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/pointer.jl#L107-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_string-Tuple{Union{Ptr{Int8}, Ptr{UInt8}}, Integer}" href="#Base.unsafe_string-Tuple{Union{Ptr{Int8}, Ptr{UInt8}}, Integer}"><code>Base.unsafe_string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_string(p::Ptr{UInt8}, [length::Integer])</code></pre><p>Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If <code>length</code> is specified (the length of the data in bytes), the string does not have to be NUL-terminated.</p><p>This function is labeled &quot;unsafe&quot; because it will crash if <code>p</code> is not a valid memory address to data of the requested length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/string.jl#L55-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_trunc" href="#Base.unsafe_trunc"><code>Base.unsafe_trunc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_trunc(T, x)</code></pre><p>Return the nearest integral value of type <code>T</code> whose absolute value is less than or equal to <code>x</code>. If the value is not representable by <code>T</code>, an arbitrary value will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/float.jl#L226-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T, N} where N}, Type{Array{T, N}}}, Ptr{T}, Tuple{Vararg{Int64, N}}}} where {T, N}" href="#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T, N} where N}, Type{Array{T, N}}}, Ptr{T}, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>Base.unsafe_wrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)</code></pre><p>Wrap a Julia <code>Array</code> object around the data at the address given by <code>pointer</code>, without making a copy.  The pointer element type <code>T</code> determines the array element type. <code>dims</code> is either an integer (for a 1d array) or a tuple of the array dimensions. <code>own</code> optionally specifies whether Julia should take ownership of the memory, calling <code>free</code> on the pointer when the array is no longer referenced.</p><p>This function is labeled &quot;unsafe&quot; because it will crash if <code>pointer</code> is not a valid memory address to data of the requested length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/pointer.jl#L70-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsafe_write-Tuple{IO, Ptr{UInt8}, UInt64}" href="#Base.unsafe_write-Tuple{IO, Ptr{UInt8}, UInt64}"><code>Base.unsafe_write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_write(io::IO, ref, nbytes::UInt)</code></pre><p>Copy <code>nbytes</code> from <code>ref</code> (converted to a pointer) into the <code>IO</code> object.</p><p>It is recommended that subtypes <code>T&lt;:IO</code> override the following method signature to provide more efficient implementations: <code>unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L226-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsigned" href="#Base.unsigned"><code>Base.unsigned</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsigned(T::Integer)</code></pre><p>Convert an integer bitstype to the unsigned type of the same size.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unsigned(Int16)
UInt16
julia&gt; unsigned(UInt64)
UInt64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unsigned-Tuple{Any}" href="#Base.unsigned-Tuple{Any}"><code>Base.unsigned</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsigned(x)</code></pre><p>Convert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unsigned(-2)
0xfffffffffffffffe
julia&gt; unsigned(2)
0x0000000000000002
julia&gt; signed(unsigned(-2))
-2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L174-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.valtype-Tuple{Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:AbstractArray}" href="#Base.valtype-Tuple{Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:AbstractArray}"><code>Base.valtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valtype(T::Type{&lt;:AbstractArray})
valtype(A::AbstractArray)</code></pre><p>Return the value type of an array. This is identical to <code>eltype</code> and is provided mainly for compatibility with the dictionary interface.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; valtype([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])
String</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>For arrays, this function requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L145-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.valtype-Union{Tuple{Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:AbstractDict{K, V}}, Tuple{V}, Tuple{K}} where {K, V}" href="#Base.valtype-Union{Tuple{Type{var&quot;#s832&quot;} where var&quot;#s832&quot;&lt;:AbstractDict{K, V}}, Tuple{V}, Tuple{K}} where {K, V}"><code>Base.valtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">valtype(type)</code></pre><p>Get the value type of an dictionary type. Behaves similarly to <a href="#Base.eltype-Tuple{Type}"><code>eltype</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; valtype(Dict(Int32(1) =&gt; &quot;foo&quot;))
String</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L263-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.values-Tuple{AbstractDict}" href="#Base.values-Tuple{AbstractDict}"><code>Base.values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">values(a::AbstractDict)</code></pre><p>Return an iterator over all values in a collection. <code>collect(values(a))</code> returns an array of values. When the values are stored internally in a hash table, as is the case for <code>Dict</code>, the order in which they are returned may vary. But <code>keys(a)</code> and <code>values(a)</code> both iterate <code>a</code> and return the elements in the same order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; D = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char, Int64} with 2 entries:
  &#39;a&#39; =&gt; 2
  &#39;b&#39; =&gt; 3

julia&gt; collect(values(D))
2-element Vector{Int64}:
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractdict.jl#L105-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.values-Tuple{Any}" href="#Base.values-Tuple{Any}"><code>Base.values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">values(iterator)</code></pre><p>For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its &quot;values&quot;.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; values(d)
ValueIterator for a Dict{String, Int64} with 2 entries. Values:
  2
  1

julia&gt; values([2])
1-element Vector{Int64}:
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L770-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vcat-Tuple" href="#Base.vcat-Tuple"><code>Base.vcat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vcat(A...)</code></pre><p>Concatenate along dimension 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2 3 4 5]
1×5 Matrix{Int64}:
 1  2  3  4  5

julia&gt; b = [6 7 8 9 10; 11 12 13 14 15]
2×5 Matrix{Int64}:
  6   7   8   9  10
 11  12  13  14  15

julia&gt; vcat(a,b)
3×5 Matrix{Int64}:
  1   2   3   4   5
  6   7   8   9  10
 11  12  13  14  15

julia&gt; c = ([1 2 3], [4 5 6])
([1 2 3], [4 5 6])

julia&gt; vcat(c...)
2×3 Matrix{Int64}:
 1  2  3
 4  5  6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarray.jl#L1679-L1709">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vec-Tuple{AbstractArray}" href="#Base.vec-Tuple{AbstractArray}"><code>Base.vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vec(a::AbstractArray) -&gt; AbstractVector</code></pre><p>Reshape the array <code>a</code> as a one-dimensional column vector. Return <code>a</code> if it is already an <code>AbstractVector</code>. The resulting array shares the same underlying data as <code>a</code>, so it will only be mutable if <code>a</code> is mutable, in which case modifying one will also modify the other.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1 2 3; 4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia&gt; vec(a)
6-element Vector{Int64}:
 1
 4
 2
 5
 3
 6

julia&gt; vec(1:3)
1:3</code></pre><p>See also <a href="#Base.reshape"><code>reshape</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/abstractarraymath.jl#L11-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.vect-Tuple" href="#Base.vect-Tuple"><code>Base.vect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vect(X...)</code></pre><p>Create a <a href="#Base.Vector"><code>Vector</code></a> with element type computed from the <code>promote_typeof</code> of the argument, containing the argument list.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = Base.vect(UInt8(1), 2.5, 1//2)
3-element Vector{Float64}:
 1.0
 2.5
 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L110-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.view-Union{Tuple{N}, Tuple{AbstractArray, Vararg{Any, N}}} where N" href="#Base.view-Union{Tuple{N}, Tuple{AbstractArray, Vararg{Any, N}}} where N"><code>Base.view</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view(A, inds...)</code></pre><p>Like <a href="#Base.getindex"><code>getindex</code></a>, but returns a lightweight array that lazily references (or is effectively a <em>view</em> into) the parent array <code>A</code> at the given index or indices <code>inds</code> instead of eagerly extracting elements or constructing a copied subset. Calling <a href="#Base.getindex"><code>getindex</code></a> or <a href="#Base.setindex!"><code>setindex!</code></a> on the returned value (often a <a href="#Base.SubArray"><code>SubArray</code></a>) computes the indices to access or modify the parent array on the fly.  The behavior is undefined if the shape of the parent array is changed after <code>view</code> is called because there is no bound check for the parent array; e.g., it may cause a segmentation fault.</p><p>Some immutable parent arrays (like ranges) may choose to simply recompute a new array in some circumstances instead of returning a <code>SubArray</code> if doing so is efficient and provides compatible semantics.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>In Julia 1.6 or later, <code>view</code> can be called on an <code>AbstractString</code>, returning a <code>SubString</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; b = view(A, :, 1)
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:
 1
 3

julia&gt; fill!(b, 0)
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:
 0
 0

julia&gt; A # Note A has changed even though we modified b
2×2 Matrix{Int64}:
 0  2
 0  4

julia&gt; view(2:5, 2:3) # returns a range as type is immutable
3:4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/subarray.jl#L128-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.wait-Tuple{Base.GenericCondition}" href="#Base.wait-Tuple{Base.GenericCondition}"><code>Base.wait</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wait([x])</code></pre><p>Block the current task until some event occurs, depending on the type of the argument:</p><ul><li><a href="#Base.Channel"><code>Channel</code></a>: Wait for a value to be appended to the channel.</li><li><a href="#Base.Condition"><code>Condition</code></a>: Wait for <a href="#Base.notify-Tuple{Base.GenericCondition, Any}"><code>notify</code></a> on a condition.</li><li><code>Process</code>: Wait for a process or process chain to exit. The <code>exitcode</code> field of a process can be used to determine success or failure.</li><li><a href="@ref"><code>Task</code></a>: Wait for a <code>Task</code> to finish. If the task fails with an exception, a <code>TaskFailedException</code> (which wraps the failed task) is thrown.</li><li><a href="@ref"><code>RawFD</code></a>: Wait for changes on a file descriptor (see the <code>FileWatching</code> package).</li></ul><p>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to <a href="#Base.schedule-Tuple{Task, Any}"><code>schedule</code></a> or <a href="#Base.yieldto-Tuple{Task, Any}"><code>yieldto</code></a>.</p><p>Often <code>wait</code> is called within a <code>while</code> loop to ensure a waited-for condition is met before proceeding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/condition.jl#L81-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.which-Tuple{Any, Any}" href="#Base.which-Tuple{Any, Any}"><code>Base.which</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">which(f, types)</code></pre><p>Returns the method of <code>f</code> (a <code>Method</code> object) that would be called for arguments of the given <code>types</code>.</p><p>If <code>types</code> is an abstract type, then the method that would be called by <code>invoke</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1225-L1231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.which-Tuple{Module, Symbol}" href="#Base.which-Tuple{Module, Symbol}"><code>Base.which</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">which(module, symbol)</code></pre><p>Return the module in which the binding for the variable referenced by <code>symbol</code> in <code>module</code> was created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1254-L1258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.which-Tuple{Type}" href="#Base.which-Tuple{Type}"><code>Base.which</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">which(types::Type{&lt;:Tuple})</code></pre><p>Returns the method that would be called by the given type signature (as a tuple type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L1241-L1245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.widemul-Tuple{Number, Number}" href="#Base.widemul-Tuple{Number, Number}"><code>Base.widemul</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">widemul(x, y)</code></pre><p>Multiply <code>x</code> and <code>y</code>, giving the result as a larger type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; widemul(Float32(3.), 4.)
12.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L220-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.widen-Tuple{T} where T" href="#Base.widen-Tuple{T} where T"><code>Base.widen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">widen(x)</code></pre><p>If <code>x</code> is a type, return a &quot;larger&quot; type, defined so that arithmetic operations <code>+</code> and <code>-</code> are guaranteed not to overflow nor lose precision for any combination of values that type <code>x</code> can hold.</p><p>For fixed-size integer types less than 128 bits, <code>widen</code> will return a type with twice the number of bits.</p><p>If <code>x</code> is a value, it is converted to <code>widen(typeof(x))</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; widen(Int32)
Int64

julia&gt; widen(1.5f0)
1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L821-L841">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.windowserror-Tuple{Any, Bool}" href="#Base.windowserror-Tuple{Any, Bool}"><code>Base.windowserror</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">windowserror(sysfunc[, code::UInt32=Libc.GetLastError()])
windowserror(sysfunc, iftrue::Bool)</code></pre><p>Like <a href="#Base.systemerror-Tuple{Any, Bool}"><code>systemerror</code></a>, but for Windows API functions that use <a href="@ref Base.Libc.GetLastError"><code>GetLastError</code></a> to return an error code instead of setting <a href="@ref Base.Libc.errno"><code>errno</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L175-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.withenv-Union{Tuple{T}, Tuple{Function, Vararg{Pair{T, B} where B, N} where N}} where T&lt;:AbstractString" href="#Base.withenv-Union{Tuple{T}, Tuple{Function, Vararg{Pair{T, B} where B, N} where N}} where T&lt;:AbstractString"><code>Base.withenv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">withenv(f::Function, kv::Pair...)</code></pre><p>Execute <code>f</code> in an environment that is temporarily modified (not replaced as in <code>setenv</code>) by zero or more <code>&quot;var&quot;=&gt;val</code> arguments <code>kv</code>. <code>withenv</code> is generally used via the <code>withenv(kv...) do ... end</code> syntax. A value of <code>nothing</code> can be used to temporarily unset an environment variable (if it is set). When <code>withenv</code> returns, the original environment has been restored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/env.jl#L146-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write" href="#Base.write"><code>Base.write</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write(io::IO, x)
write(filename::AbstractString, x)</code></pre><p>Write the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also <a href="#Base.print-Tuple{IO, Any}"><code>print</code></a> to write a text representation (with an encoding that may depend upon <code>io</code>).</p><p>The endianness of the written value depends on the endianness of the host system. Convert to/from a fixed endianness when writing/reading (e.g. using  <a href="#Base.htol-Tuple{Any}"><code>htol</code></a> and <a href="#Base.ltoh-Tuple{Any}"><code>ltoh</code></a>) to get results that are consistent across platforms.</p><p>You can write multiple values with the same <code>write</code> call. i.e. the following are equivalent:</p><pre><code class="nohighlight hljs">write(io, x, y...)
write(io, x) + write(io, y...)</code></pre><p><strong>Examples</strong></p><p>Consistent serialization:</p><pre><code class="language-julia-repl hljs">julia&gt; fname = tempname(); # random temporary filename

julia&gt; open(fname,&quot;w&quot;) do f
           # Make sure we write 64bit integer in little-endian byte order
           write(f,htol(Int64(42)))
       end
8

julia&gt; open(fname,&quot;r&quot;) do f
           # Convert back to host byte order and host integer type
           Int(ltoh(read(f,Int64)))
       end
42</code></pre><p>Merging write calls:</p><pre><code class="language-julia-repl hljs">julia&gt; io = IOBuffer();

julia&gt; write(io, &quot;JuliaLang is a GitHub organization.&quot;, &quot; It has many members.&quot;)
56

julia&gt; String(take!(io))
&quot;JuliaLang is a GitHub organization. It has many members.&quot;

julia&gt; write(io, &quot;Sometimes those members&quot;) + write(io, &quot; write documentation.&quot;)
44

julia&gt; String(take!(io))
&quot;Sometimes those members write documentation.&quot;</code></pre><p>User-defined plain-data types without <code>write</code> methods can be written when wrapped in a <code>Ref</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; struct MyStruct; x::Float64; end

julia&gt; io = IOBuffer()
IOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=Inf, ptr=1, mark=-1)

julia&gt; write(io, Ref(MyStruct(42.0)))
8

julia&gt; seekstart(io); read!(io, Ref(MyStruct(NaN)))
Base.RefValue{MyStruct}(MyStruct(42.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/io.jl#L156-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.xor-Tuple{Bool, Bool}" href="#Base.xor-Tuple{Bool, Bool}"><code>Base.xor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">xor(x, y)
⊻(x, y)</code></pre><p>Bitwise exclusive or of <code>x</code> and <code>y</code>. Implements <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, returning <a href="#Base.missing"><code>missing</code></a> if one of the arguments is <code>missing</code>.</p><p>The infix operation <code>a ⊻ b</code> is a synonym for <code>xor(a,b)</code>, and <code>⊻</code> can be typed by tab-completing <code>\xor</code> or <code>\veebar</code> in the Julia REPL.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; xor(true, false)
true

julia&gt; xor(true, true)
false

julia&gt; xor(true, missing)
missing

julia&gt; false ⊻ false
false

julia&gt; [true; true; false] .⊻ [true; false; false]
3-element BitVector:
 0
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/bool.jl#L39-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.yield-Tuple{Task, Any}" href="#Base.yield-Tuple{Task, Any}"><code>Base.yield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yield(t::Task, arg = nothing)</code></pre><p>A fast, unfair-scheduling version of <code>schedule(t, arg); yield()</code> which immediately yields to <code>t</code> before calling the scheduler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L671-L676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.yield-Tuple{}" href="#Base.yield-Tuple{}"><code>Base.yield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yield()</code></pre><p>Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L651-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.yieldto-Tuple{Task, Any}" href="#Base.yieldto-Tuple{Task, Any}"><code>Base.yieldto</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yieldto(t::Task, arg = nothing)</code></pre><p>Switch to the given task. The first time a task is switched to, the task&#39;s function is called with no arguments. On subsequent switches, <code>arg</code> is returned from the task&#39;s last call to <code>yieldto</code>. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L684-L691">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zero-Tuple{Number}" href="#Base.zero-Tuple{Number}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero(x)
zero(::Type)</code></pre><p>Get the additive identity element for the type of <code>x</code> (<code>x</code> can also specify the type itself).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; zero(1)
0

julia&gt; zero(big&quot;2.0&quot;)
0.0

julia&gt; zero(rand(2,2))
2×2 Matrix{Float64}:
 0.0  0.0
 0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/number.jl#L240-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zeros" href="#Base.zeros"><code>Base.zeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zeros([T=Float64,] dims::Tuple)
zeros([T=Float64,] dims...)</code></pre><p>Create an <code>Array</code>, with element type <code>T</code>, of all zeros with size specified by <code>dims</code>. See also <a href="#Base.fill"><code>fill</code></a>, <a href="#Base.ones"><code>ones</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; zeros(1)
1-element Vector{Float64}:
 0.0

julia&gt; zeros(Int8, 2, 3)
2×3 Matrix{Int8}:
 0  0  0
 0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/array.jl#L454-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.:&lt;:" href="#Core.:&lt;:"><code>Core.:&lt;:</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">&lt;:(T1, T2)</code></pre><p>Subtype operator: returns <code>true</code> if and only if all values of type <code>T1</code> are also of type <code>T2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Float64 &lt;: AbstractFloat
true

julia&gt; Vector{Int} &lt;: AbstractArray
true

julia&gt; Matrix{Float64} &lt;: Matrix{AbstractFloat}
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.:===" href="#Core.:==="><code>Core.:===</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">===(x,y) -&gt; Bool
≡(x,y) -&gt; Bool</code></pre><p>Determine whether <code>x</code> and <code>y</code> are identical, in the sense that no program could distinguish them. First the types of <code>x</code> and <code>y</code> are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called &quot;egal&quot;. It always returns a <code>Bool</code> value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1, 2]; b = [1, 2];

julia&gt; a == b
true

julia&gt; a === b
false

julia&gt; a === a
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L207-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Intrinsics.cglobal" href="#Core.Intrinsics.cglobal"><code>Core.Intrinsics.cglobal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cglobal((symbol, library) [, type=Cvoid])</code></pre><p>Obtain a pointer to a global variable in a C-exported shared library, specified exactly as in <a href="@ref"><code>ccall</code></a>. Returns a <code>Ptr{Type}</code>, defaulting to <code>Ptr{Cvoid}</code> if no <code>Type</code> argument is supplied. The values can be read or written by <a href="#Base.unsafe_load"><code>unsafe_load</code></a> or <a href="#Base.unsafe_store!"><code>unsafe_store!</code></a>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.eval" href="#Core.eval"><code>Core.eval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Core.eval(m::Module, expr)</code></pre><p>Evaluate an expression in the given module and return the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.fieldtype" href="#Core.fieldtype"><code>Core.fieldtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fieldtype(T, name::Symbol | index::Int)</code></pre><p>Determine the declared type of a field (specified by name or index) in a composite DataType <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           x::Int64
           y::String
       end

julia&gt; fieldtype(Foo, :x)
Int64

julia&gt; fieldtype(Foo, 2)
String</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L640-L658">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.ifelse" href="#Core.ifelse"><code>Core.ifelse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ifelse(condition::Bool, x, y)</code></pre><p>Return <code>x</code> if <code>condition</code> is <code>true</code>, otherwise return <code>y</code>. This differs from <code>?</code> or <code>if</code> in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using <code>ifelse</code> instead of an <code>if</code> statement can eliminate the branch in generated code and provide higher performance in tight loops.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ifelse(1 &gt; 2, 1, 2)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/operators.jl#L359-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.throw" href="#Core.throw"><code>Core.throw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">throw(e)</code></pre><p>Throw an object as an exception.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@NamedTuple-Tuple{Any}" href="#Base.@NamedTuple-Tuple{Any}"><code>Base.@NamedTuple</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@NamedTuple{key1::Type1, key2::Type2, ...}
@NamedTuple begin key1::Type1; key2::Type2; ...; end</code></pre><p>This macro gives a more convenient syntax for declaring <code>NamedTuple</code> types. It returns a <code>NamedTuple</code> type with the given keys and types, equivalent to <code>NamedTuple{(:key1, :key2, ...), Tuple{Type1,Type2,...}}</code>. If the <code>::Type</code> declaration is omitted, it is taken to be <code>Any</code>.   The <code>begin ... end</code> form allows the declarations to be split across multiple lines (similar to a <code>struct</code> declaration), but is otherwise equivalent.</p><p>For example, the tuple <code>(a=3.1, b=&quot;hello&quot;)</code> has a type <code>NamedTuple{(:a, :b),Tuple{Float64,String}}</code>, which can also be declared via <code>@NamedTuple</code> as:</p><pre><code class="language-julia-repl hljs">julia&gt; @NamedTuple{a::Float64, b::String}
NamedTuple{(:a, :b), Tuple{Float64, String}}

julia&gt; @NamedTuple begin
           a::Float64
           b::String
       end
NamedTuple{(:a, :b), Tuple{Float64, String}}</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This macro is available as of Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/namedtuple.jl#L359-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@__DIR__-Tuple{}" href="#Base.@__DIR__-Tuple{}"><code>Base.@__DIR__</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@__DIR__ -&gt; AbstractString</code></pre><p>Expand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by <code>julia -e &lt;expr&gt;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L1826-L1832">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@__FILE__-Tuple{}" href="#Base.@__FILE__-Tuple{}"><code>Base.@__FILE__</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@__FILE__ -&gt; AbstractString</code></pre><p>Expand to a string with the path to the file containing the macrocall, or an empty string if evaluated by <code>julia -e &lt;expr&gt;</code>. Return <code>nothing</code> if the macro was missing parser source information. Alternatively see <a href="#Base.PROGRAM_FILE"><code>PROGRAM_FILE</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/loading.jl#L1813-L1820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@__LINE__-Tuple{}" href="#Base.@__LINE__-Tuple{}"><code>Base.@__LINE__</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@__LINE__ -&gt; Int</code></pre><p>Expand to the line number of the location of the macrocall. Return <code>0</code> if the line number could not be determined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L845-L850">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@__MODULE__-Tuple{}" href="#Base.@__MODULE__-Tuple{}"><code>Base.@__MODULE__</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@__MODULE__ -&gt; Module</code></pre><p>Get the <code>Module</code> of the toplevel eval, which is the <code>Module</code> code is currently being read from.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@allocated-Tuple{Any}" href="#Base.@allocated-Tuple{Any}"><code>Base.@allocated</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@allocated</code></pre><p>A macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression.</p><p>See also <a href="#Base.@time-Tuple{Any}"><code>@time</code></a>, <a href="#Base.@timev-Tuple{Any}"><code>@timev</code></a>, <a href="#Base.@timed-Tuple{Any}"><code>@timed</code></a>, and <a href="#Base.@elapsed-Tuple{Any}"><code>@elapsed</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; @allocated rand(10^6)
8000080</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/timing.jl#L301-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@assert-Tuple{Any, Vararg{Any, N} where N}" href="#Base.@assert-Tuple{Any, Vararg{Any, N} where N}"><code>Base.@assert</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@assert cond [text]</code></pre><p>Throw an <a href="@ref"><code>AssertionError</code></a> if <code>cond</code> is <code>false</code>. Preferred syntax for writing assertions. Message <code>text</code> is optionally displayed upon assertion failure.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>An assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @assert iseven(3) &quot;3 is an odd number!&quot;
ERROR: AssertionError: 3 is an odd number!

julia&gt; @assert isodd(3) &quot;What even are numbers?&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/error.jl#L189-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@async-Tuple{Any}" href="#Base.@async-Tuple{Any}"><code>Base.@async</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@async</code></pre><p>Wrap an expression in a <a href="@ref"><code>Task</code></a> and add it to the local machine&#39;s scheduler queue.</p><p>Values can be interpolated into <code>@async</code> via <code>$</code>, which copies the value directly into the constructed underlying closure. This allows you to insert the <em>value</em> of a variable, isolating the asynchronous code from changes to the variable&#39;s value in the current task.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>Interpolating values via <code>$</code> is available as of Julia 1.4.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L396-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@b_str-Tuple{Any}" href="#Base.@b_str-Tuple{Any}"><code>Base.@b_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@b_str</code></pre><p>Create an immutable byte (<code>UInt8</code>) vector using string syntax.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v = b&quot;12\x01\x02&quot;
4-element Base.CodeUnits{UInt8, String}:
 0x31
 0x32
 0x01
 0x02

julia&gt; v[2]
0x32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L468-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@boundscheck-Tuple{Any}" href="#Base.@boundscheck-Tuple{Any}"><code>Base.@boundscheck</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@boundscheck(blk)</code></pre><p>Annotates the expression <code>blk</code> as a bounds checking block, allowing it to be elided by <a href="#Base.@inbounds-Tuple{Any}"><code>@inbounds</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The function in which <code>@boundscheck</code> is written must be inlined into its caller in order for <code>@inbounds</code> to have effect.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @inline function g(A, i)
           @boundscheck checkbounds(A, i)
           return &quot;accessing ($A)[$i]&quot;
       end;

julia&gt; f1() = return g(1:2, -1);

julia&gt; f2() = @inbounds return g(1:2, -1);

julia&gt; f1()
ERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]
Stacktrace:
 [1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:455
 [2] checkbounds at ./abstractarray.jl:420 [inlined]
 [3] g at ./none:2 [inlined]
 [4] f1() at ./none:1
 [5] top-level scope

julia&gt; f2()
&quot;accessing (1:2)[-1]&quot;</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>@boundscheck</code> annotation allows you, as a library writer, to opt-in to allowing <em>other code</em> to remove your bounds checks with <a href="#Base.@inbounds-Tuple{Any}"><code>@inbounds</code></a>. As noted there, the caller must verify—using information they can access—that their accesses are valid before using <code>@inbounds</code>. For indexing into your <a href="#Core.AbstractArray"><code>AbstractArray</code></a> subclasses, for example, this involves checking the indices against its <a href="#Base.size-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}"><code>size</code></a>. Therefore, <code>@boundscheck</code> annotations should only be added to a <a href="#Base.getindex"><code>getindex</code></a> or <a href="#Base.setindex!"><code>setindex!</code></a> implementation after you are certain its behavior is correct.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L482-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@ccall-Tuple{Any}" href="#Base.@ccall-Tuple{Any}"><code>Base.@ccall</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@ccall library.function_name(argvalue1::argtype1, ...)::returntype
@ccall function_name(argvalue1::argtype1, ...)::returntype
@ccall $function_pointer(argvalue1::argtype1, ...)::returntype</code></pre><p>Call a function in a C-exported shared library, specified by <code>library.function_name</code>, where <code>library</code> is a string constant or literal. The library may be omitted, in which case the <code>function_name</code> is resolved in the current process. Alternatively, <code>@ccall</code> may also be used to call a function pointer <code>$function_pointer</code>, such as one returned by <code>dlsym</code>.</p><p>Each <code>argvalue</code> to <code>@ccall</code> is converted to the corresponding <code>argtype</code>, by automatic insertion of calls to <code>unsafe_convert(argtype, cconvert(argtype, argvalue))</code>. (See also the documentation for <a href="#Base.unsafe_convert"><code>unsafe_convert</code></a> and <a href="#Base.cconvert"><code>cconvert</code></a> for further details.) In most cases, this simply results in a call to <code>convert(argtype, argvalue)</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">@ccall strlen(s::Cstring)::Csize_t</code></pre><p>This calls the C standard library function:</p><pre><code class="nohighlight hljs">size_t strlen(char *)</code></pre><p>with a Julia variable named <code>s</code>. See also <code>ccall</code>.</p><p>Varargs are supported with the following convention:</p><pre><code class="nohighlight hljs">@ccall printf(&quot;%s = %d&quot;::Cstring ; &quot;foo&quot;::Cstring, foo::Cint)::Cint</code></pre><p>The semicolon is used to separate required arguments (of which there must be at least one) from variadic arguments.</p><p>Example using an external library:</p><pre><code class="nohighlight hljs"># C signature of g_uri_escape_string:
# char *g_uri_escape_string(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);

const glib = &quot;libglib-2.0&quot;
@ccall glib.g_uri_escape_string(my_uri::Cstring, &quot;:/&quot;::Cstring, true::Cint)::Cstring</code></pre><p>The string literal could also be used directly before the function name, if desired <code>&quot;libglib-2.0&quot;.g_uri_escape_string(...</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L664-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@cfunction-Tuple{Any, Any, Any}" href="#Base.@cfunction-Tuple{Any, Any, Any}"><code>Base.@cfunction</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@cfunction(callable, ReturnType, (ArgumentTypes...,)) -&gt; Ptr{Cvoid}
@cfunction($callable, ReturnType, (ArgumentTypes...,)) -&gt; CFunction</code></pre><p>Generate a C-callable function pointer from the Julia function <code>callable</code> for the given type signature. To pass the return value to a <code>ccall</code>, use the argument type <code>Ptr{Cvoid}</code> in the signature.</p><p>Note that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a &#39;<span>$</span>&#39; in front of the function argument changes this to instead create a runtime closure over the local variable <code>callable</code> (this is not supported on all architectures).</p><p>See <a href="@ref Calling-C-and-Fortran-Code">manual section on ccall and cfunction usage</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; function foo(x::Int, y::Int)
           return x + y
       end

julia&gt; @cfunction(foo, Int, (Int, Int))
Ptr{Cvoid} @0x000000001b82fcd0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/c.jl#L38-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@deprecate" href="#Base.@deprecate"><code>Base.@deprecate</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@deprecate old new [ex=true]</code></pre><p>Deprecate method <code>old</code> and specify the replacement call <code>new</code>. Prevent <code>@deprecate</code> from exporting <code>old</code> by setting <code>ex</code> to <code>false</code>. <code>@deprecate</code> defines a new method with the same signature as <code>old</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>As of Julia 1.5, functions defined by <code>@deprecate</code> do not print warning when <code>julia</code> is run without the <code>--depwarn=yes</code> flag set, as the default value of <code>--depwarn</code> option is <code>no</code>.  The warnings are printed from tests run by <code>Pkg.test()</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @deprecate old(x) new(x)
old (generic function with 1 method)

julia&gt; @deprecate old(x) new(x) false
old (generic function with 1 method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/deprecated.jl#L17-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@elapsed-Tuple{Any}" href="#Base.@elapsed-Tuple{Any}"><code>Base.@elapsed</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@elapsed</code></pre><p>A macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.</p><p>In some cases the system will look inside the <code>@elapsed</code> expression and compile some of the called code before execution of the top-level expression begins. When that happens, some compilation time will not be counted. To include this time you can run <code>@elapsed @eval ...</code>.</p><p>See also <a href="#Base.@time-Tuple{Any}"><code>@time</code></a>, <a href="#Base.@timev-Tuple{Any}"><code>@timev</code></a>, <a href="#Base.@timed-Tuple{Any}"><code>@timed</code></a>, and <a href="#Base.@allocated-Tuple{Any}"><code>@allocated</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; @elapsed sleep(0.3)
0.301391426</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/timing.jl#L265-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@eval-Tuple{Any}" href="#Base.@eval-Tuple{Any}"><code>Base.@eval</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@eval [mod,] ex</code></pre><p>Evaluate an expression with values interpolated into it using <code>eval</code>. If two arguments are provided, the first is the module to evaluate in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@generated-Tuple{Any}" href="#Base.@generated-Tuple{Any}"><code>Base.@generated</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@generated f
@generated(f)</code></pre><p><code>@generated</code> is used to annotate a function which will be generated. In the body of the generated function, only types of arguments can be read (not the values). The function returns a quoted expression evaluated when the function is called. The <code>@generated</code> macro should not be used on functions mutating the global scope or depending on mutable elements.</p><p>See <a href="@ref">Metaprogramming</a> for further details.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">julia&gt; @generated function bar(x)
           if x &lt;: Integer
               return :(x ^ 2)
           else
               return :(x)
           end
       end
bar (generic function with 1 method)

julia&gt; bar(4)
16

julia&gt; bar(&quot;baz&quot;)
&quot;baz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L392-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@gensym-Tuple" href="#Base.@gensym-Tuple"><code>Base.@gensym</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@gensym</code></pre><p>Generates a gensym symbol for a variable. For example, <code>@gensym x y</code> is transformed into <code>x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@goto-Tuple{Symbol}" href="#Base.@goto-Tuple{Symbol}"><code>Base.@goto</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@goto name</code></pre><p><code>@goto name</code> unconditionally jumps to the statement at the location <a href="#Base.@label-Tuple{Symbol}"><code>@label name</code></a>.</p><p><code>@label</code> and <code>@goto</code> cannot create jumps to different top-level statements. Attempts cause an error. To still use <code>@goto</code>, enclose the <code>@label</code> and <code>@goto</code> in a block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L573-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@inbounds-Tuple{Any}" href="#Base.@inbounds-Tuple{Any}"><code>Base.@inbounds</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@inbounds(blk)</code></pre><p>Eliminates array bounds checking within expressions.</p><p>In the example below the in-range check for referencing element <code>i</code> of array <code>A</code> is skipped to improve performance.</p><pre><code class="language-julia hljs">function sum(A::AbstractArray)
    r = zero(eltype(A))
    for i = 1:length(A)
        @inbounds r += A[i]
    end
    return r
end</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Using <code>@inbounds</code> may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually. Only use <code>@inbounds</code> when it is certain from the information locally available that all accesses are in bounds.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L530-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@inline-Tuple{Any}" href="#Base.@inline-Tuple{Any}"><code>Base.@inline</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@inline</code></pre><p>Give a hint to the compiler that this function is worth inlining.</p><p>Small functions typically do not need the <code>@inline</code> annotation, as the compiler does it automatically. By using <code>@inline</code> on bigger functions, an extra nudge can be given to the compiler to inline it. This is shown in the following example:</p><pre><code class="language-julia hljs">@inline function bigfunction(x)
    #=
        Function Definition
    =#
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L180-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@invokelatest-Tuple{Any}" href="#Base.@invokelatest-Tuple{Any}"><code>Base.@invokelatest</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@invokelatest f(args...; kwargs...)</code></pre><p>Provides a convenient way to call <a href="#Base.invokelatest-Tuple{Any, Vararg{Any, N} where N}"><code>Base.invokelatest</code></a>. <code>@invokelatest f(args...; kwargs...)</code> will simply be expanded into <code>Base.invokelatest(f, args...; kwargs...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/util.jl#L518-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@irrational-Tuple{Any, Any, Any}" href="#Base.@irrational-Tuple{Any, Any, Any}"><code>Base.@irrational</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@irrational sym val def
@irrational(sym, val, def)</code></pre><p>Define a new <code>Irrational</code> value, <code>sym</code>, with pre-computed <code>Float64</code> value <code>val</code>, and arbitrary-precision definition in terms of <code>BigFloat</code>s given by the expression <code>def</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/irrationals.jl#L162-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@isdefined-Tuple{Symbol}" href="#Base.@isdefined-Tuple{Symbol}"><code>Base.@isdefined</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@isdefined s -&gt; Bool</code></pre><p>Tests whether variable <code>s</code> is defined in the current scope.</p><p>See also <a href="@ref"><code>isdefined</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @isdefined newvar
false

julia&gt; newvar = 1
1

julia&gt; @isdefined newvar
true

julia&gt; function f()
           println(@isdefined x)
           x = 3
           println(@isdefined x)
       end
f (generic function with 1 method)

julia&gt; f()
false
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L109-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@kwdef-Tuple{Any}" href="#Base.@kwdef-Tuple{Any}"><code>Base.@kwdef</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@kwdef typedef</code></pre><p>This is a helper macro that automatically defines a keyword-based constructor for the type declared in the expression <code>typedef</code>, which must be a <code>struct</code> or <code>mutable struct</code> expression. The default argument is supplied by declaring fields of the form <code>field::T = default</code> or <code>field = default</code>. If no default is provided then the keyword argument becomes a required keyword argument in the resulting type constructor.</p><p>Inner constructors can still be defined, but at least one should accept arguments in the same form as the default inner constructor (i.e. one positional argument per field) in order to function correctly with the keyword outer constructor.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>Base.@kwdef</code> for parametric structs, and structs with supertypes requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Base.@kwdef struct Foo
           a::Int = 1         # specified default
           b::String          # required keyword
       end
Foo

julia&gt; Foo(b=&quot;hi&quot;)
Foo(1, &quot;hi&quot;)

julia&gt; Foo()
ERROR: UndefKeywordError: keyword argument b not assigned
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/util.jl#L399-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@label-Tuple{Symbol}" href="#Base.@label-Tuple{Symbol}"><code>Base.@label</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@label name</code></pre><p>Labels a statement with the symbolic label <code>name</code>. The label marks the end-point of an unconditional jump with <a href="#Base.@goto-Tuple{Symbol}"><code>@goto name</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L563-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@locals-Tuple{}" href="#Base.@locals-Tuple{}"><code>Base.@locals</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@locals()</code></pre><p>Construct a dictionary of the names (as symbols) and values of all local variables defined as of the call site.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This macro requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let x = 1, y = 2
           Base.@locals
       end
Dict{Symbol, Any} with 2 entries:
  :y =&gt; 2
  :x =&gt; 1

julia&gt; function f(x)
           local y
           show(Base.@locals); println()
           for i = 1:1
               show(Base.@locals); println()
           end
           y = 2
           show(Base.@locals); println()
           nothing
       end;

julia&gt; f(42)
Dict{Symbol, Any}(:x =&gt; 42)
Dict{Symbol, Any}(:i =&gt; 1, :x =&gt; 42)
Dict{Symbol, Any}(:y =&gt; 2, :x =&gt; 42)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/reflection.jl#L247-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@macroexpand-Tuple{Any}" href="#Base.@macroexpand-Tuple{Any}"><code>Base.@macroexpand</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@macroexpand</code></pre><p>Return equivalent expression with all macros removed (expanded).</p><p>There are differences between <code>@macroexpand</code> and <a href="#Base.macroexpand-Tuple{Module, Any}"><code>macroexpand</code></a>.</p><ul><li><p>While <a href="#Base.macroexpand-Tuple{Module, Any}"><code>macroexpand</code></a> takes a keyword argument <code>recursive</code>, <code>@macroexpand</code> is always recursive. For a non recursive macro version, see <a href="#Base.@macroexpand1-Tuple{Any}"><code>@macroexpand1</code></a>.</p></li><li><p>While <a href="#Base.macroexpand-Tuple{Module, Any}"><code>macroexpand</code></a> has an explicit <code>module</code> argument, <code>@macroexpand</code> always expands with respect to the module in which it is called.</p></li></ul><p>This is best seen in the following example:</p><pre><code class="language-julia-repl hljs">julia&gt; module M
           macro m()
               1
           end
           function f()
               (@macroexpand(@m),
                macroexpand(M, :(@m)),
                macroexpand(Main, :(@m))
               )
           end
       end
M

julia&gt; macro m()
           2
       end
@m (macro with 1 method)

julia&gt; M.f()
(1, 1, 2)</code></pre><p>With <code>@macroexpand</code> the expression expands where <code>@macroexpand</code> appears in the code (module <code>M</code> in the example). With <code>macroexpand</code> the expression expands in the module given as the first argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L118-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@macroexpand1-Tuple{Any}" href="#Base.@macroexpand1-Tuple{Any}"><code>Base.@macroexpand1</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@macroexpand1</code></pre><p>Non recursive version of <a href="#Base.@macroexpand-Tuple{Any}"><code>@macroexpand</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@noinline-Tuple{Any}" href="#Base.@noinline-Tuple{Any}"><code>Base.@noinline</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@noinline</code></pre><p>Give a hint to the compiler that it should not inline a function.</p><p>Small functions are typically inlined automatically. By using <code>@noinline</code> on small functions, auto-inlining can be prevented. This is shown in the following example:</p><pre><code class="language-julia hljs">@noinline function smallfunction(x)
    #=
        Function Definition
    =#
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the function is trivial (for example returning a constant) it might get inlined anyway.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L202-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@nospecialize-Tuple" href="#Base.@nospecialize-Tuple"><code>Base.@nospecialize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@nospecialize</code></pre><p>Applied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.</p><p>When used without arguments, it applies to all arguments of the parent scope. In local scope, this means all arguments of the containing function. In global (top-level) scope, this means all methods subsequently defined in the current module.</p><p>Specialization can reset back to the default by using <a href="#Base.@specialize-Tuple"><code>@specialize</code></a>.</p><pre><code class="language-julia hljs">function example_function(@nospecialize x)
    ...
end

function example_function(x, @nospecialize(y = 1))
    ...
end

function example_function(x, y, z)
    @nospecialize x y
    ...
end

@nospecialize
f(y) = [x for x in y]
@specialize</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L43-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@polly-Tuple{Any}" href="#Base.@polly-Tuple{Any}"><code>Base.@polly</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@polly</code></pre><p>Tells the compiler to apply the polyhedral optimizer Polly to a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L258-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@propagate_inbounds-Tuple{Any}" href="#Base.@propagate_inbounds-Tuple{Any}"><code>Base.@propagate_inbounds</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@propagate_inbounds</code></pre><p>Tells the compiler to inline a function while retaining the caller&#39;s inbounds context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@pure-Tuple{Any}" href="#Base.@pure-Tuple{Any}"><code>Base.@pure</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@pure ex
@pure(ex)</code></pre><p><code>@pure</code> gives the compiler a hint for the definition of a pure function, helping for type inference.</p><p>A pure function can only depend on immutable information. This also means a <code>@pure</code> function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect <code>@pure</code> annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions. This macro is intended for internal compiler use and may be subject to changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/expr.jl#L226-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@r_str-Tuple{Any, Vararg{Any, N} where N}" href="#Base.@r_str-Tuple{Any, Vararg{Any, N} where N}"><code>Base.@r_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@r_str -&gt; Regex</code></pre><p>Construct a regex, such as <code>r&quot;^[a-z]*$&quot;</code>, without interpolation and unescaping (except for quotation mark <code>&quot;</code> which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:</p><ul><li><code>i</code> enables case-insensitive matching</li><li><code>m</code> treats the <code>^</code> and <code>$</code> tokens as matching the start and end of individual lines, as opposed to the whole string.</li><li><code>s</code> allows the <code>.</code> modifier to match newlines.</li><li><code>x</code> enables &quot;comment mode&quot;: whitespace is enabled except when escaped with <code>\</code>, and <code>#</code> is treated as starting a comment.</li><li><code>a</code> disables <code>UCP</code> mode (enables ASCII mode). By default <code>\B</code>, <code>\b</code>, <code>\D</code>, <code>\d</code>, <code>\S</code>, <code>\s</code>, <code>\W</code>, <code>\w</code>, etc. match based on Unicode character properties. With this option, these sequences only match ASCII characters.</li></ul><p>See <a href="#Base.Regex"><code>Regex</code></a> if interpolation is needed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; match(r&quot;a+.*b+.*?d$&quot;ism, &quot;Goodbye,\nOh, angry,\nBad world\n&quot;)
RegexMatch(&quot;angry,\nBad world&quot;)</code></pre><p>This regex has the first three flags enabled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L90-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@raw_str-Tuple{Any}" href="#Base.@raw_str-Tuple{Any}"><code>Base.@raw_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@raw_str -&gt; String</code></pre><p>Create a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; println(raw&quot;\ $x&quot;)
\ $x

julia&gt; println(raw&quot;\&quot;&quot;)
&quot;

julia&gt; println(raw&quot;\\\&quot;&quot;)
\&quot;

julia&gt; println(raw&quot;\\x \\\&quot;&quot;)
\\x \&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/strings/io.jl#L491-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@s_str-Tuple{Any}" href="#Base.@s_str-Tuple{Any}"><code>Base.@s_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@s_str -&gt; SubstitutionString</code></pre><p>Construct a substitution string, used for regular expression substitutions.  Within the string, sequences of the form <code>\N</code> refer to the Nth capture group in the regex, and <code>\g&lt;groupname&gt;</code> refers to a named capture group with name <code>groupname</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; msg = &quot;#Hello# from Julia&quot;;

julia&gt; replace(msg, r&quot;#(.+)# from (?&lt;from&gt;\w+)&quot; =&gt; s&quot;FROM: \g&lt;from&gt;; MESSAGE: \1&quot;)
&quot;FROM: Julia; MESSAGE: Hello&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/regex.jl#L465-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@show-Tuple" href="#Base.@show-Tuple"><code>Base.@show</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@show</code></pre><p>Show an expression and result, returning the result. See also <a href="#Base.show-Tuple{IO, Any}"><code>show</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/show.jl#L946-L950">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@specialize-Tuple" href="#Base.@specialize-Tuple"><code>Base.@specialize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@specialize</code></pre><p>Reset the specialization hint for an argument back to the default. For details, see <a href="#Base.@nospecialize-Tuple"><code>@nospecialize</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/essentials.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@static-Tuple{Any}" href="#Base.@static-Tuple{Any}"><code>Base.@static</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@static</code></pre><p>Partially evaluate an expression at parse time.</p><p>For example, <code>@static Sys.iswindows() ? foo : bar</code> will evaluate <code>Sys.iswindows()</code> and insert either <code>foo</code> or <code>bar</code> into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a <code>ccall</code> to a non-existent function. <code>@static if Sys.isapple() foo end</code> and <code>@static foo &lt;&amp;&amp;,||&gt; bar</code> are also valid syntax.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/osutils.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@sync-Tuple{Any}" href="#Base.@sync-Tuple{Any}"><code>Base.@sync</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@sync</code></pre><p>Wait until all lexically-enclosed uses of <code>@async</code>, <code>@spawn</code>, <code>@spawnat</code> and <code>@distributed</code> are complete. All exceptions thrown by enclosed async operations are collected and thrown as a <code>CompositeException</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L376-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@task-Tuple{Any}" href="#Base.@task-Tuple{Any}"><code>Base.@task</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@task</code></pre><p>Wrap an expression in a <a href="@ref"><code>Task</code></a> without executing it, and return the <a href="@ref"><code>Task</code></a>. This only creates a task, and does not run it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a1() = sum(i for i in 1:1000);

julia&gt; b = @task a1();

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/task.jl#L99-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@threadcall-Tuple{Any, Any, Any, Vararg{Any, N} where N}" href="#Base.@threadcall-Tuple{Any, Any, Any, Vararg{Any, N} where N}"><code>Base.@threadcall</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)</code></pre><p>The <code>@threadcall</code> macro is called in the same way as <a href="@ref"><code>ccall</code></a> but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main <code>julia</code> thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the <code>UV_THREADPOOL_SIZE</code> environment variable and restarting the <code>julia</code> process.</p><p>Note that the called function should never call back into Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/threadcall.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@time-Tuple{Any}" href="#Base.@time-Tuple{Any}"><code>Base.@time</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@time</code></pre><p>A macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression. Any time spent garbage collecting (gc) or compiling is shown as a percentage.</p><p>In some cases the system will look inside the <code>@time</code> expression and compile some of the called code before execution of the top-level expression begins. When that happens, some compilation time will not be counted. To include this time you can run <code>@time @eval ...</code>.</p><p>See also <a href="#Base.@timev-Tuple{Any}"><code>@timev</code></a>, <a href="#Base.@timed-Tuple{Any}"><code>@timed</code></a>, <a href="#Base.@elapsed-Tuple{Any}"><code>@elapsed</code></a>, and <a href="#Base.@allocated-Tuple{Any}"><code>@allocated</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For more serious benchmarking, consider the <code>@btime</code> macro from the BenchmarkTools.jl package which among other things evaluates the function multiple times in order to reduce noise.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; x = rand(10,10);

julia&gt; @time x * x;
  0.606588 seconds (2.19 M allocations: 116.555 MiB, 3.75% gc time, 99.94% compilation time)

julia&gt; @time x * x;
  0.000009 seconds (1 allocation: 896 bytes)

julia&gt; @time begin
           sleep(0.3)
           1+1
       end
  0.301395 seconds (8 allocations: 336 bytes)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/timing.jl#L167-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@timed-Tuple{Any}" href="#Base.@timed-Tuple{Any}"><code>Base.@timed</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@timed</code></pre><p>A macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.</p><p>In some cases the system will look inside the <code>@timed</code> expression and compile some of the called code before execution of the top-level expression begins. When that happens, some compilation time will not be counted. To include this time you can run <code>@timed @eval ...</code>.</p><p>See also <a href="#Base.@time-Tuple{Any}"><code>@time</code></a>, <a href="#Base.@timev-Tuple{Any}"><code>@timev</code></a>, <a href="#Base.@elapsed-Tuple{Any}"><code>@elapsed</code></a>, and <a href="#Base.@allocated-Tuple{Any}"><code>@allocated</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; stats = @timed rand(10^6);

julia&gt; stats.time
0.006634834

julia&gt; stats.bytes
8000256

julia&gt; stats.gctime
0.0055765

julia&gt; propertynames(stats.gcstats)
(:allocd, :malloc, :realloc, :poolalloc, :bigalloc, :freecall, :total_time, :pause, :full_sweep)

julia&gt; stats.gcstats.total_time
5576500</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The return type of this macro was changed from <code>Tuple</code> to <code>NamedTuple</code> in Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/timing.jl#L327-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@timev-Tuple{Any}" href="#Base.@timev-Tuple{Any}"><code>Base.@timev</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@timev</code></pre><p>This is a verbose version of the <code>@time</code> macro. It first prints the same information as <code>@time</code>, then any non-zero memory allocation counters, and then returns the value of the expression.</p><p>See also <a href="#Base.@time-Tuple{Any}"><code>@time</code></a>, <a href="#Base.@timed-Tuple{Any}"><code>@timed</code></a>, <a href="#Base.@elapsed-Tuple{Any}"><code>@elapsed</code></a>, and <a href="#Base.@allocated-Tuple{Any}"><code>@allocated</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; x = rand(10,10);

julia&gt; @timev x * x;
  0.546770 seconds (2.20 M allocations: 116.632 MiB, 4.23% gc time, 99.94% compilation time)
elapsed time (ns): 546769547
gc time (ns):      23115606
bytes allocated:   122297811
pool allocs:       2197930
non-pool GC allocs:1327
malloc() calls:    36
realloc() calls:   5
GC pauses:         3

julia&gt; @timev x * x;
  0.000010 seconds (1 allocation: 896 bytes)
elapsed time (ns): 9848
bytes allocated:   896
pool allocs:       1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/timing.jl#L219-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@v_str-Tuple{Any}" href="#Base.@v_str-Tuple{Any}"><code>Base.@v_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@v_str</code></pre><p>String macro used to parse a string to a <a href="#Base.VersionNumber"><code>VersionNumber</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; v&quot;1.2.3&quot;
v&quot;1.2.3&quot;

julia&gt; v&quot;2.0.1-rc1&quot;
v&quot;2.0.1-rc1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/version.jl#L132-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@view-Tuple{Any}" href="#Base.@view-Tuple{Any}"><code>Base.@view</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@view A[inds...]</code></pre><p>Creates a <code>SubArray</code> from an indexing expression. This can only be applied directly to a reference expression (e.g. <code>@view A[1,2:end]</code>), and should <em>not</em> be used as the target of an assignment (e.g. <code>@view(A[1,2:end]) = ...</code>).  See also <a href="#Base.@views-Tuple{Any}"><code>@views</code></a> to switch an entire block of code to use views for slicing.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Using <code>begin</code> in an indexing expression to refer to the first index requires at least Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia&gt; b = @view A[:, 1]
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:
 1
 3

julia&gt; fill!(b, 0)
2-element view(::Matrix{Int64}, :, 1) with eltype Int64:
 0
 0

julia&gt; A
2×2 Matrix{Int64}:
 0  2
 0  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/views.jl#L77-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.@views-Tuple{Any}" href="#Base.@views-Tuple{Any}"><code>Base.@views</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@views expression</code></pre><p>Convert every array-slicing operation in the given expression (which may be a <code>begin</code>/<code>end</code> block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit <a href="#Base.getindex"><code>getindex</code></a> calls (as opposed to <code>array[...]</code>) are unaffected.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>@views</code> macro only affects <code>array[...]</code> expressions that appear explicitly in the given <code>expression</code>, not array slicing that occurs in functions called by that code.</p></div></div><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>Using <code>begin</code> in an indexing expression to refer to the first index requires at least Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = zeros(3, 3);

julia&gt; @views for row in 1:3
           b = A[row, :]
           b[:] .= row
       end

julia&gt; A
3×3 Matrix{Float64}:
 1.0  1.0  1.0
 2.0  2.0  2.0
 3.0  3.0  3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/views.jl#L195-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.@big_str-Tuple{Any}" href="#Core.@big_str-Tuple{Any}"><code>Core.@big_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@big_str str
@big_str(str)</code></pre><p>Parse a string into a <a href="@ref"><code>BigInt</code></a> or <a href="@ref"><code>BigFloat</code></a>, and throw an <code>ArgumentError</code> if the string is not a valid number. For integers <code>_</code> is allowed in the string as a separator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; big&quot;123_456&quot;
123456

julia&gt; big&quot;7891.5&quot;
7891.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L623-L639">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.@cmd-Tuple{Any}" href="#Core.@cmd-Tuple{Any}"><code>Core.@cmd</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@cmd str</code></pre><p>Similar to <code>cmd</code>, generate a <code>Cmd</code> from the <code>str</code> string which represents the shell command(s) to be executed. The <a href="#Base.Cmd"><code>Cmd</code></a> object can be run as a process and can outlive the spawning julia process (see <code>Cmd</code> for more).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cm = @cmd &quot; echo 1 &quot;
`echo 1`

julia&gt; run(cm)
1
Process(`echo 1`, ProcessExited(0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/cmd.jl#L410-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.@int128_str-Tuple{Any}" href="#Core.@int128_str-Tuple{Any}"><code>Core.@int128_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@int128_str str
@int128_str(str)</code></pre><p><code>@int128_str</code> parses a string into a Int128 Throws an <code>ArgumentError</code> if the string is not a valid integer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L601-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.@uint128_str-Tuple{Any}" href="#Core.@uint128_str-Tuple{Any}"><code>Core.@uint128_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@uint128_str str
@uint128_str(str)</code></pre><p><code>@uint128_str</code> parses a string into a UInt128 Throws an <code>ArgumentError</code> if the string is not a valid integer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/1b93d53fc4bb59350ada898038ed4de2994cce33/base/int.jl#L612-L618">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interfaces/">« Resizing Interfaces</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Saturday 18 September 2021 14:46">Saturday 18 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
