var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Modules = [ResizingTools, Base]","category":"page"},{"location":"references/#ResizingTools.AbstractRDArray","page":"References","title":"ResizingTools.AbstractRDArray","text":"AbstractRDArray{T,N} <: DenseArray{T,N}\n\nN-dimensional resizable dense array with elements of type T with some pre-defined array methods.\n\n\n\n\n\n","category":"type"},{"location":"references/#ResizingTools.SimpleRDArray","page":"References","title":"ResizingTools.SimpleRDArray","text":"SimpleRDArray{T,N} <: AbstractRDArray{T,N}\n\nA simple implementation of resizable dense array.\n\n\n\n\n\n","category":"type"},{"location":"references/#ResizingTools.Size","page":"References","title":"ResizingTools.Size","text":"Size{N}\n\nA mutable warpper of NTuple{N,Int} used to represent the dimension of an resizable array. Mutate 'i'th dimension to ndim by sz[i] = ndim mutate the whole dimensions to ndims by set!(sz, ndims).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.resize!-Tuple{AbstractArray, Any, Integer}","page":"References","title":"Base.resize!","text":"Base.resize!(A::AbstractArray{T,N}, I, i::Integer)\n\nResize the ith dimension to I, where I can be an integer or a colon or an iterator.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.resize!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}}} where {T, N}","page":"References","title":"Base.resize!","text":"Base.resize!(A::AbstractArray{T,N}, sz)\n\nResize A to sz. sz can be a tuple of integer or Colon or iterator.\n\n\n\n\n\n","category":"method"},{"location":"references/#ResizingTools.getsize-Tuple{AbstractArray, Integer}","page":"References","title":"ResizingTools.getsize","text":"getsize(A::AbstractArray, [dim])\n\nReturn the dimensions of A unlike size which may not return a NTuple{N,Int}. For a AbstractRDArray, convert(Tuple, getsize(A)) is the default implementation of size(A).\n\n\n\n\n\n","category":"method"},{"location":"references/#ResizingTools.isresizable-Tuple{AbstractArray}","page":"References","title":"ResizingTools.isresizable","text":"isresizable(A::AbstractArray)\n\nCheck if the type of A is resizable.\n\n!!! Note\n\n`isresizable(A)` for a `Vector` or a `BitVector` will return `false` even\nwhich can be resized by `resize!(A, n)`.\n\n\n\n\n\n","category":"method"},{"location":"references/#ResizingTools.mapindex-Tuple{AbstractArray, Tuple}","page":"References","title":"ResizingTools.mapindex","text":"mapindex(A::AbstractArray, I::Tuple)\nmapindex(A::AbstractArray, i::Integer, I)\n\nMap the index or indices I of A to index of parent(A).\n\n\n\n\n\n","category":"method"},{"location":"references/#ResizingTools.setsize!-Tuple{AbstractArray, Integer, Integer}","page":"References","title":"ResizingTools.setsize!","text":"setsize!(A::AbstractArray, d::Integer, i::Integer)\n\nSet the ith dimension to d.\n\n\n\n\n\n","category":"method"},{"location":"references/#ResizingTools.setsize!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Tuple{Vararg{Any, N}}}} where {T, N}","page":"References","title":"ResizingTools.setsize!","text":"setsize!(A::AbstractArray{T,N}, sz) where {T,N}\n\nSet the size of A to sz\n\n\n\n\n\n","category":"method"},{"location":"references/#Base","page":"References","title":"Base","text":"Base\n\nThe base library of Julia. Base is a module that contains basic functionality (the contents of base/). All modules implicitly contain using Base, since this is needed in the vast majority of cases.\n\n\n\n\n\n","category":"module"},{"location":"references/#Base.ARGS","page":"References","title":"Base.ARGS","text":"ARGS\n\nAn array of the command line arguments passed to Julia, as strings.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.AbstractVecOrMat","page":"References","title":"Base.AbstractVecOrMat","text":"AbstractVecOrMat{T}\n\nUnion type of AbstractVector{T} and AbstractMatrix{T}.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.C_NULL","page":"References","title":"Base.C_NULL","text":"C_NULL\n\nThe C null pointer constant, sometimes used when calling external code.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.DEPOT_PATH","page":"References","title":"Base.DEPOT_PATH","text":"DEPOT_PATH\n\nA stack of \"depot\" locations where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. By default it includes:\n\n~/.julia where ~ is the user home as appropriate on the system;\nan architecture-specific shared system directory, e.g. /usr/local/share/julia;\nan architecture-independent shared system directory, e.g. /usr/share/julia.\n\nSo DEPOT_PATH might be:\n\n[joinpath(homedir(), \".julia\"), \"/usr/local/share/julia\", \"/usr/share/julia\"]\n\nThe first entry is the \"user depot\" and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.\n\nDEPOT_PATH is populated based on the JULIA_DEPOT_PATH environment variable if set.\n\nDEPOT_PATH contents\n\nEach entry in DEPOT_PATH is a path to a directory which contains subdirectories used by Julia for various purposes. Here is an overview of some of the subdirectories that may exist in a depot:\n\nclones: Contains full clones of package repos. Maintained by Pkg.jl and used as a cache.\ncompiled: Contains precompiled *.ji files for packages. Maintained by Julia.\ndev: Default directory for Pkg.develop. Maintained by Pkg.jl and the user.\nenvironments: Default package environments. For instance the global environment for a specific julia version. Maintained by Pkg.jl.\nlogs: Contains logs of Pkg and REPL operations. Maintained by Pkg.jl and Julia.\npackages: Contains packages, some of which were explicitly installed and some which are implicit dependencies. Maintained by Pkg.jl.\nregistries: Contains package registries. By default only General. Maintained by Pkg.jl.\n\nSee also: JULIA_DEPOT_PATH, and Code Loading.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.DenseVecOrMat","page":"References","title":"Base.DenseVecOrMat","text":"DenseVecOrMat{T}\n\nUnion type of DenseVector{T} and DenseMatrix{T}.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.ENDIAN_BOM","page":"References","title":"Base.ENDIAN_BOM","text":"ENDIAN_BOM\n\nThe 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value 0x04030201. Big-endian machines will contain the value 0x01020304.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.ENV","page":"References","title":"Base.ENV","text":"ENV\n\nReference to the singleton EnvDict, providing a dictionary interface to system environment variables.\n\n(On Windows, system environment variables are case-insensitive, and ENV correspondingly converts all keys to uppercase for display, iteration, and copying. Portable code should not rely on the ability to distinguish variables by case, and should beware that setting an ostensibly lowercase variable may result in an uppercase ENV key.)\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.Inf","page":"References","title":"Base.Inf","text":"Inf, Inf64\n\nPositive infinity of type Float64.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.Inf16","page":"References","title":"Base.Inf16","text":"Inf16\n\nPositive infinity of type Float16.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.Inf32","page":"References","title":"Base.Inf32","text":"Inf32\n\nPositive infinity of type Float32.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.Inf64","page":"References","title":"Base.Inf64","text":"Inf, Inf64\n\nPositive infinity of type Float64.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.LOAD_PATH","page":"References","title":"Base.LOAD_PATH","text":"LOAD_PATH\n\nAn array of paths for using and import statements to consider as project environments or package directories when loading code. It is populated based on the JULIA_LOAD_PATH environment variable if set; otherwise it defaults to [\"@\", \"@v#.#\", \"@stdlib\"]. Entries starting with @ have special meanings:\n\n@ refers to the \"current active environment\", the initial value of which is initially determined by the JULIA_PROJECT environment variable or the --project command-line option.\n@stdlib expands to the absolute path of the current Julia installation's standard library directory.\n@name refers to a named environment, which are stored in depots (see JULIA_DEPOT_PATH) under the environments subdirectory. The user's named environments are stored in ~/.julia/environments so @name would refer to the environment in ~/.julia/environments/name if it exists and contains a Project.toml file. If name contains # characters, then they are replaced with the major, minor and patch components of the Julia version number. For example, if you are running Julia 1.2 then @v#.# expands to @v1.2 and will look for an environment by that name, typically at ~/.julia/environments/v1.2.\n\nThe fully expanded value of LOAD_PATH that is searched for projects and packages can be seen by calling the Base.load_path() function.\n\nSee also: JULIA_LOAD_PATH, JULIA_PROJECT, JULIA_DEPOT_PATH, and Code Loading.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.NaN","page":"References","title":"Base.NaN","text":"NaN, NaN64\n\nA not-a-number value of type Float64.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.NaN16","page":"References","title":"Base.NaN16","text":"NaN16\n\nA not-a-number value of type Float16.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.NaN32","page":"References","title":"Base.NaN32","text":"NaN32\n\nA not-a-number value of type Float32.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.NaN64","page":"References","title":"Base.NaN64","text":"NaN, NaN64\n\nA not-a-number value of type Float64.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.PROGRAM_FILE","page":"References","title":"Base.PROGRAM_FILE","text":"PROGRAM_FILE\n\nA string containing the script name passed to Julia from the command line. Note that the script name remains unchanged from within included files. Alternatively see @__FILE__.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.VERSION","page":"References","title":"Base.VERSION","text":"VERSION\n\nA VersionNumber object describing which version of Julia is in use. For details see Version Number Literals.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.VecOrMat","page":"References","title":"Base.VecOrMat","text":"VecOrMat{T}\n\nUnion type of Vector{T} and Matrix{T}.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.im","page":"References","title":"Base.im","text":"im\n\nThe imaginary unit.\n\nExamples\n\njulia> im * im\n-1 + 0im\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.missing","page":"References","title":"Base.missing","text":"missing\n\nThe singleton instance of type Missing representing a missing value.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.stderr","page":"References","title":"Base.stderr","text":"stderr\n\nGlobal variable referring to the standard error stream.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.stdin","page":"References","title":"Base.stdin","text":"stdin\n\nGlobal variable referring to the standard input stream.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.stdout","page":"References","title":"Base.stdout","text":"stdout\n\nGlobal variable referring to the standard out stream.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.text_colors","page":"References","title":"Base.text_colors","text":"Dictionary of color codes for the terminal.\n\nAvailable colors are: :normal, :default, :bold, :black, :blink, :blue, :cyan, :green, :hidden, :light_black, :light_blue, :light_cyan, :light_green, :light_magenta, :light_red, :light_yellow, :magenta, :nothing, :red, :reverse, :underline, :white, or  :yellow as well as the integers 0 to 255 inclusive.\n\nThe color :default will print text in the default color while the color :normal will print text with all text properties (like boldness) reset. Printing with the color :nothing will print the string without modifications.\n\n\n\n\n\n","category":"constant"},{"location":"references/#Base.:=>","page":"References","title":"Base.:=>","text":"Pair(x, y)\nx => y\n\nConstruct a Pair object with type Pair{typeof(x), typeof(y)}. The elements are stored in the fields first and second. They can also be accessed via iteration (but a Pair is treated as a single \"scalar\" for broadcasting operations).\n\nSee also: Dict\n\nExamples\n\njulia> p = \"foo\" => 7\n\"foo\" => 7\n\njulia> typeof(p)\nPair{String, Int64}\n\njulia> p.first\n\"foo\"\n\njulia> for x in p\n           println(x)\n       end\nfoo\n7\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractChannel","page":"References","title":"Base.AbstractChannel","text":"AbstractChannel{T}\n\nRepresentation of a channel passing objects of type T.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractDict","page":"References","title":"Base.AbstractDict","text":"AbstractDict{K, V}\n\nSupertype for dictionary-like types with keys of type K and values of type V. Dict, IdDict and other types are subtypes of this. An AbstractDict{K, V} should be an iterator of Pair{K, V}.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractIrrational","page":"References","title":"Base.AbstractIrrational","text":"AbstractIrrational <: Real\n\nNumber type representing an exact irrational value, which is automatically rounded to the correct precision in arithmetic operations with other numeric quantities.\n\nSubtypes MyIrrational <: AbstractIrrational should implement at least ==(::MyIrrational, ::MyIrrational), hash(x::MyIrrational, h::UInt), and convert(::Type{F}, x::MyIrrational) where {F <: Union{BigFloat,Float32,Float64}}.\n\nIf a subtype is used to represent values that may occasionally be rational (e.g. a square-root type that represents √n for integers n will give a rational result when n is a perfect square), then it should also implement isinteger, iszero, isone, and == with Real values (since all of these default to false for AbstractIrrational types), as well as defining hash to equal that of the corresponding Rational.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractLock","page":"References","title":"Base.AbstractLock","text":"AbstractLock\n\nAbstract supertype describing types that implement the synchronization primitives: lock, trylock, unlock, and islocked.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractMatch","page":"References","title":"Base.AbstractMatch","text":"AbstractMatch objects are used to represent information about matches found in a string    using an AbstractPattern.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractMatrix","page":"References","title":"Base.AbstractMatrix","text":"AbstractMatrix{T}\n\nSupertype for two-dimensional arrays (or array-like types) with elements of type T. Alias for AbstractArray{T,2}.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractPattern","page":"References","title":"Base.AbstractPattern","text":"An abstract type representing any sort of pattern matching expression (typically a regular\nexpression).\n`AbstractPattern` objects can be used to match strings with [`match`](@ref).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractPipe","page":"References","title":"Base.AbstractPipe","text":"AbstractPipe\n\nAbstractPipe is the abstract supertype for IO pipes that provide for communication between processes.\n\nIf pipe isa AbstractPipe, it must obey the following interface:\n\npipe.in or pipe.in_stream, if present, must be of type IO and be used to provide input to the pipe\npipe.out or pipe.out_stream, if present, must be of type IO and be used for output from the pipe\npipe.err or pipe.err_stream, if present, must be of type IO and be used for writing errors from the pipe\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractRange","page":"References","title":"Base.AbstractRange","text":"AbstractRange{T}\n\nSupertype for ranges with elements of type T. UnitRange and other types are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractSet","page":"References","title":"Base.AbstractSet","text":"AbstractSet{T}\n\nSupertype for set-like types whose elements are of type T. Set, BitSet and other types are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractUnitRange","page":"References","title":"Base.AbstractUnitRange","text":"AbstractUnitRange{T} <: OrdinalRange{T, T}\n\nSupertype for ranges with a step size of oneunit(T) with elements of type T. UnitRange and other types are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AbstractVector","page":"References","title":"Base.AbstractVector","text":"AbstractVector{T}\n\nSupertype for one-dimensional arrays (or array-like types) with elements of type T. Alias for AbstractArray{T,1}.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AlwaysLockedST","page":"References","title":"Base.AlwaysLockedST","text":"AlwaysLockedST\n\nThis struct does not implement a real lock, but instead pretends to be always locked on the original thread it was allocated on, and simply ignores all other interactions. It also does not synchronize tasks; for that use a real lock such as RecursiveLock. This can be used in the place of a real lock to, instead, simply and cheaply assert that the operation is only occurring on a single cooperatively-scheduled thread. It is thus functionally equivalent to allocating a real, recursive, task-unaware lock immediately calling lock on it, and then never calling a matching unlock, except that calling lock from another thread will throw a concurrency violation exception.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AsyncCollector-Tuple{Any, Any, Vararg{Any, N} where N}","page":"References","title":"Base.AsyncCollector","text":"AsyncCollector(f, results, c...; ntasks=0, batch_size=nothing) -> iterator\n\nReturn an iterator which applies f to each element of c asynchronously and collects output into results.\n\nKeyword args ntasks and batch_size have the same behavior as in asyncmap. If batch_size is specified, f must be a function which operates on an array of argument tuples.\n\nnote: Note\niterate(::AsyncCollector, state) -> (nothing, state). A successful return from iterate indicates that the next element from the input collection is being processed asynchronously. It blocks until a free worker task becomes available.\n\nnote: Note\nfor _ in AsyncCollector(f, results, c...; ntasks=1) end is equivalent to map!(f, results, c...).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.AsyncCondition","page":"References","title":"Base.AsyncCondition","text":"AsyncCondition()\n\nCreate a async condition that wakes up tasks waiting for it (by calling wait on the object) when notified from C by a call to uv_async_send. Waiting tasks are woken with an error when the object is closed (by close). Use isopen to check whether it is still active.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.AsyncCondition-Tuple{Function}","page":"References","title":"Base.AsyncCondition","text":"AsyncCondition(callback::Function)\n\nCreate a async condition that calls the given callback function. The callback is passed one argument, the async condition object itself.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.AsyncGenerator","page":"References","title":"Base.AsyncGenerator","text":"AsyncGenerator(f, c...; ntasks=0, batch_size=nothing) -> iterator\n\nApply f to each element of c using at most ntasks asynchronous tasks.\n\nKeyword args ntasks and batch_size have the same behavior as in asyncmap. If batch_size is specified, f must be a function which operates on an array of argument tuples.\n\nnote: Note\ncollect(AsyncGenerator(f, c...; ntasks=1)) is equivalent to map(f, c...).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.BitArray","page":"References","title":"Base.BitArray","text":"BitArray{N} <: AbstractArray{Bool, N}\n\nSpace-efficient N-dimensional boolean array, using just one bit for each boolean value.\n\nBitArrays pack up to 64 values into every 8 bytes, resulting in an 8x space efficiency over Array{Bool, N} and allowing some operations to work on 64 values at once.\n\nBy default, Julia returns BitArrays from broadcasting operations that generate boolean elements (including dotted-comparisons like .==) as well as from the functions trues and falses.\n\nnote: Note\nDue to its packed storage format, concurrent access to the elements of a BitArray where at least one of them is a write is not thread safe.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.BitArray-Tuple{Any}","page":"References","title":"Base.BitArray","text":"BitArray(itr)\n\nConstruct a BitArray generated by the given iterable object. The shape is inferred from the itr object.\n\nExamples\n\njulia> BitArray([1 0; 0 1])\n2×2 BitMatrix:\n 1  0\n 0  1\n\njulia> BitArray(x+y == 3 for x = 1:2, y = 1:3)\n2×3 BitMatrix:\n 0  1  0\n 1  0  0\n\njulia> BitArray(x+y == 3 for x = 1:2 for y = 1:3)\n6-element BitVector:\n 0\n 1\n 0\n 1\n 0\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.BitArray-Tuple{UndefInitializer, Vararg{Integer, N} where N}","page":"References","title":"Base.BitArray","text":"BitArray(undef, dims::Integer...)\nBitArray{N}(undef, dims::NTuple{N,Int})\n\nConstruct an undef BitArray with the given dimensions. Behaves identically to the Array constructor. See undef.\n\nExamples\n\njulia> BitArray(undef, 2, 2)\n2×2 BitMatrix:\n 0  0\n 0  0\n\njulia> BitArray(undef, (3, 1))\n3×1 BitMatrix:\n 0\n 0\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.BitSet-Tuple{Any}","page":"References","title":"Base.BitSet","text":"BitSet([itr])\n\nConstruct a sorted set of Ints generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use Set instead.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.BitVector-Tuple{Tuple{Vararg{Bool, N} where N}}","page":"References","title":"Base.BitVector","text":"BitVector(nt::Tuple{Vararg{Bool}})\n\nConstruct a BitVector from a tuple of Bool.\n\nExamples\n\njulia> nt = (true, false, true, false)\n(true, false, true, false)\n\njulia> BitVector(nt)\n4-element BitVector:\n 1\n 0\n 1\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.BottomRF","page":"References","title":"Base.BottomRF","text":"BottomRF(rf) -> rf′\n\n\"Bottom\" reducing function.  This is a thin wrapper around the op argument passed to foldl-like functions for handling the initial invocation to call reduce_first.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.CFunction","page":"References","title":"Base.CFunction","text":"CFunction struct\n\nGarbage-collection handle for the return value from @cfunction when the first argument is annotated with '$'. Like all cfunction handles, it should be passed to ccall as a Ptr{Cvoid}, and will be converted automatically at the call site to the appropriate type.\n\nSee @cfunction.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cchar","page":"References","title":"Base.Cchar","text":"Cchar\n\nEquivalent to the native char c-type.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cdouble","page":"References","title":"Base.Cdouble","text":"Cdouble\n\nEquivalent to the native double c-type (Float64).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cfloat","page":"References","title":"Base.Cfloat","text":"Cfloat\n\nEquivalent to the native float c-type (Float32).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Channel","page":"References","title":"Base.Channel","text":"Channel{T=Any}(size::Int=0)\n\nConstructs a Channel with an internal buffer that can hold a maximum of size objects of type T. put! calls on a full channel block until an object is removed with take!.\n\nChannel(0) constructs an unbuffered channel. put! blocks until a matching take! is called. And vice-versa.\n\nOther constructors:\n\nChannel(): default constructor, equivalent to Channel{Any}(0)\nChannel(Inf): equivalent to Channel{Any}(typemax(Int))\nChannel(sz): equivalent to Channel{Any}(sz)\n\ncompat: Julia 1.3\nThe default constructor Channel() and default size=0 were added in Julia 1.3.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Channel-Union{Tuple{Function}, Tuple{T}, Tuple{Function, Any}} where T","page":"References","title":"Base.Channel","text":"Channel{T=Any}(func::Function, size=0; taskref=nothing, spawn=false)\n\nCreate a new task from func, bind it to a new channel of type T and size size, and schedule the task, all in a single call.\n\nfunc must accept the bound channel as its only argument.\n\nIf you need a reference to the created task, pass a Ref{Task} object via the keyword argument taskref.\n\nIf spawn = true, the Task created for func may be scheduled on another thread in parallel, equivalent to creating a task via Threads.@spawn.\n\nReturn a Channel.\n\nExamples\n\njulia> chnl = Channel() do ch\n           foreach(i -> put!(ch, i), 1:4)\n       end;\n\njulia> typeof(chnl)\nChannel{Any}\n\njulia> for i in chnl\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n\nReferencing the created task:\n\njulia> taskref = Ref{Task}();\n\njulia> chnl = Channel(taskref=taskref) do ch\n           println(take!(ch))\n       end;\n\njulia> istaskdone(taskref[])\nfalse\n\njulia> put!(chnl, \"Hello\");\nHello\n\njulia> istaskdone(taskref[])\ntrue\n\ncompat: Julia 1.3\nThe spawn= parameter was added in Julia 1.3. This constructor was added in Julia 1.3. In earlier versions of Julia, Channel used keyword arguments to set size and T, but those constructors are deprecated.\n\njulia> chnl = Channel{Char}(1, spawn=true) do ch\n           for c in \"hello world\"\n               put!(ch, c)\n           end\n       end\nChannel{Char}(1) (1 item available)\n\njulia> String(collect(chnl))\n\"hello world\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.Cint","page":"References","title":"Base.Cint","text":"Cint\n\nEquivalent to the native signed int c-type (Int32).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cintmax_t","page":"References","title":"Base.Cintmax_t","text":"Cintmax_t\n\nEquivalent to the native intmax_t c-type (Int64).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Clong","page":"References","title":"Base.Clong","text":"Clong\n\nEquivalent to the native signed long c-type.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Clonglong","page":"References","title":"Base.Clonglong","text":"Clonglong\n\nEquivalent to the native signed long long c-type (Int64).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cmd","page":"References","title":"Base.Cmd","text":"Cmd(cmd::Cmd; ignorestatus, detach, windows_verbatim, windows_hide, env, dir)\n\nConstruct a new Cmd object, representing an external program and arguments, from cmd, while changing the settings of the optional keyword arguments:\n\nignorestatus::Bool: If true (defaults to false), then the Cmd will not throw an error if the return code is nonzero.\ndetach::Bool: If true (defaults to false), then the Cmd will be run in a new process group, allowing it to outlive the julia process and not have Ctrl-C passed to it.\nwindows_verbatim::Bool: If true (defaults to false), then on Windows the Cmd will send a command-line string to the process with no quoting or escaping of arguments, even arguments containing spaces. (On Windows, arguments are sent to a program as a single \"command-line\" string, and programs are responsible for parsing it into arguments. By default, empty arguments and arguments with spaces or tabs are quoted with double quotes \" in the command line, and \\ or \" are preceded by backslashes. windows_verbatim=true is useful for launching programs that parse their command line in nonstandard ways.) Has no effect on non-Windows systems.\nwindows_hide::Bool: If true (defaults to false), then on Windows no new console window is displayed when the Cmd is executed. This has no effect if a console is already open or on non-Windows systems.\nenv: Set environment variables to use when running the Cmd. env is either a dictionary mapping strings to strings, an array of strings of the form \"var=val\", an array or tuple of \"var\"=>val pairs. In order to modify (rather than replace) the existing environment, initialize env with copy(ENV) and then set env[\"var\"]=val as desired.  To add to an environment block within a Cmd object without replacing all elements, use addenv() which will return a Cmd object with the updated environment.\ndir::AbstractString: Specify a working directory for the command (instead of the current directory).\n\nFor any keywords that are not specified, the current settings from cmd are used. Normally, to create a Cmd object in the first place, one uses backticks, e.g.\n\nCmd(`echo \"Hello world\"`, ignorestatus=true, detach=false)\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.CodeUnits","page":"References","title":"Base.CodeUnits","text":"CodeUnits(s::AbstractString)\n\nWrap a string (without copying) in an immutable vector-like object that accesses the code units of the string's representation.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Colon","page":"References","title":"Base.Colon","text":"Colon()\n\nColons (:) are used to signify indexing entire objects or dimensions at once.\n\nVery few operations are defined on Colons directly; instead they are converted by to_indices to an internal vector type (Base.Slice) to represent the collection of indices they span before being used.\n\nThe singleton instance of Colon is also a function used to construct ranges; see :.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Complex","page":"References","title":"Base.Complex","text":"Complex{T<:Real} <: Number\n\nComplex number type with real and imaginary part of type T.\n\nComplexF16, ComplexF32 and ComplexF64 are aliases for Complex{Float16}, Complex{Float32} and Complex{Float64} respectively.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.ComposedFunction","page":"References","title":"Base.ComposedFunction","text":"ComposedFunction{Outer,Inner} <: Function\n\nRepresents the composition of two callable objects outer::Outer and inner::Inner. That is\n\nComposedFunction(outer, inner)(args...; kw...) === outer(inner(args...; kw...))\n\nThe preferred way to construct instance of ComposedFunction is to use the composition operator ∘:\n\njulia> sin ∘ cos === ComposedFunction(sin, cos)\ntrue\n\njulia> typeof(sin∘cos)\nComposedFunction{typeof(sin), typeof(cos)}\n\nThe composed pieces are stored in the fields of ComposedFunction and can be retrieved as follows:\n\njulia> composition = sin ∘ cos\nsin ∘ cos\n\njulia> composition.outer === sin\ntrue\n\njulia> composition.inner === cos\ntrue\n\ncompat: Julia 1.6\nComposedFunction requires at least Julia 1.6. In earlier versions ∘ returns an anonymous function instead.\n\nSee also ∘.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.CompositeException","page":"References","title":"Base.CompositeException","text":"CompositeException\n\nWrap a Vector of exceptions thrown by a Task (e.g. generated from a remote worker over a channel or an asynchronously executing local I/O write or a remote worker under pmap) with information about the series of exceptions. For example, if a group of workers are executing several tasks, and multiple workers fail, the resulting CompositeException will contain a \"bundle\" of information from each worker indicating where and why the exception(s) occurred.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Condition","page":"References","title":"Base.Condition","text":"Condition()\n\nCreate an edge-triggered event source that tasks can wait for. Tasks that call wait on a Condition are suspended and queued. Tasks are woken up when notify is later called on the Condition. Edge triggering means that only tasks waiting at the time notify is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The Channel and Threads.Event types do this, and can be used for level-triggered events.\n\nThis object is NOT thread-safe. See Threads.Condition for a thread-safe version.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cptrdiff_t","page":"References","title":"Base.Cptrdiff_t","text":"Cptrdiff_t\n\nEquivalent to the native ptrdiff_t c-type (Int).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cshort","page":"References","title":"Base.Cshort","text":"Cshort\n\nEquivalent to the native signed short c-type (Int16).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Csize_t","page":"References","title":"Base.Csize_t","text":"Csize_t\n\nEquivalent to the native size_t c-type (UInt).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cssize_t","page":"References","title":"Base.Cssize_t","text":"Cssize_t\n\nEquivalent to the native ssize_t c-type.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cstring","page":"References","title":"Base.Cstring","text":"Cstring\n\nA C-style string composed of the native character type Cchars. Cstrings are NUL-terminated. For C-style strings composed of the native wide character type, see Cwstring. For more information about string interopability with C, see the manual.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cuchar","page":"References","title":"Base.Cuchar","text":"Cuchar\n\nEquivalent to the native unsigned char c-type (UInt8).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cuint","page":"References","title":"Base.Cuint","text":"Cuint\n\nEquivalent to the native unsigned int c-type (UInt32).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cuintmax_t","page":"References","title":"Base.Cuintmax_t","text":"Cuintmax_t\n\nEquivalent to the native uintmax_t c-type (UInt64).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Culong","page":"References","title":"Base.Culong","text":"Culong\n\nEquivalent to the native unsigned long c-type.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Culonglong","page":"References","title":"Base.Culonglong","text":"Culonglong\n\nEquivalent to the native unsigned long long c-type (UInt64).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cushort","page":"References","title":"Base.Cushort","text":"Cushort\n\nEquivalent to the native unsigned short c-type (UInt16).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cwchar_t","page":"References","title":"Base.Cwchar_t","text":"Cwchar_t\n\nEquivalent to the native wchar_t c-type (Int32).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Cwstring","page":"References","title":"Base.Cwstring","text":"Cwstring\n\nA C-style string composed of the native wide character type Cwchar_ts. Cwstrings are NUL-terminated. For C-style strings composed of the native character type, see Cstring. For more information about string interopability with C, see the manual.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.CyclePadding","page":"References","title":"Base.CyclePadding","text":"CyclePadding(padding, total_size)\n\nCylces an iterator of Padding structs, restarting the padding at total_size. E.g. if padding is all the padding in a struct and total_size is the total aligned size of that array, CyclePadding will correspond to the padding in an infinite vector of such structs.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.DenseMatrix","page":"References","title":"Base.DenseMatrix","text":"DenseMatrix{T}\n\nTwo-dimensional DenseArray with elements of type T. Alias for DenseArray{T,2}.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.DenseVector","page":"References","title":"Base.DenseVector","text":"DenseVector{T}\n\nOne-dimensional DenseArray with elements of type T. Alias for DenseArray{T,1}.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Dict","page":"References","title":"Base.Dict","text":"Dict([itr])\n\nDict{K,V}() constructs a hash table with keys of type K and values of type V. Keys are compared with isequal and hashed with hash.\n\nGiven a single iterable argument, constructs a Dict whose key-value pairs are taken from 2-tuples (key,value) generated by the argument.\n\nExamples\n\njulia> Dict([(\"A\", 1), (\"B\", 2)])\nDict{String, Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n\nAlternatively, a sequence of pair arguments may be passed.\n\njulia> Dict(\"A\"=>1, \"B\"=>2)\nDict{String, Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.DimensionMismatch","page":"References","title":"Base.DimensionMismatch","text":"DimensionMismatch([msg])\n\nThe objects called do not have matching dimensionality. Optional argument msg is a descriptive error string.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Dims","page":"References","title":"Base.Dims","text":"Dims{N}\n\nAn NTuple of N Ints used to represent the dimensions of an AbstractArray.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.EOFError","page":"References","title":"Base.EOFError","text":"EOFError()\n\nNo more data was available to read from a file or stream.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.EnvDict","page":"References","title":"Base.EnvDict","text":"EnvDict() -> EnvDict\n\nA singleton of this type provides a hash table interface to environment variables.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Event","page":"References","title":"Base.Event","text":"Event()\n\nCreate a level-triggered event source. Tasks that call wait on an Event are suspended and queued until notify is called on the Event. After notify is called, the Event remains in a signaled state and tasks will no longer block when waiting for it.\n\ncompat: Julia 1.1\nThis functionality requires at least Julia 1.1.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.ExponentialBackOff-Tuple{}","page":"References","title":"Base.ExponentialBackOff","text":"ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter=0.1)\n\nA Float64 iterator of length n whose elements exponentially increase at a rate in the interval factor * (1 ± jitter).  The first element is first_delay and all elements are clamped to max_delay.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.FilteringRF","page":"References","title":"Base.FilteringRF","text":"FilteringRF(f, rf) -> rf′\n\nCreate a filtering reducing function rf′(acc, x) = f(x) ? rf(acc, x) : acc.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Fix1","page":"References","title":"Base.Fix1","text":"Fix1(f, x)\n\nA type representing a partially-applied version of the two-argument function f, with the first argument fixed to the value \"x\". In other words, Fix1(f, x) behaves similarly to y->f(x, y).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Fix2","page":"References","title":"Base.Fix2","text":"Fix2(f, x)\n\nA type representing a partially-applied version of the two-argument function f, with the second argument fixed to the value \"x\". In other words, Fix2(f, x) behaves similarly to y->f(y, x).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.FlatteningRF","page":"References","title":"Base.FlatteningRF","text":"FlatteningRF(rf) -> rf′\n\nCreate a flattening reducing function that is roughly equivalent to rf′(acc, x) = foldl(rf, x; init=acc).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Generator","page":"References","title":"Base.Generator","text":"Generator(f, iter)\n\nGiven a function f and an iterator iter, construct an iterator that yields the values of f applied to the elements of iter. The syntax for constructing an instance of this type is f(x) for x in iter [if cond(x)::Bool]. The [if cond(x)::Bool] expression is optional and acts as a \"guard\", effectively filtering out values where the condition is false.\n\njulia> g = (abs2(x) for x in 1:5 if x != 3);\n\njulia> for x in g\n           println(x)\n       end\n1\n4\n16\n25\n\njulia> collect(g)\n4-element Vector{Int64}:\n  1\n  4\n 16\n 25\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.GenericCondition","page":"References","title":"Base.GenericCondition","text":"GenericCondition\n\nAbstract implementation of a condition object for synchronizing tasks objects with a given lock.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.IOBuffer-Tuple{AbstractVector{UInt8}}","page":"References","title":"Base.IOBuffer","text":"IOBuffer([data::AbstractVector{UInt8}]; keywords...) -> IOBuffer\n\nCreate an in-memory I/O stream, which may optionally operate on a pre-existing array.\n\nIt may take optional keyword arguments:\n\nread, write, append: restricts operations to the buffer; see open for details.\ntruncate: truncates the buffer size to zero length.\nmaxsize: specifies a size beyond which the buffer may not be grown.\nsizehint: suggests a capacity of the buffer (data must implement sizehint!(data, size)).\n\nWhen data is not given, the buffer will be both readable and writable by default.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n\njulia> io = IOBuffer(b\"JuliaLang is a GitHub organization.\")\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=35, maxsize=Inf, ptr=1, mark=-1)\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization.\"\n\njulia> write(io, \"This isn't writable.\")\nERROR: ArgumentError: ensureroom failed, IOBuffer is not writeable\n\njulia> io = IOBuffer(UInt8[], read=true, write=true, maxsize=34)\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=34, ptr=1, mark=-1)\n\njulia> write(io, \"JuliaLang is a GitHub organization.\")\n34\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization\"\n\njulia> length(read(IOBuffer(b\"data\", read=true, truncate=false)))\n4\n\njulia> length(read(IOBuffer(b\"data\", read=true, truncate=true)))\n0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.IOBuffer-Tuple{String}","page":"References","title":"Base.IOBuffer","text":"IOBuffer(string::String)\n\nCreate a read-only IOBuffer on the data underlying the given string.\n\nExamples\n\njulia> io = IOBuffer(\"Haho\");\n\njulia> String(take!(io))\n\"Haho\"\n\njulia> String(take!(io))\n\"Haho\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.IOContext","page":"References","title":"Base.IOContext","text":"IOContext\n\nIOContext provides a mechanism for passing output configuration settings among show methods.\n\nIn short, it is an immutable dictionary that is a subclass of IO. It supports standard dictionary operations such as getindex, and can also be used as an I/O stream.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.IOContext-Tuple{IO, IO}","page":"References","title":"Base.IOContext","text":"IOContext(io::IO, context::IOContext)\n\nCreate an IOContext that wraps an alternate IO but inherits the properties of context.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.IOContext-Tuple{IO, Pair, Vararg{Pair, N} where N}","page":"References","title":"Base.IOContext","text":"IOContext(io::IO, KV::Pair...)\n\nCreate an IOContext that wraps a given stream, adding the specified key=>value pairs to the properties of that stream (note that io can itself be an IOContext).\n\nuse (key => value) in io to see if this particular combination is in the properties set\nuse get(io, key, default) to retrieve the most recent value for a particular key\n\nThe following properties are in common use:\n\n:compact: Boolean specifying that values should be printed more compactly, e.g. that numbers should be printed with fewer digits. This is set when printing array elements. :compact output should not contain line breaks.\n:limit: Boolean specifying that containers should be truncated, e.g. showing … in place of most elements.\n:displaysize: A Tuple{Int,Int} giving the size in rows and columns to use for text output. This can be used to override the display size for called functions, but to get the size of the screen use the displaysize function.\n:typeinfo: a Type characterizing the information already printed concerning the type of the object about to be displayed. This is mainly useful when displaying a collection of objects of the same type, so that redundant type information can be avoided (e.g. [Float16(0)] can be shown as \"Float16[0.0]\" instead of \"Float16[Float16(0.0)]\" : while displaying the elements of the array, the :typeinfo property will be set to Float16).\n:color: Boolean specifying whether ANSI color/escape codes are supported/expected. By default, this is determined by whether io is a compatible terminal and by any --color command-line flag when julia was launched.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> printstyled(IOContext(io, :color => true), \"string\", color=:red)\n\njulia> String(take!(io))\n\"\\e[31mstring\\e[39m\"\n\njulia> printstyled(io, \"string\", color=:red)\n\njulia> String(take!(io))\n\"string\"\n\njulia> print(IOContext(stdout, :compact => false), 1.12341234)\n1.12341234\njulia> print(IOContext(stdout, :compact => true), 1.12341234)\n1.12341\n\njulia> function f(io::IO)\n           if get(io, :short, false)\n               print(io, \"short\")\n           else\n               print(io, \"loooooong\")\n           end\n       end\nf (generic function with 1 method)\n\njulia> f(stdout)\nloooooong\njulia> f(IOContext(stdout, :short => true))\nshort\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.IOStream","page":"References","title":"Base.IOStream","text":"IOStream\n\nA buffered IO stream wrapping an OS file descriptor. Mostly used to represent files returned by open.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.IdDict","page":"References","title":"Base.IdDict","text":"IdDict([itr])\n\nIdDict{K,V}() constructs a hash table using object-id as hash and === as equality with keys of type K and values of type V.\n\nSee Dict for further help.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.IdentityUnitRange","page":"References","title":"Base.IdentityUnitRange","text":"IdentityUnitRange(range::AbstractUnitRange)\n\nRepresent an AbstractUnitRange range as an offset vector such that range[i] == i.\n\nIdentityUnitRanges are frequently used as axes for offset arrays.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.ImmutableDict","page":"References","title":"Base.ImmutableDict","text":"ImmutableDict\n\nImmutableDict is a dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions. Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key.\n\nImmutableDict(KV::Pair)\n\nCreate a new entry in the ImmutableDict for a key => value pair\n\nuse (key => value) in dict to see if this particular combination is in the properties set\nuse get(dict, key, default) to retrieve the most recent value for a particular key\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.IndexCartesian","page":"References","title":"Base.IndexCartesian","text":"IndexCartesian()\n\nSubtype of IndexStyle used to describe arrays which are optimally indexed by a Cartesian index. This is the default for new custom AbstractArray subtypes.\n\nA Cartesian indexing style uses multiple integer indices to describe the position in a multidimensional array, with exactly one index per dimension. This means that requesting eachindex from an array that is IndexCartesian will return a range of CartesianIndices.\n\nA N-dimensional custom array that reports its IndexStyle as IndexCartesian needs to implement indexing (and indexed assignment) with exactly N Int indices; all other indexing expressions — including linear indexing — will be recomputed to the equivalent Cartesian location.  For example, if A were a 2×3 custom matrix with cartesian indexing, and we referenced A[5], this would be recomputed to the equivalent Cartesian index and call A[1, 3] since 5 = 2*1 + 3.\n\nIt is significantly more expensive to compute Cartesian indices from a linear index than it is to go the other way.  The former operation requires division — a very costly operation — whereas the latter only uses multiplication and addition and is essentially free. This asymmetry means it is far more costly to use linear indexing with an IndexCartesian array than it is to use Cartesian indexing with an IndexLinear array.\n\nSee also IndexLinear.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.IndexLinear","page":"References","title":"Base.IndexLinear","text":"IndexLinear()\n\nSubtype of IndexStyle used to describe arrays which are optimally indexed by one linear index.\n\nA linear indexing style uses one integer index to describe the position in the array (even if it's a multidimensional array) and column-major ordering is used to efficiently access the elements. This means that requesting eachindex from an array that is IndexLinear will return a simple one-dimensional range, even if it is multidimensional.\n\nA custom array that reports its IndexStyle as IndexLinear only needs to implement indexing (and indexed assignment) with a single Int index; all other indexing expressions — including multidimensional accesses — will be recomputed to the linear index.  For example, if A were a 2×3 custom matrix with linear indexing, and we referenced A[1, 3], this would be recomputed to the equivalent linear index and call A[5] since 2*1 + 3 = 5.\n\nSee also IndexCartesian.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.IndexStyle-Tuple{AbstractArray}","page":"References","title":"Base.IndexStyle","text":"IndexStyle(A)\nIndexStyle(typeof(A))\n\nIndexStyle specifies the \"native indexing style\" for array A. When you define a new AbstractArray type, you can choose to implement either linear indexing (with IndexLinear) or cartesian indexing. If you decide to only implement linear indexing, then you must set this trait for your array type:\n\nBase.IndexStyle(::Type{<:MyArray}) = IndexLinear()\n\nThe default is IndexCartesian().\n\nJulia's internal indexing machinery will automatically (and invisibly) recompute all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.\n\nIf you define both styles of indexing for your AbstractArray, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, eachindex creates an iterator whose type depends on the setting of this trait.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.Irrational","page":"References","title":"Base.Irrational","text":"Irrational{sym} <: AbstractIrrational\n\nNumber type representing an exact irrational value denoted by the symbol sym.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.IteratorEltype-Tuple{Any}","page":"References","title":"Base.IteratorEltype","text":"IteratorEltype(itertype::Type) -> IteratorEltype\n\nGiven the type of an iterator, return one of the following values:\n\nEltypeUnknown() if the type of elements yielded by the iterator is not known in advance.\nHasEltype() if the element type is known, and eltype would return a meaningful value.\n\nHasEltype() is the default, since iterators are assumed to implement eltype.\n\nThis trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.\n\njulia> Base.IteratorEltype(1:5)\nBase.HasEltype()\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.IteratorSize-Tuple{Any}","page":"References","title":"Base.IteratorSize","text":"IteratorSize(itertype::Type) -> IteratorSize\n\nGiven the type of an iterator, return one of the following values:\n\nSizeUnknown() if the length (number of elements) cannot be determined in advance.\nHasLength() if there is a fixed, finite length.\nHasShape{N}() if there is a known length plus a notion of multidimensional shape (as for an array).  In this case N should give the number of dimensions, and the axes function is valid  for the iterator.\nIsInfinite() if the iterator yields values forever.\n\nThe default value (for iterators that do not define this function) is HasLength(). This means that most iterators are assumed to implement length.\n\nThis trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.\n\njulia> Base.IteratorSize(1:5)\nBase.HasShape{1}()\n\njulia> Base.IteratorSize((2,3))\nBase.HasLength()\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.KeyError","page":"References","title":"Base.KeyError","text":"KeyError(key)\n\nAn indexing operation into an AbstractDict (Dict) or Set like object tried to access or delete a non-existent element.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.LibuvServer","page":"References","title":"Base.LibuvServer","text":"LibuvServer\n\nAn abstract type for IOServers handled by libuv.\n\nIf server isa LibuvServer, it must obey the following interface:\n\nserver.handle must be a Ptr{Cvoid}\nserver.status must be an Int\nserver.cond must be a GenericCondition\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.LibuvStream","page":"References","title":"Base.LibuvStream","text":"LibuvStream\n\nAn abstract type for IO streams handled by libuv.\n\nIfstream isa LibuvStream, it must obey the following interface:\n\nstream.handle, if present, must be a Ptr{Cvoid}\nstream.status, if present, must be an Int\nstream.buffer, if present, must be an IOBuffer\nstream.sendbuf, if present, must be a Union{Nothing,IOBuffer}\nstream.cond, if present, must be a GenericCondition\nstream.lock, if present, must be an AbstractLock\nstream.throttle, if present, must be an Int\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.LinRange","page":"References","title":"Base.LinRange","text":"LinRange{T}\n\nA range with len linearly spaced elements between its start and stop. The size of the spacing is controlled by len, which must be an Int.\n\nExamples\n\njulia> LinRange(1.5, 5.5, 9)\n9-element LinRange{Float64}:\n 1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5\n\nCompared to using range, directly constructing a LinRange should have less overhead but won't try to correct for floating point errors:\n\njulia> collect(range(-0.1, 0.3, length=5))\n5-element Array{Float64,1}:\n -0.1\n  0.0\n  0.1\n  0.2\n  0.3\n\njulia> collect(LinRange(-0.1, 0.3, 5))\n5-element Array{Float64,1}:\n -0.1\n -1.3877787807814457e-17\n  0.09999999999999999\n  0.19999999999999998\n  0.3\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.LinearIndices","page":"References","title":"Base.LinearIndices","text":"LinearIndices(A::AbstractArray)\n\nReturn a LinearIndices array with the same shape and axes as A, holding the linear index of each entry in A. Indexing this array with cartesian indices allows mapping them to linear indices.\n\nFor arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to length(A). However, for AbstractVectors linear indices are axes(A, 1), and therefore do not start at 1 for vectors with unconventional indexing.\n\nCalling this function is the \"safe\" way to write algorithms that exploit linear indexing.\n\nExamples\n\njulia> A = fill(1, (5,6,7));\n\njulia> b = LinearIndices(A);\n\njulia> extrema(b)\n(1, 210)\n\nLinearIndices(inds::CartesianIndices) -> R\nLinearIndices(sz::Dims) -> R\nLinearIndices((istart:istop, jstart:jstop, ...)) -> R\n\nReturn a LinearIndices array with the specified shape or axes.\n\nExample\n\nThe main purpose of this constructor is intuitive conversion from cartesian to linear indexing:\n\njulia> linear = LinearIndices((1:3, 1:2))\n3×2 LinearIndices{2, Tuple{UnitRange{Int64}, UnitRange{Int64}}}:\n 1  4\n 2  5\n 3  6\n\njulia> linear[1,2]\n4\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.LogicalIndex","page":"References","title":"Base.LogicalIndex","text":"LogicalIndex(mask)\n\nThe LogicalIndex type is a special vector that simply contains all indices I where mask[I] is true. This specialized type does not support indexing directly as doing so would require O(n) lookup time. AbstractArray{Bool} are wrapped with LogicalIndex upon calling to_indices.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.MappingRF","page":"References","title":"Base.MappingRF","text":"MappingRF(f, rf) -> rf′\n\nCreate a mapping reducing function rf′(acc, x) = rf(acc, f(x)).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Matrix","page":"References","title":"Base.Matrix","text":"Matrix{T} <: AbstractMatrix{T}\n\nTwo-dimensional dense array with elements of type T, often used to represent a mathematical matrix. Alias for Array{T,2}.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Missing","page":"References","title":"Base.Missing","text":"Missing\n\nA type with no fields whose singleton instance missing is used to represent missing values.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.MissingException","page":"References","title":"Base.MissingException","text":"MissingException(msg)\n\nException thrown when a missing value is encountered in a situation where it is not supported. The error message, in the msg field may provide more specific details.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.OneTo","page":"References","title":"Base.OneTo","text":"Base.OneTo(n)\n\nDefine an AbstractUnitRange that behaves like 1:n, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.OrdinalRange","page":"References","title":"Base.OrdinalRange","text":"OrdinalRange{T, S} <: AbstractRange{T}\n\nSupertype for ordinal ranges with elements of type T with spacing(s) of type S. The steps should be always-exact multiples of oneunit, and T should be a \"discrete\" type, which cannot have values smaller than oneunit. For example, Integer or Date types would qualify, whereas Float64 would not (since this type can represent values smaller than oneunit(Float64). UnitRange, StepRange, and other types are subtypes of this.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Pair","page":"References","title":"Base.Pair","text":"Pair(x, y)\nx => y\n\nConstruct a Pair object with type Pair{typeof(x), typeof(y)}. The elements are stored in the fields first and second. They can also be accessed via iteration (but a Pair is treated as a single \"scalar\" for broadcasting operations).\n\nSee also: Dict\n\nExamples\n\njulia> p = \"foo\" => 7\n\"foo\" => 7\n\njulia> typeof(p)\nPair{String, Int64}\n\njulia> p.first\n\"foo\"\n\njulia> for x in p\n           println(x)\n       end\nfoo\n7\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Pipe-Tuple{}","page":"References","title":"Base.Pipe","text":"Construct an uninitialized Pipe object.\n\nThe appropriate end of the pipe will be automatically initialized if the object is used in process spawning. This can be useful to easily obtain references in process pipelines, e.g.:\n\njulia> err = Pipe()\n\n# After this `err` will be initialized and you may read `foo`'s\n# stderr from the `err` pipe.\njulia> run(pipeline(pipeline(`foo`, stderr=err), `cat`), wait=false)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ProcessFailedException","page":"References","title":"Base.ProcessFailedException","text":"ProcessFailedException\n\nIndicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.RangeStepStyle","page":"References","title":"Base.RangeStepStyle","text":"RangeStepStyle(instance)\nRangeStepStyle(T::Type)\n\nIndicate whether an instance or a type supports constructing a range with a perfectly regular step or not. A regular step means that step will always be exactly equal to the difference between two subsequent elements in a range, i.e. for a range r::AbstractRange{T}:\n\nall(diff(r) .== step(r))\n\nWhen a type T always leads to ranges with regular steps, it should define the following method:\n\nBase.RangeStepStyle(::Type{<:AbstractRange{<:T}}) = Base.RangeStepRegular()\n\nThis will allow hash to use an O(1) algorithm for AbstractRange{T} objects instead of the default O(N) algorithm (with N the length of the range).\n\nIn some cases, whether the step will be regular depends not only on the element type T, but also on the type of the step S. In that case, more specific methods should be defined:\n\nBase.RangeStepStyle(::Type{<:OrdinalRange{<:T, <:S}}) = Base.RangeStepRegular()\n\nBy default, all range types are assumed to be RangeStepIrregular, except ranges with an element type which is a subtype of Integer.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Rational","page":"References","title":"Base.Rational","text":"Rational{T<:Integer} <: Real\n\nRational number type, with numerator and denominator of type T. Rationals are checked for overflow.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.ReentrantLock","page":"References","title":"Base.ReentrantLock","text":"ReentrantLock()\n\nCreates a re-entrant lock for synchronizing Tasks. The same task can acquire the lock as many times as required. Each lock must be matched with an unlock.\n\nCalling 'lock' will also inhibit running of finalizers on that thread until the corresponding 'unlock'. Use of the standard lock pattern illustrated below should naturally be supported, but beware of inverting the try/lock order or missing the try block entirely (e.g. attempting to return with the lock still held):\n\nlock(l)\ntry\n    <atomic work>\nfinally\n    unlock(l)\nend\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Regex","page":"References","title":"Base.Regex","text":"Regex(pattern[, flags])\n\nA type representing a regular expression. Regex objects can be used to match strings with match.\n\nRegex objects can be created using the @r_str string macro. The Regex(pattern[, flags]) constructor is usually used if the pattern string needs to be interpolated. See the documentation of the string macro for details on flags.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.ReinterpretArray","page":"References","title":"Base.ReinterpretArray","text":"Gives a reinterpreted view (of element type T) of the underlying array (of element type S). If the size of T differs from the size of S, the array will be compressed/expanded in the first dimension. The variant reinterpret(reshape, T, a) instead adds or consumes the first dimension depending on the ratio of element sizes.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.SecretBuffer","page":"References","title":"Base.SecretBuffer","text":"Base.SecretBuffer()\n\nAn IOBuffer-like object where the contents will be securely wiped when garbage collected.\n\nIt is considered best practice to wipe the buffer using Base.shred!(::SecretBuffer) as soon as the secure data are no longer required. When initializing with existing data, the SecretBuffer! method is highly recommended to securely zero the passed argument. Avoid initializing with and converting to Strings as they are unable to be securely zeroed.\n\nExamples\n\njulia> s = Base.SecretBuffer()\nSecretBuffer(\"*******\")\n\njulia> write(s, 's', 'e', 'c', 'r', 'e', 't')\n6\n\njulia> seek(s, 0); Char(read(s, UInt8))\n's': ASCII/Unicode U+0073 (category Ll: Letter, lowercase)\n\njulia> Base.shred!(s)\nSecretBuffer(\"*******\")\n\njulia> eof(s)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.SecretBuffer-Tuple{AbstractString}","page":"References","title":"Base.SecretBuffer","text":"SecretBuffer(str::AbstractString)\n\nA convenience constructor to initialize a SecretBuffer from a non-secret string.\n\nStrings are bad at keeping secrets because they are unable to be securely zeroed or destroyed. Therefore, avoid using this constructor with secret data. Instead of starting with a string, either construct the SecretBuffer incrementally with SecretBuffer() and write, or use a Vector{UInt8} with the Base.SecretBuffer!(::Vector{UInt8}) constructor.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.Semaphore","page":"References","title":"Base.Semaphore","text":"Semaphore(sem_size)\n\nCreate a counting semaphore that allows at most sem_size acquires to be in use at any time. Each acquire must be matched with a release.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Set-Tuple{Any}","page":"References","title":"Base.Set","text":"Set([itr])\n\nConstruct a Set of the values generated by the given iterable object, or an empty set. Should be used instead of BitSet for sparse integer sets, or for sets of arbitrary objects.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.Slice","page":"References","title":"Base.Slice","text":"Slice(indices)\n\nRepresent an AbstractUnitRange of indices as a vector of the indices themselves, with special handling to signal they represent a complete slice of a dimension (:).\n\nUpon calling to_indices, Colons are converted to Slice objects to represent the indices over which the Colon spans. Slice objects are themselves unit ranges with the same indices as those they wrap. This means that indexing into Slice objects with an integer always returns that exact integer, and they iterate over all the wrapped indices, even supporting offset indices.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Some","page":"References","title":"Base.Some","text":"Some{T}\n\nA wrapper type used in Union{Some{T}, Nothing} to distinguish between the absence of a value (nothing) and the presence of a nothing value (i.e. Some(nothing)).\n\nUse something to access the value wrapped by a Some object.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.StepRange","page":"References","title":"Base.StepRange","text":"StepRange{T, S} <: OrdinalRange{T, S}\n\nRanges with elements of type T with spacing of type S. The step between each element is constant, and the range is defined in terms of a start and stop of type T and a step of type S. Neither T nor S should be floating point types. The syntax a:b:c with b > 1 and a, b, and c all integers creates a StepRange.\n\nExamples\n\njulia> collect(StepRange(1, Int8(2), 10))\n5-element Vector{Int64}:\n 1\n 3\n 5\n 7\n 9\n\njulia> typeof(StepRange(1, Int8(2), 10))\nStepRange{Int64, Int8}\n\njulia> typeof(1:3:6)\nStepRange{Int64, Int64}\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.StepRangeLen","page":"References","title":"Base.StepRangeLen","text":"StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1]) where {T,R,S}\nStepRangeLen(       ref::R, step::S, len, [offset=1]) where {  R,S}\n\nA range r where r[i] produces values of type T (in the second form, T is deduced automatically), parameterized by a reference value, a step, and the length. By default ref is the starting value r[1], but alternatively you can supply it as the value of r[offset] for some other index 1 <= offset <= len. In conjunction with TwicePrecision this can be used to implement ranges that are free of roundoff error.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.StringIndexError","page":"References","title":"Base.StringIndexError","text":"StringIndexError(str, i)\n\nAn error occurred when trying to access str at index i that is not valid.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.SubArray","page":"References","title":"Base.SubArray","text":"SubArray{T,N,P,I,L} <: AbstractArray{T,N}\n\nN-dimensional view into a parent array (of type P) with an element type T, restricted by a tuple of indices (of type I). L is true for types that support fast linear indexing, and false otherwise.\n\nConstruct SubArrays using the view function.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.SubString","page":"References","title":"Base.SubString","text":"SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))\nSubString(s::AbstractString, r::UnitRange{<:Integer})\n\nLike getindex, but returns a view into the parent string s within range i:j or r respectively instead of making a copy.\n\nExamples\n\njulia> SubString(\"abc\", 1, 2)\n\"ab\"\n\njulia> SubString(\"abc\", 1:2)\n\"ab\"\n\njulia> SubString(\"abc\", 2)\n\"bc\"\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.SubstitutionString","page":"References","title":"Base.SubstitutionString","text":"SubstitutionString(substr)\n\nStores the given string substr as a SubstitutionString, for use in regular expression substitutions. Most commonly constructed using the @s_str macro.\n\njulia> SubstitutionString(\"Hello \\\\g<name>, it's \\\\1\")\ns\"Hello \\g<name>, it's \\1\"\n\njulia> subst = s\"Hello \\g<name>, it's \\1\"\ns\"Hello \\g<name>, it's \\1\"\n\njulia> typeof(subst)\nSubstitutionString{String}\n\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.SystemError","page":"References","title":"Base.SystemError","text":"SystemError(prefix::AbstractString, [errno::Int32])\n\nA system call failed with an error code (in the errno global variable).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.TaskFailedException","page":"References","title":"Base.TaskFailedException","text":"TaskFailedException\n\nThis exception is thrown by a wait(t) call when task t fails. TaskFailedException wraps the failed task t.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Timer","page":"References","title":"Base.Timer","text":"Timer(delay; interval = 0)\n\nCreate a timer that wakes up tasks waiting for it (by calling wait on the timer object).\n\nWaiting tasks are woken after an initial delay of delay seconds, and then repeating with the given interval in seconds. If interval is equal to 0, the timer is only triggered once. When the timer is closed (by close) waiting tasks are woken with an error. Use isopen to check whether a timer is still active.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Timer-Tuple{Function, Real}","page":"References","title":"Base.Timer","text":"Timer(callback::Function, delay; interval = 0)\n\nCreate a timer that wakes up tasks waiting for it (by calling wait on the timer object) and calls the function callback.\n\nWaiting tasks are woken and the function callback is called after an initial delay of delay seconds, and then repeating with the given interval in seconds. If interval is equal to 0, the timer is only triggered once. The function callback is called with a single argument, the timer itself. When the timer is closed (by close) waiting tasks are woken with an error. Use isopen to check whether a timer is still active.\n\nExamples\n\nHere the first number is printed after a delay of two seconds, then the following numbers are printed quickly.\n\njulia> begin\n           i = 0\n           cb(timer) = (global i += 1; println(i))\n           t = Timer(cb, 2, interval=0.2)\n           wait(t)\n           sleep(0.5)\n           close(t)\n       end\n1\n2\n3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.TwicePrecision","page":"References","title":"Base.TwicePrecision","text":"TwicePrecision{T}(hi::T, lo::T)\nTwicePrecision{T}((num, denom))\n\nA number with twice the precision of T, e.g., quad-precision if T = Float64. hi represents the high bits (most significant bits) and lo the low bits (least significant bits). Rational values num//denom can be approximated conveniently using the syntax TwicePrecision{T}((num, denom)).\n\nWhen used with T<:Union{Float16,Float32,Float64} to construct an \"exact\" StepRangeLen, ref should be the range element with smallest magnitude and offset set to the corresponding index.  For efficiency, multiplication of step by the index is not performed at twice precision: step.hi should have enough trailing zeros in its bits representation that (0:len-1)*step.hi is exact (has no roundoff error).  If step has an exact rational representation num//denom, then you can construct step using\n\nstep = TwicePrecision{T}((num, denom), nb)\n\nwhere nb is the number of trailing zero bits of step.hi.  For ranges, you can set nb = ceil(Int, log2(len-1)).\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.UUID","page":"References","title":"Base.UUID","text":"Represents a Universally Unique Identifier (UUID).\nCan be built from one `UInt128` (all byte values), two `UInt64`, or four `UInt32`.\nConversion from a string will check the UUID validity.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.UnitRange","page":"References","title":"Base.UnitRange","text":"UnitRange{T<:Real}\n\nA range parameterized by a start and stop of type T, filled with elements spaced by 1 from start until stop is exceeded. The syntax a:b with a and b both Integers creates a UnitRange.\n\nExamples\n\njulia> collect(UnitRange(2.3, 5.2))\n3-element Vector{Float64}:\n 2.3\n 3.3\n 4.3\n\njulia> typeof(1:10)\nUnitRange{Int64}\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Val","page":"References","title":"Base.Val","text":"Val(c)\n\nReturn Val{c}(), which contains no run-time data. Types like this can be used to pass the information between functions through the value c, which must be an isbits value or a Symbol. The intent of this construct is to be able to dispatch on constants directly (at compile time) without having to test the value of the constant at run time.\n\nExamples\n\njulia> f(::Val{true}) = \"Good\"\nf (generic function with 1 method)\n\njulia> f(::Val{false}) = \"Bad\"\nf (generic function with 2 methods)\n\njulia> f(Val(true))\n\"Good\"\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.Vector","page":"References","title":"Base.Vector","text":"Vector{T} <: AbstractVector{T}\n\nOne-dimensional dense array with elements of type T, often used to represent a mathematical vector. Alias for Array{T,1}.\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.VersionNumber","page":"References","title":"Base.VersionNumber","text":"VersionNumber\n\nVersion number type which follow the specifications of semantic versioning, composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. See also @v_str.\n\nExamples\n\njulia> VersionNumber(\"1.2.3\")\nv\"1.2.3\"\n\njulia> VersionNumber(\"2.0.1-rc1\")\nv\"2.0.1-rc1\"\n\n\n\n\n\n","category":"type"},{"location":"references/#Base.WeakKeyDict","page":"References","title":"Base.WeakKeyDict","text":"WeakKeyDict([itr])\n\nWeakKeyDict() constructs a hash table where the keys are weak references to objects which may be garbage collected even when referenced in a hash table.\n\nSee Dict for further help.  Note, unlike Dict, WeakKeyDict does not convert keys on insertion, as this would imply the key object was unreferenced anywhere before insertion.\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.AbstractArray","page":"References","title":"Core.AbstractArray","text":"AbstractArray{T,N}\n\nSupertype for N-dimensional arrays (or array-like types) with elements of type T. Array and other types are subtypes of this. See the manual section on the AbstractArray interface.\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.AbstractChar","page":"References","title":"Core.AbstractChar","text":"The AbstractChar type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the codepoint function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with < and ==, for example.  New T <: AbstractChar types should define a codepoint(::T) method and a T(::UInt32) constructor, at minimum.\n\nA given AbstractChar subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported UInt32 value may throw an error. Conversely, the built-in Char type represents a superset of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value to UInt32 throws an error. The isvalid function can be used to check which codepoints are representable in a given AbstractChar type.\n\nInternally, an AbstractChar type may use a variety of encodings.  Conversion via codepoint(char) will not reveal this encoding because it always returns the Unicode value of the character. print(io, c) of any c::AbstractChar produces an encoding determined by io (UTF-8 for all built-in IO types), via conversion to Char if necessary.\n\nwrite(io, c), in contrast, may emit an encoding depending on typeof(c), and read(io, typeof(c)) should read the same encoding as write. New AbstractChar types must provide their own implementations of write and read.\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.AbstractString","page":"References","title":"Core.AbstractString","text":"The AbstractString type is the supertype of all string implementations in Julia. Strings are encodings of sequences of Unicode code points as represented by the AbstractChar type. Julia makes a few assumptions about strings:\n\nStrings are encoded in terms of fixed-size \"code units\"\nCode units can be extracted with codeunit(s, i)\nThe first code unit has index 1\nThe last code unit has index ncodeunits(s)\nAny index i such that 1 ≤ i ≤ ncodeunits(s) is in bounds\nString indexing is done in terms of these code units:\nCharacters are extracted by s[i] with a valid string index i\nEach AbstractChar in a string is encoded by one or more code units\nOnly the index of the first code unit of an AbstractChar is a valid index\nThe encoding of an AbstractChar is independent of what precedes or follows it\nString encodings are [self-synchronizing] – i.e. isvalid(s, i) is O(1)\n\n[self-synchronizing]: https://en.wikipedia.org/wiki/Self-synchronizing_code\n\nSome string functions that extract code units, characters or substrings from strings error if you pass them out-of-bounds or invalid string indices. This includes codeunit(s, i) and s[i]. Functions that do string index arithmetic take a more relaxed approach to indexing and give you the closest valid string index when in-bounds, or when out-of-bounds, behave as if there were an infinite number of characters padding each side of the string. Usually these imaginary padding characters have code unit length 1 but string types may choose different \"imaginary\" character sizes as makes sense for their implementations (e.g. substrings may pass index arithmetic through to the underlying string they provide a view into). Relaxed indexing functions include those intended for index arithmetic: thisind, nextind and prevind. This model allows index arithmetic to work with out-of- bounds indices as intermediate values so long as one never uses them to retrieve a character, which often helps avoid needing to code around edge cases.\n\nSee also: codeunit, ncodeunits, thisind, nextind, prevind\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.Array","page":"References","title":"Core.Array","text":"Array{T,N} <: AbstractArray{T,N}\n\nN-dimensional dense array with elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.Char","page":"References","title":"Core.Char","text":"Char(c::Union{Number,AbstractChar})\n\nChar is a 32-bit AbstractChar type that is the default representation of characters in Julia. Char is the type used for character literals like 'x' and it is also the element type of String.\n\nIn order to losslessly represent arbitrary byte streams stored in a String, a Char value may store information that cannot be converted to a Unicode codepoint — converting such a Char to UInt32 will throw an error. The isvalid(c::Char) function can be used to query whether c represents a valid Unicode character.\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.DenseArray","page":"References","title":"Core.DenseArray","text":"DenseArray{T, N} <: AbstractArray{T,N}\n\nN-dimensional dense array with elements of type T. The elements of a dense array are stored contiguously in memory.\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.LLVMPtr","page":"References","title":"Core.LLVMPtr","text":"LLVMPtr{T, AS}\n\nA pointer type that more closely resembles LLVM semantics: It includes the pointer address space, and will be passed as an actual pointer instead of an integer.\n\nThis type is mainly used to interface with code that has strict requirements about pointers, e.g., intrinsics that are selected based on the address space, or back-ends that require pointers to be identifiable by their types.\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.NTuple","page":"References","title":"Core.NTuple","text":"NTuple{N, T}\n\nA compact way of representing the type for a tuple of length N where all elements are of type T.\n\nExamples\n\njulia> isa((1, 2, 3, 4, 5, 6), NTuple{6, Int})\ntrue\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.NamedTuple","page":"References","title":"Core.NamedTuple","text":"NamedTuple\n\nNamedTuples are, as their name suggests, named Tuples. That is, they're a tuple-like collection of values, where each entry has a unique name, represented as a Symbol. Like Tuples, NamedTuples are immutable; neither the names nor the values can be modified in place after construction.\n\nAccessing the value associated with a name in a named tuple can be done using field access syntax, e.g. x.a, or using getindex, e.g. x[:a]. A tuple of the names can be obtained using keys, and a tuple of the values can be obtained using values.\n\nnote: Note\nIteration over NamedTuples produces the values without the names. (See example below.) To iterate over the name-value pairs, use the pairs function.\n\nThe @NamedTuple macro can be used for conveniently declaring NamedTuple types.\n\nExamples\n\njulia> x = (a=1, b=2)\n(a = 1, b = 2)\n\njulia> x.a\n1\n\njulia> x[:a]\n1\n\njulia> keys(x)\n(:a, :b)\n\njulia> values(x)\n(1, 2)\n\njulia> collect(x)\n2-element Vector{Int64}:\n 1\n 2\n\njulia> collect(pairs(x))\n2-element Vector{Pair{Symbol, Int64}}:\n :a => 1\n :b => 2\n\nIn a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair name::Symbol => value or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:\n\njulia> (; :a => 1)\n(a = 1,)\n\njulia> keys = (:a, :b, :c); values = (1, 2, 3);\n\njulia> (; zip(keys, values)...)\n(a = 1, b = 2, c = 3)\n\nAs in keyword arguments, identifiers and dot expressions imply names:\n\njulia> x = 0\n0\n\njulia> t = (; x)\n(x = 0,)\n\njulia> (; t.x)\n(x = 0,)\n\ncompat: Julia 1.5\nImplicit names from identifiers and dot expressions are available as of Julia 1.5.\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.Ptr","page":"References","title":"Core.Ptr","text":"Ptr{T}\n\nA memory address referring to data of type T.  However, there is no guarantee that the memory is actually valid, or that it actually represents data of the specified type.\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.Ref","page":"References","title":"Core.Ref","text":"Ref{T}\n\nAn object that safely references data of type T. This type is guaranteed to point to valid, Julia-allocated memory of the correct type. The underlying data is protected from freeing by the garbage collector as long as the Ref itself is referenced.\n\nIn Julia, Ref objects are dereferenced (loaded or stored) with [].\n\nCreation of a Ref to a value x of type T is usually written Ref(x). Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written Ref(a, i) for creating a reference to the i-th element of a.\n\nRef{T}() creates a reference to a value of type T without initialization. For a bitstype T, the value will be whatever currently resides in the memory allocated. For a non-bitstype T, the reference will be undefined and attempting to dereference it will result in an error, \"UndefRefError: access to undefined reference\".\n\nTo check if a Ref is an undefined reference, use isassigned(ref::RefValue). For example, isassigned(Ref{T}()) is false if T is not a bitstype. If T is a bitstype, isassigned(Ref{T}()) will always be true.\n\nWhen passed as a ccall argument (either as a Ptr or Ref type), a Ref object will be converted to a native pointer to the data it references. For most T, or when converted to a Ptr{Cvoid}, this is a pointer to the object data. When T is an isbits type, this value may be safely mutated, otherwise mutation is strictly undefined behavior.\n\nAs a special case, setting T = Any will instead cause the creation of a pointer to the reference itself when converted to a Ptr{Any} (a jl_value_t const* const* if T is immutable, else a jl_value_t *const *). When converted to a Ptr{Cvoid}, it will still return a pointer to the data region as for any other T.\n\nA C_NULL instance of Ptr can be passed to a ccall Ref argument to initialize it.\n\nUse in broadcasting\n\nRef is sometimes used in broadcasting in order to treat the referenced values as a scalar.\n\nExamples\n\njulia> Ref(5)\nBase.RefValue{Int64}(5)\n\njulia> isa.(Ref([1,2,3]), [Array, Dict, Int]) # Treat reference values as scalar during broadcasting\n3-element BitVector:\n 1\n 0\n 0\n\njulia> Ref{Function}()  # Undefined reference to a non-bitstype, Function\nBase.RefValue{Function}(#undef)\n\njulia> try\n           Ref{Function}()[] # Dereferencing an undefined reference will result in an error\n       catch e\n           println(e)\n       end\nUndefRefError()\n\njulia> Ref{Int64}()[]; # A reference to a bitstype refers to an undetermined value if not given\n\njulia> isassigned(Ref{Int64}()) # A reference to a bitstype is always assigned\ntrue\n\njulia> Ref{Int64}(0)[] == 0 # Explicitly give a value for a bitstype reference\ntrue\n\n\n\n\n\n","category":"type"},{"location":"references/#Core.String-Tuple{AbstractString}","page":"References","title":"Core.String","text":"String(s::AbstractString)\n\nConvert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.\n\n\n\n\n\n","category":"method"},{"location":"references/#Core.String-Tuple{AbstractVector{UInt8}}","page":"References","title":"Core.String","text":"String(v::AbstractVector{UInt8})\n\nCreate a new String object from a byte vector v containing UTF-8 encoded characters. If v is Vector{UInt8} it will be truncated to zero length and future modification of v cannot affect the contents of the resulting string. To avoid truncation of Vector{UInt8} data, use String(copy(v)); for other AbstractVector types, String(v) already makes a copy.\n\nWhen possible, the memory of v will be used without copying when the String object is created. This is guaranteed to be the case for byte vectors returned by take! on a writable IOBuffer and by calls to read(io, nb). This allows zero-copy conversion of I/O data to strings. In other cases, Vector{UInt8} data may be copied, but v is truncated anyway to guarantee consistent behavior.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:!-Tuple{Bool}","page":"References","title":"Base.:!","text":"!(x)\n\nBoolean not. Implements three-valued logic, returning missing if x is missing.\n\nExamples\n\njulia> !true\nfalse\n\njulia> !false\ntrue\n\njulia> !missing\nmissing\n\njulia> .![true false true]\n1×3 BitMatrix:\n 0  1  0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:!-Tuple{Function}","page":"References","title":"Base.:!","text":"!f::Function\n\nPredicate function negation: when the argument of ! is a function, it returns a function which computes the boolean negation of f.\n\nExamples\n\njulia> str = \"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\"∀ ε > 0, ∃ δ > 0: |x-y| < δ ⇒ |f(x)-f(y)| < ε\"\n\njulia> filter(isletter, str)\n\"εδxyδfxfyε\"\n\njulia> filter(!isletter, str)\n\"∀  > 0, ∃  > 0: |-| <  ⇒ |()-()| < \"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:!=-Tuple{Any, Any}","page":"References","title":"Base.:!=","text":"!=(x, y)\n≠(x,y)\n\nNot-equals comparison operator. Always gives the opposite answer as ==.\n\nImplementation\n\nNew types should generally not implement this, and rely on the fallback definition !=(x,y) = !(x==y) instead.\n\nExamples\n\njulia> 3 != 2\ntrue\n\njulia> \"foo\" ≠ \"foo\"\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:!=-Tuple{Any}","page":"References","title":"Base.:!=","text":"!=(x)\n\nCreate a function that compares its argument to x using !=, i.e. a function equivalent to y -> y != x. The returned function is of type Base.Fix2{typeof(!=)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:!==-Tuple{Any, Any}","page":"References","title":"Base.:!==","text":"!==(x, y)\n≢(x,y)\n\nAlways gives the opposite answer as ===.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a ≢ b\ntrue\n\njulia> a ≢ a\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:&-Union{Tuple{T}, Tuple{T, T}} where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}","page":"References","title":"Base.:&","text":"x & y\n\nBitwise and. Implements three-valued logic, returning missing if one operand is missing and the other is true. Add parentheses for function application form: (&)(x, y).\n\nExamples\n\njulia> 4 & 10\n0\n\njulia> 4 & 12\n4\n\njulia> true & missing\nmissing\n\njulia> false & missing\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:*-Tuple{Union{AbstractChar, AbstractString}, Vararg{Union{AbstractChar, AbstractString}, N} where N}","page":"References","title":"Base.:*","text":"*(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -> AbstractString\n\nConcatenate strings and/or characters, producing a String. This is equivalent to calling the string function on the arguments. Concatenation of built-in string types always produces a value of type String but other string types may choose to return a string of a different type as appropriate.\n\nExamples\n\njulia> \"Hello \" * \"world\"\n\"Hello world\"\n\njulia> 'j' * \"ulia\"\n\"julia\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:*-Tuple{Union{Regex, AbstractChar, AbstractString}, Vararg{Union{Regex, AbstractChar, AbstractString}, N} where N}","page":"References","title":"Base.:*","text":"*(s::Regex, t::Union{Regex,AbstractString,AbstractChar}) -> Regex\n*(s::Union{Regex,AbstractString,AbstractChar}, t::Regex) -> Regex\n\nConcatenate regexes, strings and/or characters, producing a Regex. String and character arguments must be matched exactly in the resulting regex, meaning that the contained characters are devoid of any special meaning (they are quoted with \"\\Q\" and \"\\E\").\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\nExamples\n\njulia> match(r\"Hello|Good bye\" * ' ' * \"world\", \"Hello world\")\nRegexMatch(\"Hello world\")\n\njulia> r = r\"a|b\" * \"c|d\"\nr\"(?:a|b)\\Qc|d\\E\"\n\njulia> match(r, \"ac\") == nothing\ntrue\n\njulia> match(r, \"ac|d\")\nRegexMatch(\"ac|d\")\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.://-Tuple{Integer, Integer}","page":"References","title":"Base.://","text":"//(num, den)\n\nDivide two integers or rational numbers, giving a Rational result.\n\nExamples\n\njulia> 3 // 5\n3//5\n\njulia> (3 // 5) // (2 // 1)\n3//10\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.::-Union{Tuple{T}, Tuple{T, Any, T}} where T","page":"References","title":"Base.::","text":"(:)(start, [step], stop)\n\nRange operator. a:b constructs a range from a to b with a step size of 1 (a UnitRange) , and a:s:b is similar but uses a step size of s (a StepRange).\n\n: is also used in indexing to select whole dimensions  and for Symbol literals, as in e.g. :hello.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:<-Tuple{Any, Any}","page":"References","title":"Base.:<","text":"<(x, y)\n\nLess-than comparison operator. Falls back to isless. Because of the behavior of floating-point NaN values, this operator implements a partial order.\n\nImplementation\n\nNew numeric types with a canonical partial order should implement this function for two arguments of the new type. Types with a canonical total order should implement isless instead. (x < y) | (x == y)\n\nExamples\n\njulia> 'a' < 'b'\ntrue\n\njulia> \"abc\" < \"abd\"\ntrue\n\njulia> 5 < 3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:<-Tuple{Any}","page":"References","title":"Base.:<","text":"<(x)\n\nCreate a function that compares its argument to x using <, i.e. a function equivalent to y -> y < x. The returned function is of type Base.Fix2{typeof(<)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:<<-Tuple{BitVector, Int64}","page":"References","title":"Base.:<<","text":"<<(B::BitVector, n) -> BitVector\n\nLeft bit shift operator, B << n. For n >= 0, the result is B with elements shifted n positions backwards, filling with false values. If n < 0, elements are shifted forwards. Equivalent to B >> -n.\n\nExamples\n\njulia> B = BitVector([true, false, true, false, false])\n5-element BitVector:\n 1\n 0\n 1\n 0\n 0\n\njulia> B << 1\n5-element BitVector:\n 0\n 1\n 0\n 0\n 0\n\njulia> B << -1\n5-element BitVector:\n 0\n 1\n 0\n 1\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:<<-Tuple{Integer, Integer}","page":"References","title":"Base.:<<","text":"<<(x, n)\n\nLeft bit shift operator, x << n. For n >= 0, the result is x shifted left by n bits, filling with 0s. This is equivalent to x * 2^n. For n < 0, this is equivalent to x >> -n.\n\nExamples\n\njulia> Int8(3) << 2\n12\n\njulia> bitstring(Int8(3))\n\"00000011\"\n\njulia> bitstring(Int8(12))\n\"00001100\"\n\nSee also >>, >>>.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:<=-Tuple{Any, Any}","page":"References","title":"Base.:<=","text":"<=(x, y)\n≤(x,y)\n\nLess-than-or-equals comparison operator. Falls back to (x < y) | (x == y).\n\nExamples\n\njulia> 'a' <= 'b'\ntrue\n\njulia> 7 ≤ 7 ≤ 9\ntrue\n\njulia> \"abc\" ≤ \"abc\"\ntrue\n\njulia> 5 <= 3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:<=-Tuple{Any}","page":"References","title":"Base.:<=","text":"<=(x)\n\nCreate a function that compares its argument to x using <=, i.e. a function equivalent to y -> y <= x. The returned function is of type Base.Fix2{typeof(<=)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:==","page":"References","title":"Base.:==","text":"==(x, y)\n\nGeneric equality operator. Falls back to ===. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, == is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.\n\nThis operator follows IEEE semantics for floating-point numbers: 0.0 == -0.0 and NaN != NaN.\n\nThe result is of type Bool, except when one of the operands is missing, in which case missing is returned (three-valued logic). For collections, missing is returned if at least one of the operands contains a missing value and all non-missing values are equal. Use isequal or === to always get a Bool result.\n\nImplementation\n\nNew numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.\n\nisequal falls back to ==, so new methods of == will be used by the Dict type to compare keys. If your type will be used as a dictionary key, it should therefore also implement hash.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.:==-Tuple{AbstractString, AbstractString}","page":"References","title":"Base.:==","text":"==(a::AbstractString, b::AbstractString) -> Bool\n\nTest whether two strings are equal character by character (technically, Unicode code point by code point).\n\nExamples\n\njulia> \"abc\" == \"abc\"\ntrue\n\njulia> \"abc\" == \"αβγ\"\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:==-Tuple{Any}","page":"References","title":"Base.:==","text":"==(x)\n\nCreate a function that compares its argument to x using ==, i.e. a function equivalent to y -> y == x.\n\nThe returned function is of type Base.Fix2{typeof(==)}, which can be used to implement specialized methods.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:>-Tuple{Any, Any}","page":"References","title":"Base.:>","text":">(x, y)\n\nGreater-than comparison operator. Falls back to y < x.\n\nImplementation\n\nGenerally, new types should implement < instead of this function, and rely on the fallback definition >(x, y) = y < x.\n\nExamples\n\njulia> 'a' > 'b'\nfalse\n\njulia> 7 > 3 > 1\ntrue\n\njulia> \"abc\" > \"abd\"\nfalse\n\njulia> 5 > 3\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:>-Tuple{Any}","page":"References","title":"Base.:>","text":">(x)\n\nCreate a function that compares its argument to x using >, i.e. a function equivalent to y -> y > x. The returned function is of type Base.Fix2{typeof(>)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:>:-Tuple{Any, Any}","page":"References","title":"Base.:>:","text":">:(T1, T2)\n\nSupertype operator, equivalent to T2 <: T1.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:>=-Tuple{Any, Any}","page":"References","title":"Base.:>=","text":">=(x, y)\n≥(x,y)\n\nGreater-than-or-equals comparison operator. Falls back to y <= x.\n\nExamples\n\njulia> 'a' >= 'b'\nfalse\n\njulia> 7 ≥ 7 ≥ 3\ntrue\n\njulia> \"abc\" ≥ \"abc\"\ntrue\n\njulia> 5 >= 3\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:>=-Tuple{Any}","page":"References","title":"Base.:>=","text":">=(x)\n\nCreate a function that compares its argument to x using >=, i.e. a function equivalent to y -> y >= x. The returned function is of type Base.Fix2{typeof(>=)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.2\nThis functionality requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:>>-Tuple{BitVector, Union{Int64, UInt64}}","page":"References","title":"Base.:>>","text":">>(B::BitVector, n) -> BitVector\n\nRight bit shift operator, B >> n. For n >= 0, the result is B with elements shifted n positions forward, filling with false values. If n < 0, elements are shifted backwards. Equivalent to B << -n.\n\nExamples\n\njulia> B = BitVector([true, false, true, false, false])\n5-element BitVector:\n 1\n 0\n 1\n 0\n 0\n\njulia> B >> 1\n5-element BitVector:\n 0\n 1\n 0\n 1\n 0\n\njulia> B >> -1\n5-element BitVector:\n 0\n 1\n 0\n 0\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:>>-Tuple{Integer, Integer}","page":"References","title":"Base.:>>","text":">>(x, n)\n\nRight bit shift operator, x >> n. For n >= 0, the result is x shifted right by n bits, where n >= 0, filling with 0s if x >= 0, 1s if x < 0, preserving the sign of x. This is equivalent to fld(x, 2^n). For n < 0, this is equivalent to x << -n.\n\nExamples\n\njulia> Int8(13) >> 2\n3\n\njulia> bitstring(Int8(13))\n\"00001101\"\n\njulia> bitstring(Int8(3))\n\"00000011\"\n\njulia> Int8(-14) >> 2\n-4\n\njulia> bitstring(Int8(-14))\n\"11110010\"\n\njulia> bitstring(Int8(-4))\n\"11111100\"\n\nSee also >>>, <<.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:>>>-Tuple{BitVector, Int64}","page":"References","title":"Base.:>>>","text":">>>(B::BitVector, n) -> BitVector\n\nUnsigned right bitshift operator, B >>> n. Equivalent to B >> n. See >> for details and examples.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:>>>-Tuple{Integer, Integer}","page":"References","title":"Base.:>>>","text":">>>(x, n)\n\nUnsigned right bit shift operator, x >>> n. For n >= 0, the result is x shifted right by n bits, where n >= 0, filling with 0s. For n < 0, this is equivalent to x << -n.\n\nFor Unsigned integer types, this is equivalent to >>. For Signed integer types, this is equivalent to signed(unsigned(x) >> n).\n\nExamples\n\njulia> Int8(-14) >>> 2\n60\n\njulia> bitstring(Int8(-14))\n\"11110010\"\n\njulia> bitstring(Int8(60))\n\"00111100\"\n\nBigInts are treated as if having infinite size, so no filling is required and this is equivalent to >>.\n\nSee also >>, <<.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:\\-Tuple{Any, Any}","page":"References","title":"Base.:\\","text":"\\(x, y)\n\nLeft division operator: multiplication of y by the inverse of x on the left. Gives floating-point results for integer arguments.\n\nExamples\n\njulia> 3 \\ 6\n2.0\n\njulia> inv(3) * 6\n2.0\n\njulia> A = [4 3; 2 1]; x = [5, 6];\n\njulia> A \\ x\n2-element Vector{Float64}:\n  6.5\n -7.0\n\njulia> inv(A) * x\n2-element Vector{Float64}:\n  6.5\n -7.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:^-Tuple{Number, Number}","page":"References","title":"Base.:^","text":"^(x, y)\n\nExponentiation operator. If x is a matrix, computes matrix exponentiation.\n\nIf y is an Int literal (e.g. 2 in x^2 or -3 in x^-3), the Julia code x^y is transformed by the compiler to Base.literal_pow(^, x, Val(y)), to enable compile-time specialization on the value of the exponent. (As a default fallback we have Base.literal_pow(^, x, Val(y)) = ^(x,y), where usually ^ == Base.^ unless ^ has been defined in the calling namespace.) If y is a negative integer literal, then Base.literal_pow transforms the operation to inv(x)^-y by default, where -y is positive.\n\njulia> 3^5\n243\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> A^3\n2×2 Matrix{Int64}:\n 37   54\n 81  118\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:^-Tuple{Regex, Integer}","page":"References","title":"Base.:^","text":"^(s::Regex, n::Integer)\n\nRepeat a regex n times.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\nExamples\n\njulia> r\"Test \"^2\nr\"(?:Test ){2}\"\n\njulia> match(r\"Test \"^2, \"Test Test \")\nRegexMatch(\"Test Test \")\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}","page":"References","title":"Base.:^","text":"^(s::Union{AbstractString,AbstractChar}, n::Integer)\n\nRepeat a string or character n times. This can also be written as repeat(s, n).\n\nSee also: repeat\n\nExamples\n\njulia> \"Test \"^3\n\"Test Test Test \"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:|-Union{Tuple{T}, Tuple{T, T}} where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}","page":"References","title":"Base.:|","text":"x | y\n\nBitwise or. Implements three-valued logic, returning missing if one operand is missing and the other is false.\n\nExamples\n\njulia> 4 | 10\n14\n\njulia> 4 | 1\n5\n\njulia> true | missing\ntrue\n\njulia> false | missing\nmissing\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:|>-Tuple{Any, Any}","page":"References","title":"Base.:|>","text":"|>(x, f)\n\nApplies a function to the preceding argument. This allows for easy function chaining.\n\nExamples\n\njulia> [1:5;] |> x->x.^2 |> sum |> inv\n0.01818181818181818\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:~-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}","page":"References","title":"Base.:~","text":"~(x)\n\nBitwise not.\n\nExamples\n\njulia> ~4\n-5\n\njulia> ~10\n-11\n\njulia> ~true\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:∉","page":"References","title":"Base.:∉","text":"∉(item, collection) -> Bool\n∌(collection, item) -> Bool\n\nNegation of ∈ and ∋, i.e. checks that item is not in collection.\n\nWhen broadcasting with items .∉ collection, both item and collection are broadcasted over, which is often not what is intended. For example, if both arguments are vectors (and the dimensions match), the result is a vector indicating whether each value in collection items is not in the value at the corresponding position in collection. To get a vector indicating whether each value in items is not in collection, wrap collection in a tuple or a Ref like this: items .∉ Ref(collection).\n\nExamples\n\njulia> 1 ∉ 2:4\ntrue\n\njulia> 1 ∉ 1:3\nfalse\n\njulia> [1, 2] .∉ [2, 3]\n2-element BitVector:\n 1\n 1\n\njulia> [1, 2] .∉ ([2, 3],)\n2-element BitVector:\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.:∋-Tuple{Any, Any}","page":"References","title":"Base.:∋","text":"∋(collection, item) -> Bool\n\nLike in, but with arguments in reverse order. Avoid adding methods to this function; define in instead.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:∋-Tuple{Any}","page":"References","title":"Base.:∋","text":"∋(item)\n\nCreate a function that checks whether its argument contains the given item, i.e. a function equivalent to y -> item in y.\n\ncompat: Julia 1.6\nThis method requires Julia 1.6 or later.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:∌","page":"References","title":"Base.:∌","text":"∉(item, collection) -> Bool\n∌(collection, item) -> Bool\n\nNegation of ∈ and ∋, i.e. checks that item is not in collection.\n\nWhen broadcasting with items .∉ collection, both item and collection are broadcasted over, which is often not what is intended. For example, if both arguments are vectors (and the dimensions match), the result is a vector indicating whether each value in collection items is not in the value at the corresponding position in collection. To get a vector indicating whether each value in items is not in collection, wrap collection in a tuple or a Ref like this: items .∉ Ref(collection).\n\nExamples\n\njulia> 1 ∉ 2:4\ntrue\n\njulia> 1 ∉ 1:3\nfalse\n\njulia> [1, 2] .∉ [2, 3]\n2-element BitVector:\n 1\n 1\n\njulia> [1, 2] .∉ ([2, 3],)\n2-element BitVector:\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.:∘","page":"References","title":"Base.:∘","text":"f ∘ g\n\nCompose functions: i.e. (f ∘ g)(args...) means f(g(args...)). The ∘ symbol can be entered in the Julia REPL (and most editors, appropriately configured) by typing \\circ<tab>.\n\nFunction composition also works in prefix form: ∘(f, g) is the same as f ∘ g. The prefix form supports composition of multiple functions: ∘(f, g, h) = f ∘ g ∘ h and splatting ∘(fs...) for composing an iterable collection of functions.\n\ncompat: Julia 1.4\nMultiple function composition requires at least Julia 1.4.\n\ncompat: Julia 1.5\nComposition of one function ∘(f)  requires at least Julia 1.5.\n\nExamples\n\njulia> map(uppercase∘first, [\"apple\", \"banana\", \"carrot\"])\n3-element Vector{Char}:\n 'A': ASCII/Unicode U+0041 (category Lu: Letter, uppercase)\n 'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n 'C': ASCII/Unicode U+0043 (category Lu: Letter, uppercase)\n\njulia> fs = [\n           x -> 2x\n           x -> x/2\n           x -> x-1\n           x -> x+1\n       ];\n\njulia> ∘(fs...)(3)\n3.0\n\nSee also ComposedFunction.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.:≉-Tuple","page":"References","title":"Base.:≉","text":"x ≉ y\n\nThis is equivalent to !isapprox(x,y) (see isapprox).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.:⊆","page":"References","title":"Base.:⊆","text":"issubset(a, b) -> Bool\n⊆(a, b) -> Bool\n⊇(b, a) -> Bool\n\nDetermine whether every element of a is also in b, using in.\n\nExamples\n\njulia> issubset([1, 2], [1, 2, 3])\ntrue\n\njulia> [1, 2, 3] ⊆ [1, 2]\nfalse\n\njulia> [1, 2, 3] ⊇ [1, 2]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.:⊇","page":"References","title":"Base.:⊇","text":"issubset(a, b) -> Bool\n⊆(a, b) -> Bool\n⊇(b, a) -> Bool\n\nDetermine whether every element of a is also in b, using in.\n\nExamples\n\njulia> issubset([1, 2], [1, 2, 3])\ntrue\n\njulia> [1, 2, 3] ⊆ [1, 2]\nfalse\n\njulia> [1, 2, 3] ⊇ [1, 2]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.:⊈","page":"References","title":"Base.:⊈","text":"⊈(a, b) -> Bool\n⊉(b, a) -> Bool\n\nNegation of ⊆ and ⊇, i.e. checks that a is not a subset of b.\n\nExamples\n\njulia> (1, 2) ⊈ (2, 3)\ntrue\n\njulia> (1, 2) ⊈ (1, 2, 3)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.:⊉","page":"References","title":"Base.:⊉","text":"⊈(a, b) -> Bool\n⊉(b, a) -> Bool\n\nNegation of ⊆ and ⊇, i.e. checks that a is not a subset of b.\n\nExamples\n\njulia> (1, 2) ⊈ (2, 3)\ntrue\n\njulia> (1, 2) ⊈ (1, 2, 3)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.:⊊","page":"References","title":"Base.:⊊","text":"⊊(a, b) -> Bool\n⊋(b, a) -> Bool\n\nDetermines if a is a subset of, but not equal to, b.\n\nExamples\n\njulia> (1, 2) ⊊ (1, 2, 3)\ntrue\n\njulia> (1, 2) ⊊ (1, 2)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.:⊋","page":"References","title":"Base.:⊋","text":"⊊(a, b) -> Bool\n⊋(b, a) -> Bool\n\nDetermines if a is a subset of, but not equal to, b.\n\nExamples\n\njulia> (1, 2) ⊊ (1, 2, 3)\ntrue\n\njulia> (1, 2) ⊊ (1, 2)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.Libc.getpid-Tuple{Base.Process}","page":"References","title":"Base.Libc.getpid","text":"getpid(process) -> Int32\n\nGet the child process ID, if it still exists.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.MainInclude.eval","page":"References","title":"Base.MainInclude.eval","text":"eval(expr)\n\nEvaluate an expression in the global scope of the containing module. Every Module (except those defined with baremodule) has its own 1-argument definition of eval, which evaluates expressions in that module.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.MainInclude.include","page":"References","title":"Base.MainInclude.include","text":"include([mapexpr::Function,] path::AbstractString)\n\nEvaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with baremodule) has its own definition of include, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to include will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\n\nThe optional first argument mapexpr can be used to transform the included code before it is evaluated: for each parsed expression expr in path, the include function actually evaluates mapexpr(expr).  If it is omitted, mapexpr defaults to identity.\n\nUse Base.include to evaluate a file into another module.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.PipeBuffer","page":"References","title":"Base.PipeBuffer","text":"PipeBuffer(data::Vector{UInt8}=UInt8[]; maxsize::Integer = typemax(Int))\n\nAn IOBuffer that allows reading and performs writes by appending. Seeking and truncating are not supported. See IOBuffer for the available constructors. If data is given, creates a PipeBuffer to operate on a data vector, optionally specifying a size beyond which the underlying Array may not be grown.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.SecretBuffer!-Tuple{Vector{UInt8}}","page":"References","title":"Base.SecretBuffer!","text":"SecretBuffer!(data::Vector{UInt8})\n\nInitialize a new SecretBuffer from data, securely zeroing data afterwards.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.Threads.foreach-Tuple{Any, Channel}","page":"References","title":"Base.Threads.foreach","text":"Threads.foreach(f, channel::Channel;\n                schedule::Threads.AbstractSchedule=Threads.FairSchedule(),\n                ntasks=Threads.nthreads())\n\nSimilar to foreach(f, channel), but iteration over channel and calls to f are split across ntasks tasks spawned by Threads.@spawn. This function will wait for all internally spawned tasks to complete before returning.\n\nIf schedule isa FairSchedule, Threads.foreach will attempt to spawn tasks in a manner that enables Julia's scheduler to more freely load-balance work items across threads. This approach generally has higher per-item overhead, but may perform better than StaticSchedule in concurrence with other multithreaded workloads.\n\nIf schedule isa StaticSchedule, Threads.foreach will spawn tasks in a manner that incurs lower per-item overhead than FairSchedule, but is less amenable to load-balancing. This approach thus may be more suitable for fine-grained, uniform workloads, but may perform worse than FairSchedule in concurrence with other multithreaded workloads.\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.__precompile__","page":"References","title":"Base.__precompile__","text":"__precompile__(isprecompilable::Bool)\n\nSpecify whether the file calling this function is precompilable, defaulting to true. If a module or file is not safely precompilable, it should call __precompile__(false) in order to throw an error if Julia attempts to precompile it.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base._show_nonempty-Tuple{IO, AbstractMatrix{T} where T, String}","page":"References","title":"Base._show_nonempty","text":"_show_nonempty(io, X::AbstractMatrix, prefix) prints matrix X with opening and closing square brackets, preceded by prefix, supposed to encode the type of the elements.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base._xfadjoint-Tuple{Any, Any}","page":"References","title":"Base._xfadjoint","text":"_xfadjoint(op, itr) -> op′, itr′\n\nGiven a pair of reducing function op and an iterator itr, return a pair (op′, itr′) of similar types.  If the iterator itr is transformed by an iterator transform ixf whose adjoint transducer xf is known, op′ = xf(op) and itr′ = ixf⁻¹(itr) is returned.  Otherwise, op and itr are returned as-is.  For example, transducer rf -> MappingRF(f, rf) is the adjoint of iterator transform itr -> Generator(f, itr).\n\nNested iterator transforms are converted recursively.  That is to say, given op and\n\nitr = (ixf₁ ∘ ixf₂ ∘ ... ∘ ixfₙ)(itr′)\n\nwhat is returned is itr′ and\n\nop′ = (xfₙ ∘ ... ∘ xf₂ ∘ xf₁)(op)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.abs","page":"References","title":"Base.abs","text":"abs(x)\n\nThe absolute value of x.\n\nWhen abs is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when abs is applied to the minimum representable value of a signed integer. That is, when x == typemin(typeof(x)), abs(x) == x < 0, not -x as might be expected.\n\nExamples\n\njulia> abs(-3)\n3\n\njulia> abs(1 + im)\n1.4142135623730951\n\njulia> abs(typemin(Int64))\n-9223372036854775808\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.abs2-Tuple{Real}","page":"References","title":"Base.abs2","text":"abs2(x)\n\nSquared absolute value of x.\n\nExamples\n\njulia> abs2(-3)\n9\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.accumulate!-Tuple{Any, Any, Any}","page":"References","title":"Base.accumulate!","text":"accumulate!(op, B, A; [dims], [init])\n\nCumulative operation op on A along the dimension dims, storing the result in B. Providing dims is optional for vectors.  If the keyword argument init is given, its value is used to instantiate the accumulation. See also accumulate.\n\nExamples\n\njulia> x = [1, 0, 2, 0, 3];\n\njulia> y = [0, 0, 0, 0, 0];\n\njulia> accumulate!(+, y, x);\n\njulia> y\n5-element Vector{Int64}:\n 1\n 1\n 3\n 3\n 6\n\njulia> A = [1 2; 3 4];\n\njulia> B = [0 0; 0 0];\n\njulia> accumulate!(-, B, A, dims=1);\n\njulia> B\n2×2 Matrix{Int64}:\n  1   2\n -2  -2\n\njulia> accumulate!(-, B, A, dims=2);\n\njulia> B\n2×2 Matrix{Int64}:\n 1  -1\n 3  -1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.accumulate-Tuple{Any, Any}","page":"References","title":"Base.accumulate","text":"accumulate(op, A; dims::Integer, [init])\n\nCumulative operation op along the dimension dims of A (providing dims is optional for vectors). An initial value init may optionally be provided by a keyword argument. See also accumulate! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of accumulate, see: cumsum, cumprod\n\ncompat: Julia 1.5\naccumulate on a non-array iterator requires at least Julia 1.5.\n\nExamples\n\njulia> accumulate(+, [1,2,3])\n3-element Vector{Int64}:\n 1\n 3\n 6\n\njulia> accumulate(*, [1,2,3])\n3-element Vector{Int64}:\n 1\n 2\n 6\n\njulia> accumulate(+, [1,2,3]; init=100)\n3-element Vector{Int64}:\n 101\n 103\n 106\n\njulia> accumulate(min, [1,2,-1]; init=0)\n3-element Vector{Int64}:\n  0\n  0\n -1\n\njulia> accumulate(+, fill(1, 3, 3), dims=1)\n3×3 Matrix{Int64}:\n 1  1  1\n 2  2  2\n 3  3  3\n\njulia> accumulate(+, fill(1, 3, 3), dims=2)\n3×3 Matrix{Int64}:\n 1  2  3\n 1  2  3\n 1  2  3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.acquire-Tuple{Base.Semaphore}","page":"References","title":"Base.acquire","text":"acquire(s::Semaphore)\n\nWait for one of the sem_size permits to be available, blocking until one can be acquired.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.active_project","page":"References","title":"Base.active_project","text":"active_project()\n\nReturn the path of the active Project.toml file.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.add12-Union{Tuple{T}, Tuple{T, T}} where T","page":"References","title":"Base.add12","text":"zhi, zlo = add12(x, y)\n\nA high-precision representation of x + y for floating-point numbers. Mathematically, zhi + zlo = x + y, where zhi contains the most significant bits and zlo the least significant.\n\nBecause of the way floating-point numbers are printed, lo may not look the way you might expect from the standpoint of decimal representation, even though it is exact from the standpoint of binary representation.\n\nExample:\n\njulia> 1.0 + 1.0001e-15\n1.000000000000001\n\njulia> big(1.0) + big(1.0001e-15)\n1.000000000000001000100000000000020165767380775934141445417482375879192346701529\n\njulia> hi, lo = Base.add12(1.0, 1.0001e-15)\n(1.000000000000001, -1.1012302462515652e-16)\n\njulia> big(hi) + big(lo)\n1.000000000000001000100000000000020165767380775934141445417482375879192346701529\n\nlo differs from 1.0e-19 because hi is not exactly equal to the first 16 decimal digits of the answer.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.add_sum-Tuple{Any, Any}","page":"References","title":"Base.add_sum","text":"Base.add_sum(x, y)\n\nThe reduction operator used in sum. The main difference from + is that small integers are promoted to Int/UInt.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.addenv-Tuple{Cmd, Dict}","page":"References","title":"Base.addenv","text":"addenv(command::Cmd, env...; inherit::Bool = true)\n\nMerge new environment mappings into the given Cmd object, returning a new Cmd object. Duplicate keys are replaced.  If command does not contain any environment values set already, it inherits the current environment at time of addenv() call if inherit is true.\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.alignment-Tuple{IO, Any}","page":"References","title":"Base.alignment","text":"alignment(io, X) returns a tuple (left,right) showing how many characters are needed on either side of an alignment feature such as a decimal point.\n\nExamples\n\njulia> Base.alignment(stdout, 42)\n(2, 0)\n\njulia> Base.alignment(stdout, 4.23)\n(1, 3)\n\njulia> Base.alignment(stdout, 1 + 10im)\n(3, 5)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.alignment-Union{Tuple{V}, Tuple{T}, Tuple{IO, AbstractVecOrMat{T} where T, AbstractVector{T}, AbstractVector{V}, Integer, Integer, Integer}} where {T, V}","page":"References","title":"Base.alignment","text":"alignment(io, X, rows, cols, cols_if_complete, cols_otherwise, sep) returns the alignment for specified parts of array X, returning the (left,right) info. It will look in X's rows, cols (both lists of indices) and figure out what's needed to be fully aligned, for example looking all the way down a column and finding out the maximum size of each element. Parameter sep::Integer is number of spaces to put between elements. cols_if_complete and cols_otherwise indicate screen width to use. Alignment is reported as a vector of (left,right) tuples, one for each column going across the screen.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.all!-Tuple{Any, Any}","page":"References","title":"Base.all!","text":"all!(r, A)\n\nTest whether all values in A along the singleton dimensions of r are true, and write results to r.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Matrix{Bool}:\n 1  0\n 1  0\n\njulia> all!([1; 1], A)\n2-element Vector{Int64}:\n 0\n 0\n\njulia> all!([1 1], A)\n1×2 Matrix{Int64}:\n 1  0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.all-Tuple{AbstractArray}","page":"References","title":"Base.all","text":"all(A; dims)\n\nTest whether all values along the given dimensions of an array are true.\n\nExamples\n\njulia> A = [true false; true true]\n2×2 Matrix{Bool}:\n 1  0\n 1  1\n\njulia> all(A, dims=1)\n1×2 Matrix{Bool}:\n 1  0\n\njulia> all(A, dims=2)\n2×1 Matrix{Bool}:\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.all-Tuple{Any, Any}","page":"References","title":"Base.all","text":"all(p, itr) -> Bool\n\nDetermine whether predicate p returns true for all elements of itr, returning false as soon as the first item in itr for which p returns false is encountered (short-circuiting).\n\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\n\nExamples\n\njulia> all(i->(4<=i<=6), [4,5,6])\ntrue\n\njulia> all(i -> (println(i); i < 3), 1:10)\n1\n2\n3\nfalse\n\njulia> all(i -> i > 0, [1, missing])\nmissing\n\njulia> all(i -> i > 0, [-1, missing])\nfalse\n\njulia> all(i -> i > 0, [1, 2])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.all-Tuple{Any}","page":"References","title":"Base.all","text":"all(itr) -> Bool\n\nTest whether all elements of a boolean collection are true, returning false as soon as the first false value in itr is encountered (short-circuiting).\n\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\n\nExamples\n\njulia> a = [true,false,false,true]\n4-element Vector{Bool}:\n 1\n 0\n 0\n 1\n\njulia> all(a)\nfalse\n\njulia> all((println(i); v) for (i, v) in enumerate(a))\n1\n2\nfalse\n\njulia> all([missing, false])\nfalse\n\njulia> all([true, missing])\nmissing\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.all-Tuple{Function, AbstractArray}","page":"References","title":"Base.all","text":"all(p, A; dims)\n\nDetermine whether predicate p returns true for all elements along the given dimensions of an array.\n\nExamples\n\njulia> A = [1 -1; 2 2]\n2×2 Matrix{Int64}:\n 1  -1\n 2   2\n\njulia> all(i -> i > 0, A, dims=1)\n1×2 Matrix{Bool}:\n 1  0\n\njulia> all(i -> i > 0, A, dims=2)\n2×1 Matrix{Bool}:\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.allunique-Tuple{Any}","page":"References","title":"Base.allunique","text":"allunique(itr) -> Bool\n\nReturn true if all values from itr are distinct when compared with isequal.\n\nExamples\n\njulia> a = [1; 2; 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> allunique([a, a])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.angle-Tuple{Complex}","page":"References","title":"Base.angle","text":"angle(z)\n\nCompute the phase angle in radians of a complex number z.\n\nExamples\n\njulia> rad2deg(angle(1 + im))\n45.0\n\njulia> rad2deg(angle(1 - im))\n-45.0\n\njulia> rad2deg(angle(-1 - im))\n-135.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.any!-Tuple{Any, Any}","page":"References","title":"Base.any!","text":"any!(r, A)\n\nTest whether any values in A along the singleton dimensions of r are true, and write results to r.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Matrix{Bool}:\n 1  0\n 1  0\n\njulia> any!([1; 1], A)\n2-element Vector{Int64}:\n 1\n 1\n\njulia> any!([1 1], A)\n1×2 Matrix{Int64}:\n 1  0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.any-Tuple{AbstractArray}","page":"References","title":"Base.any","text":"any(A; dims)\n\nTest whether any values along the given dimensions of an array are true.\n\nExamples\n\njulia> A = [true false; true false]\n2×2 Matrix{Bool}:\n 1  0\n 1  0\n\njulia> any(A, dims=1)\n1×2 Matrix{Bool}:\n 1  0\n\njulia> any(A, dims=2)\n2×1 Matrix{Bool}:\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.any-Tuple{Any, Any}","page":"References","title":"Base.any","text":"any(p, itr) -> Bool\n\nDetermine whether predicate p returns true for any elements of itr, returning true as soon as the first item in itr for which p returns true is encountered (short-circuiting).\n\nIf the input contains missing values, return missing if all non-missing values are false (or equivalently, if the input contains no true value), following three-valued logic.\n\nExamples\n\njulia> any(i->(4<=i<=6), [3,5,7])\ntrue\n\njulia> any(i -> (println(i); i > 3), 1:10)\n1\n2\n3\n4\ntrue\n\njulia> any(i -> i > 0, [1, missing])\ntrue\n\njulia> any(i -> i > 0, [-1, missing])\nmissing\n\njulia> any(i -> i > 0, [-1, 0])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.any-Tuple{Any}","page":"References","title":"Base.any","text":"any(itr) -> Bool\n\nTest whether any elements of a boolean collection are true, returning true as soon as the first true value in itr is encountered (short-circuiting).\n\nIf the input contains missing values, return missing if all non-missing values are false (or equivalently, if the input contains no true value), following three-valued logic.\n\nExamples\n\njulia> a = [true,false,false,true]\n4-element Vector{Bool}:\n 1\n 0\n 0\n 1\n\njulia> any(a)\ntrue\n\njulia> any((println(i); v) for (i, v) in enumerate(a))\n1\ntrue\n\njulia> any([missing, true])\ntrue\n\njulia> any([false, missing])\nmissing\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.any-Tuple{Function, AbstractArray}","page":"References","title":"Base.any","text":"any(p, A; dims)\n\nDetermine whether predicate p returns true for any elements along the given dimensions of an array.\n\nExamples\n\njulia> A = [1 -1; 2 -2]\n2×2 Matrix{Int64}:\n 1  -1\n 2  -2\n\njulia> any(i -> i > 0, A, dims=1)\n1×2 Matrix{Bool}:\n 1  0\n\njulia> any(i -> i > 0, A, dims=2)\n2×1 Matrix{Bool}:\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.append!-Tuple{Vector{T} where T, AbstractVector{T} where T}","page":"References","title":"Base.append!","text":"append!(collection, collections...) -> collection.\n\nFor an ordered container collection, add the elements of each collections to the end of it.\n\ncompat: Julia 1.6\nSpecifying multiple collections to be appended requires at least Julia 1.6.\n\nExamples\n\njulia> append!([1], [2, 3])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> append!([1, 2, 3], [4, 5], [6])\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nUse push! to add individual items to collection which are not already themselves in another collection. The result of the preceding example is equivalent to push!([1, 2, 3], 4, 5, 6).\n\nSee sizehint! for notes about the performance model.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.argmax-Tuple{AbstractArray}","page":"References","title":"Base.argmax","text":"argmax(A; dims) -> indices\n\nFor an array input, return the indices of the maximum elements over the given dimensions. NaN is treated as greater than all other values.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> argmax(A, dims=1)\n1×2 Matrix{CartesianIndex{2}}:\n CartesianIndex(2, 1)  CartesianIndex(2, 2)\n\njulia> argmax(A, dims=2)\n2×1 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.argmax-Tuple{AbstractRange}","page":"References","title":"Base.argmax","text":"argmax(r::AbstractRange)\n\nRanges can have multiple maximal elements. In that case argmax will return a maximal index, but not necessarily the first one.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.argmax-Tuple{Any}","page":"References","title":"Base.argmax","text":"argmax(itr)\n\nReturn the index or key of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned.\n\nThe collection must not be empty.\n\nExamples\n\njulia> argmax([8,0.1,-9,pi])\n1\n\njulia> argmax([1,7,7,6])\n2\n\njulia> argmax([1,7,7,NaN])\n4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.argmin-Tuple{AbstractArray}","page":"References","title":"Base.argmin","text":"argmin(A; dims) -> indices\n\nFor an array input, return the indices of the minimum elements over the given dimensions. NaN is treated as less than all other values.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> argmin(A, dims=1)\n1×2 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 1)  CartesianIndex(1, 2)\n\njulia> argmin(A, dims=2)\n2×1 Matrix{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.argmin-Tuple{AbstractRange}","page":"References","title":"Base.argmin","text":"argmin(r::AbstractRange)\n\nRanges can have multiple minimal elements. In that case argmin will return a minimal index, but not necessarily the first one.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.argmin-Tuple{Any}","page":"References","title":"Base.argmin","text":"argmin(itr)\n\nReturn the index or key of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned.\n\nThe collection must not be empty.\n\nExamples\n\njulia> argmin([8,0.1,-9,pi])\n3\n\njulia> argmin([7,1,1,6])\n2\n\njulia> argmin([7,1,1,NaN])\n4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ascii-Tuple{AbstractString}","page":"References","title":"Base.ascii","text":"ascii(s::AbstractString)\n\nConvert a string to String type and check that it contains only ASCII data, otherwise throwing an ArgumentError indicating the position of the first non-ASCII byte.\n\nExamples\n\njulia> ascii(\"abcdeγfgh\")\nERROR: ArgumentError: invalid ASCII at index 6 in \"abcdeγfgh\"\nStacktrace:\n[...]\n\njulia> ascii(\"abcdefgh\")\n\"abcdefgh\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.asyncmap!-Tuple{Any, Any, Any, Vararg{Any, N} where N}","page":"References","title":"Base.asyncmap!","text":"asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)\n\nLike asyncmap, but stores output in results rather than returning a collection.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.asyncmap-Tuple{Any, Vararg{Any, N} where N}","page":"References","title":"Base.asyncmap","text":"asyncmap(f, c...; ntasks=0, batch_size=nothing)\n\nUses multiple concurrent tasks to map f over a collection (or multiple equal length collections). For multiple collection arguments, f is applied elementwise.\n\nntasks specifies the number of tasks to run concurrently. Depending on the length of the collections, if ntasks is unspecified, up to 100 tasks will be used for concurrent mapping.\n\nntasks can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of ntasks_func is less than the current number of tasks.\n\nIf batch_size is specified, the collection is processed in batch mode. f must then be a function that must accept a Vector of argument tuples and must return a vector of results. The input vector will have a length of batch_size or less.\n\nThe following examples highlight execution in different tasks by returning the objectid of the tasks in which the mapping function is executed.\n\nFirst, with ntasks undefined, each element is processed in a different task.\n\njulia> tskoid() = objectid(current_task());\n\njulia> asyncmap(x->tskoid(), 1:5)\n5-element Array{UInt64,1}:\n 0x6e15e66c75c75853\n 0x440f8819a1baa682\n 0x9fb3eeadd0c83985\n 0xebd3e35fe90d4050\n 0x29efc93edce2b961\n\njulia> length(unique(asyncmap(x->tskoid(), 1:5)))\n5\n\nWith ntasks=2 all elements are processed in 2 tasks.\n\njulia> asyncmap(x->tskoid(), 1:5; ntasks=2)\n5-element Array{UInt64,1}:\n 0x027ab1680df7ae94\n 0xa23d2f80cd7cf157\n 0x027ab1680df7ae94\n 0xa23d2f80cd7cf157\n 0x027ab1680df7ae94\n\njulia> length(unique(asyncmap(x->tskoid(), 1:5; ntasks=2)))\n2\n\nWith batch_size defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. map is used in the modified mapping function to achieve this.\n\njulia> batch_func(input) = map(x->string(\"args_tuple: \", x, \", element_val: \", x[1], \", task: \", tskoid()), input)\nbatch_func (generic function with 1 method)\n\njulia> asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)\n5-element Array{String,1}:\n \"args_tuple: (1,), element_val: 1, task: 9118321258196414413\"\n \"args_tuple: (2,), element_val: 2, task: 4904288162898683522\"\n \"args_tuple: (3,), element_val: 3, task: 9118321258196414413\"\n \"args_tuple: (4,), element_val: 4, task: 4904288162898683522\"\n \"args_tuple: (5,), element_val: 5, task: 9118321258196414413\"\n\nnote: Note\nCurrently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, asyncmap is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.atexit-Tuple{Function}","page":"References","title":"Base.atexit","text":"atexit(f)\n\nRegister a zero-argument function f() to be called at process exit. atexit() hooks are called in last in first out (LIFO) order and run before object finalizers.\n\nExit hooks are allowed to call exit(n), in which case Julia will exit with exit code n (instead of the original exit code). If more than one exit hook calls exit(n), then Julia will exit with the exit code corresponding to the last called exit hook that calls exit(n). (Because exit hooks are called in LIFO order, \"last called\" is equivalent to \"first registered\".)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.atreplinit-Tuple{Function}","page":"References","title":"Base.atreplinit","text":"atreplinit(f)\n\nRegister a one-argument function to be called before the REPL interface is initialized in interactive sessions; this is useful to customize the interface. The argument of f is the REPL object. This function should be called from within the .julia/config/startup.jl initialization file.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.axes-Tuple{Any}","page":"References","title":"Base.axes","text":"axes(A)\n\nReturn the tuple of valid indices for array A.\n\nExamples\n\njulia> A = fill(1, (5,6,7));\n\njulia> axes(A)\n(Base.OneTo(5), Base.OneTo(6), Base.OneTo(7))\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.axes-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}","page":"References","title":"Base.axes","text":"axes(A, d)\n\nReturn the valid range of indices for array A along dimension d.\n\nSee also size, and the manual chapter on arrays with custom indices.\n\nExamples\n\njulia> A = fill(1, (5,6,7));\n\njulia> axes(A, 2)\nBase.OneTo(6)\n\nUsage note\n\nEach of the indices has to be an AbstractUnitRange{<:Integer}, but at the same time can be a type that uses custom indices. So, for example, if you need a subset, use generalized indexing constructs like begin/end or firstindex/lastindex:\n\nix = axes(v, 1)\nix[2:end]          # will work for eg Vector, but may fail in general\nix[(begin+1):end]  # works for generalized indexes\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.backtrace-Tuple{}","page":"References","title":"Base.backtrace","text":"backtrace()\n\nGet a backtrace object for the current program point.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.big-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"References","title":"Base.big","text":"big(T::Type)\n\nCompute the type that represents the numeric type T with arbitrary precision. Equivalent to typeof(big(zero(T))).\n\nExamples\n\njulia> big(Rational)\nRational{BigInt}\n\njulia> big(Float64)\nBigFloat\n\njulia> big(Complex{Int})\nComplex{BigInt}\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.bind-Tuple{Channel, Task}","page":"References","title":"Base.bind","text":"bind(chnl::Channel, task::Task)\n\nAssociate the lifetime of chnl with a task. Channel chnl is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on chnl.\n\nThe chnl object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed Channel objects.\n\nWhen a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.\n\nExamples\n\njulia> c = Channel(0);\n\njulia> task = @async foreach(i->put!(c, i), 1:4);\n\njulia> bind(c,task);\n\njulia> for i in c\n           @show i\n       end;\ni = 1\ni = 2\ni = 3\ni = 4\n\njulia> isopen(c)\nfalse\n\njulia> c = Channel(0);\n\njulia> task = @async (put!(c, 1); error(\"foo\"));\n\njulia> bind(c, task);\n\njulia> take!(c)\n1\n\njulia> put!(c, 1);\nERROR: TaskFailedException\nStacktrace:\n[...]\n    nested task error: foo\n[...]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.binomial-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"References","title":"Base.binomial","text":"binomial(n::Integer, k::Integer)\n\nThe binomial coefficient binomnk, being the coefficient of the kth term in the polynomial expansion of (1+x)^n.\n\nIf n is non-negative, then it is the number of ways to choose k out of n items:\n\nbinomnk = fracnk (n-k)\n\nwhere n is the factorial function.\n\nIf n is negative, then it is defined in terms of the identity\n\nbinomnk = (-1)^k binomk-n-1k\n\nExamples\n\njulia> binomial(5, 3)\n10\n\njulia> factorial(5) ÷ (factorial(5-3) * factorial(3))\n10\n\njulia> binomial(-5, 3)\n-35\n\nSee also\n\nfactorial\n\nExternal links\n\nBinomial coefficient on Wikipedia.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.bitreverse-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}","page":"References","title":"Base.bitreverse","text":"bitreverse(x)\n\nReverse the order of bits in integer x. x must have a fixed bit width, e.g. be an Int16 or Int32.\n\ncompat: Julia 1.5\nThis function requires Julia 1.5 or later.\n\nExamples\n\njulia> bitreverse(0x8080808080808080)\n0x0101010101010101\n\njulia> reverse(bitstring(0xa06e)) == bitstring(bitreverse(0xa06e))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.bitrotate-Union{Tuple{T}, Tuple{T, Integer}} where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}","page":"References","title":"Base.bitrotate","text":"bitrotate(x::Base.BitInteger, k::Integer)\n\nbitrotate(x, k) implements bitwise rotation. It returns the value of x with its bits rotated left k times. A negative value of k will rotate to the right instead.\n\ncompat: Julia 1.5\nThis function requires Julia 1.5 or later.\n\njulia> bitrotate(UInt8(114), 2)\n0xc9\n\njulia> bitstring(bitrotate(0b01110010, 2))\n\"11001001\"\n\njulia> bitstring(bitrotate(0b01110010, -2))\n\"10011100\"\n\njulia> bitstring(bitrotate(0b01110010, 8))\n\"01110010\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.bitstring","page":"References","title":"Base.bitstring","text":"bitstring(n)\n\nA string giving the literal bit representation of a number.\n\nExamples\n\njulia> bitstring(4)\n\"0000000000000000000000000000000000000000000000000000000000000100\"\n\njulia> bitstring(2.2)\n\"0100000000000001100110011001100110011001100110011001100110011010\"\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.bitsunionsize-Tuple{Union}","page":"References","title":"Base.bitsunionsize","text":"Base.bitsunionsize(U::Union)\n\nFor a Union of isbitstype types, return the size of the largest type; assumes Base.isbitsunion(U) == true.\n\nExamples\n\njulia> Base.bitsunionsize(Union{Float64, UInt8})\n0x0000000000000008\n\njulia> Base.bitsunionsize(Union{Float64, UInt8, Int128})\n0x0000000000000010\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.bodyfunction-Tuple{Method}","page":"References","title":"Base.bodyfunction","text":"fbody = bodyfunction(basemethod::Method)\n\nFind the keyword \"body function\" (the function that contains the body of the method as written, called after all missing keyword-arguments have been assigned default values). basemethod is the method you obtain via which or methods.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.bswap-Tuple{Union{Int8, UInt8}}","page":"References","title":"Base.bswap","text":"bswap(n)\n\nReverse the byte order of n.\n\n(See also ntoh and hton to convert between the current native byte order and big-endian order.)\n\nExamples\n\njulia> a = bswap(0x10203040)\n0x40302010\n\njulia> bswap(a)\n0x10203040\n\njulia> string(1, base = 2)\n\"1\"\n\njulia> string(bswap(1), base = 2)\n\"100000000000000000000000000000000000000000000000000000000\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.bytes2hex","page":"References","title":"Base.bytes2hex","text":"bytes2hex(a::AbstractArray{UInt8}) -> String\nbytes2hex(io::IO, a::AbstractArray{UInt8})\n\nConvert an array a of bytes to its hexadecimal string representation, either returning a String via bytes2hex(a) or writing the string to an io stream via bytes2hex(io, a).  The hexadecimal characters are all lowercase.\n\nExamples\n\njulia> a = string(12345, base = 16)\n\"3039\"\n\njulia> b = hex2bytes(a)\n2-element Vector{UInt8}:\n 0x30\n 0x39\n\njulia> bytes2hex(b)\n\"3039\"\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.bytesavailable-Tuple{Base.AbstractPipe}","page":"References","title":"Base.bytesavailable","text":"bytesavailable(io)\n\nReturn the number of bytes available for reading before a read from this stream or buffer will block.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> bytesavailable(io)\n34\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.canonicalize2-Tuple{Any, Any}","page":"References","title":"Base.canonicalize2","text":"hi, lo = canonicalize2(big, little)\n\nGenerate a representation where all the nonzero bits in hi are more significant than any of the nonzero bits in lo. big must be larger in absolute value than little.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cat-Tuple","page":"References","title":"Base.cat","text":"cat(A...; dims=dims)\n\nConcatenate the input arrays along the specified dimensions in the iterable dims. For dimensions not in dims, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in dims, the size of the output array is the sum of the sizes of the input arrays along that dimension. If dims is a single number, the different arrays are tightly stacked along that dimension. If dims is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, cat(matrices...; dims=(1,2)) builds a block diagonal matrix, i.e. a block matrix with matrices[1], matrices[2], ... as diagonal blocks and matching zero blocks away from the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.catch_backtrace-Tuple{}","page":"References","title":"Base.catch_backtrace","text":"catch_backtrace()\n\nGet the backtrace of the current exception, for use within catch blocks.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.catch_stack","page":"References","title":"Base.catch_stack","text":"catch_stack(task=current_task(); [inclue_bt=true])\n\nGet the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of (exception,backtrace) pairs, or a Vector of exceptions if include_bt is false.\n\nExplicitly passing task will return the current exception stack on an arbitrary task. This is useful for inspecting tasks which have failed due to uncaught exceptions.\n\ncompat: Julia 1.1\nThis function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.ccall_macro_parse-Tuple{Expr}","page":"References","title":"Base.ccall_macro_parse","text":"ccall_macro_parse(expression)\n\nccall_macro_parse is an implementation detail of `@ccall\n\nit takes an expression like :(printf(\"%d\"::Cstring, value::Cuint)::Cvoid) returns: a tuple of (function_name, return_type, arg_types, args)\n\nThe above input outputs this:\n\n(:printf, :Cvoid, [:Cstring, :Cuint], [\"%d\", :value])\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cconvert","page":"References","title":"Base.cconvert","text":"cconvert(T,x)\n\nConvert x to a value to be passed to C code as type T, typically by calling convert(T, x).\n\nIn cases where x cannot be safely converted to T, unlike convert, cconvert may return an object of a type different from T, which however is suitable for unsafe_convert to handle. The result of this function should be kept valid (for the GC) until the result of unsafe_convert is not needed anymore. This can be used to allocate memory that will be accessed by the ccall. If multiple objects need to be allocated, a tuple of the objects can be used as return value.\n\nNeither convert nor cconvert should take a Julia object and turn it into a Ptr.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.ceil","page":"References","title":"Base.ceil","text":"ceil([T,] x)\nceil(x; digits::Integer= [, base = 10])\nceil(x; sigdigits::Integer= [, base = 10])\n\nceil(x) returns the nearest integral value of the same type as x that is greater than or equal to x.\n\nceil(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\n\ndigits, sigdigits and base work as for round.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.channeled_tasks-Tuple{Int64, Vararg{Any, N} where N}","page":"References","title":"Base.channeled_tasks","text":"channeled_tasks(n::Int, funcs...; ctypes=fill(Any,n), csizes=fill(0,n))\n\nA convenience method to create n channels and bind them to tasks started from the provided functions in a single call. Each func must accept n arguments which are the created channels. Channel types and sizes may be specified via keyword arguments ctypes and csizes respectively. If unspecified, all channels are of type Channel{Any}(0).\n\nReturns a tuple, (Array{Channel}, Array{Task}), of the created channels and tasks.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.checkbounds-Tuple{AbstractArray, Vararg{Any, N} where N}","page":"References","title":"Base.checkbounds","text":"checkbounds(A, I...)\n\nThrow an error if the specified indices I are not in bounds for the given array A.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.checkbounds-Tuple{Type{Bool}, AbstractArray, Vararg{Any, N} where N}","page":"References","title":"Base.checkbounds","text":"checkbounds(Bool, A, I...)\n\nReturn true if the specified indices I are in bounds for the given array A. Subtypes of AbstractArray should specialize this method if they need to provide custom bounds checking behaviors; however, in many cases one can rely on A's indices and checkindex.\n\nSee also checkindex.\n\nExamples\n\njulia> A = rand(3, 3);\n\njulia> checkbounds(Bool, A, 2)\ntrue\n\njulia> checkbounds(Bool, A, 3, 4)\nfalse\n\njulia> checkbounds(Bool, A, 1:3)\ntrue\n\njulia> checkbounds(Bool, A, 1:3, 2:4)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.checkbounds_indices-Tuple{Type{Bool}, Tuple, Tuple}","page":"References","title":"Base.checkbounds_indices","text":"checkbounds_indices(Bool, IA, I)\n\nReturn true if the \"requested\" indices in the tuple I fall within the bounds of the \"permitted\" indices specified by the tuple IA. This function recursively consumes elements of these tuples, usually in a 1-for-1 fashion,\n\ncheckbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &\n                                                      checkbounds_indices(Bool, IA, I)\n\nNote that checkindex is being used to perform the actual bounds-check for a single dimension of the array.\n\nThere are two important exceptions to the 1-1 rule: linear indexing and CartesianIndex{N}, both of which may \"consume\" more than one element of IA.\n\nSee also checkbounds.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.checkindex-Tuple{Type{Bool}, AbstractUnitRange, Any}","page":"References","title":"Base.checkindex","text":"checkindex(Bool, inds::AbstractUnitRange, index)\n\nReturn true if the given index is within the bounds of inds. Custom types that would like to behave as indices for all arrays can extend this method in order to provide a specialized bounds checking implementation.\n\nExamples\n\njulia> checkindex(Bool, 1:20, 8)\ntrue\n\njulia> checkindex(Bool, 1:20, 21)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.chomp-Tuple{AbstractString}","page":"References","title":"Base.chomp","text":"chomp(s::AbstractString) -> SubString\n\nRemove a single trailing newline from a string.\n\nExamples\n\njulia> chomp(\"Hello\\n\")\n\"Hello\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.chop-Tuple{AbstractString}","page":"References","title":"Base.chop","text":"chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)\n\nRemove the first head and the last tail characters from s. The call chop(s) removes the last character from s. If it is requested to remove more characters than length(s) then an empty string is returned.\n\nExamples\n\njulia> a = \"March\"\n\"March\"\n\njulia> chop(a)\n\"Marc\"\n\njulia> chop(a, head = 1, tail = 2)\n\"ar\"\n\njulia> chop(a, head = 5, tail = 5)\n\"\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.circcopy!-Tuple{Any, Any}","page":"References","title":"Base.circcopy!","text":"circcopy!(dest, src)\n\nCopy src to dest, indexing each dimension modulo its length. src and dest must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap dest agrees with src.\n\nExamples\n\njulia> src = reshape(Vector(1:16), (4,4))\n4×4 Array{Int64,2}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> dest = OffsetArray{Int}(undef, (0:3,2:5))\n\njulia> circcopy!(dest, src)\nOffsetArrays.OffsetArray{Int64,2,Array{Int64,2}} with indices 0:3×2:5:\n 8  12  16  4\n 5   9  13  1\n 6  10  14  2\n 7  11  15  3\n\njulia> dest[1:3,2:4] == src[1:3,2:4]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.circshift!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, Tuple{Vararg{Integer, N}} where N}} where {T, N}","page":"References","title":"Base.circshift!","text":"circshift!(dest, src, shifts)\n\nCircularly shift, i.e. rotate, the data in src, storing the result in dest. shifts specifies the amount to shift in each dimension.\n\nThe dest array must be distinct from the src array (they cannot alias each other).\n\nSee also circshift.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.circshift-Tuple{AbstractArray, Any}","page":"References","title":"Base.circshift","text":"circshift(A, shifts)\n\nCircularly shift, i.e. rotate, the data in an array. The second argument is a tuple or vector giving the amount to shift in each dimension, or an integer to shift only in the first dimension.\n\nExamples\n\njulia> b = reshape(Vector(1:16), (4,4))\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> circshift(b, (0,2))\n4×4 Matrix{Int64}:\n  9  13  1  5\n 10  14  2  6\n 11  15  3  7\n 12  16  4  8\n\njulia> circshift(b, (-1,0))\n4×4 Matrix{Int64}:\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n 1  5   9  13\n\njulia> a = BitArray([true, true, false, false, true])\n5-element BitVector:\n 1\n 1\n 0\n 0\n 1\n\njulia> circshift(a, 1)\n5-element BitVector:\n 1\n 1\n 1\n 0\n 0\n\njulia> circshift(a, -1)\n5-element BitVector:\n 1\n 0\n 0\n 1\n 1\n\nSee also circshift!.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cis-Tuple{Complex}","page":"References","title":"Base.cis","text":"cis(z)\n\nReturn exp(iz).\n\nExamples\n\njulia> cis(π) ≈ -1\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cispi-Tuple{Complex}","page":"References","title":"Base.cispi","text":"cispi(z)\n\nCompute exp(ipi x) more accurately than cis(pi*x), especially for large x.\n\nExamples\n\njulia> cispi(1)\n-1.0 + 0.0im\n\njulia> cispi(0.25 + 1im)\n0.030556854645952924 + 0.030556854645952924im\n\ncompat: Julia 1.6\nThis function requires Julia 1.6 or later.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cld-Tuple{Any, Any}","page":"References","title":"Base.cld","text":"cld(x, y)\n\nSmallest integer larger than or equal to x/y. Equivalent to div(x, y, RoundUp).\n\nSee also: div\n\nExamples\n\njulia> cld(5.5,2.2)\n3.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.close","page":"References","title":"Base.close","text":"close(stream)\n\nClose an I/O stream. Performs a flush first.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.close-2","page":"References","title":"Base.close","text":"close(c::Channel[, excp::Exception])\n\nClose a channel. An exception (optionally given by excp), is thrown by:\n\nput! on a closed channel.\ntake! and fetch on an empty, closed channel.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.cmp-Tuple{AbstractString, AbstractString}","page":"References","title":"Base.cmp","text":"cmp(a::AbstractString, b::AbstractString) -> Int\n\nCompare two strings. Return 0 if both strings have the same length and the character at each index is the same in both strings. Return -1 if a is a prefix of b, or if a comes before b in alphabetical order. Return 1 if b is a prefix of a, or if b comes before a in alphabetical order (technically, lexicographical order by Unicode code points).\n\nExamples\n\njulia> cmp(\"abc\", \"abc\")\n0\n\njulia> cmp(\"ab\", \"abc\")\n-1\n\njulia> cmp(\"abc\", \"ab\")\n1\n\njulia> cmp(\"ab\", \"ac\")\n-1\n\njulia> cmp(\"ac\", \"ab\")\n1\n\njulia> cmp(\"α\", \"a\")\n1\n\njulia> cmp(\"b\", \"β\")\n-1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cmp-Tuple{Any, Any, Any}","page":"References","title":"Base.cmp","text":"cmp(<, x, y)\n\nReturn -1, 0, or 1 depending on whether x is less than, equal to, or greater than y, respectively. The first argument specifies a less-than comparison function to use.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cmp-Tuple{Any, Any}","page":"References","title":"Base.cmp","text":"cmp(x,y)\n\nReturn -1, 0, or 1 depending on whether x is less than, equal to, or greater than y, respectively. Uses the total order implemented by isless.\n\nExamples\n\njulia> cmp(1, 2)\n-1\n\njulia> cmp(2, 1)\n1\n\njulia> cmp(2+im, 3-im)\nERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})\n[...]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.coalesce","page":"References","title":"Base.coalesce","text":"coalesce(x, y...)\n\nReturn the first value in the arguments which is not equal to missing, if any. Otherwise return missing.\n\nSee also something.\n\nExamples\n\njulia> coalesce(missing, 1)\n1\n\njulia> coalesce(1, missing)\n1\n\njulia> coalesce(nothing, 1)  # returns `nothing`\n\njulia> coalesce(missing, missing)\nmissing\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.code_lowered-Tuple{Any, Any}","page":"References","title":"Base.code_lowered","text":"code_lowered(f, types; generated=true, debuginfo=:default)\n\nReturn an array of the lowered forms (IR) for the methods matching the given generic function and type signature.\n\nIf generated is false, the returned CodeInfo instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If generated is true, these CodeInfo instances will correspond to the method bodies yielded by expanding the generators.\n\nThe keyword debuginfo controls the amount of code metadata present in the output.\n\nNote that an error will be thrown if types are not leaf types when generated is true and any of the corresponding methods are an @generated method.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.code_typed-Tuple{Any, Any}","page":"References","title":"Base.code_typed","text":"code_typed(f, types; optimize=true, debuginfo=:default)\n\nReturns an array of type-inferred lowered form (IR) for the methods matching the given generic function and type signature. The keyword argument optimize controls whether additional optimizations, such as inlining, are also applied. The keyword debuginfo controls the amount of code metadata present in the output, possible options are :source or :none.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.code_typed_by_type-Tuple{Type}","page":"References","title":"Base.code_typed_by_type","text":"code_typed_by_type(types::Type{<:Tuple}; ...)\n\nSimilar to code_typed, except the argument is a tuple type describing a full signature to query.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.codepoint","page":"References","title":"Base.codepoint","text":"codepoint(c::AbstractChar) -> Integer\n\nReturn the Unicode codepoint (an unsigned integer) corresponding to the character c (or throw an exception if c does not represent a valid character). For Char, this is a UInt32 value, but AbstractChar types that represent only a subset of Unicode may return a different-sized integer (e.g. UInt8).\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.codeunit-Tuple{AbstractString, Integer}","page":"References","title":"Base.codeunit","text":"codeunit(s::AbstractString, i::Integer) -> Union{UInt8, UInt16, UInt32}\n\nReturn the code unit value in the string s at index i. Note that\n\ncodeunit(s, i) :: codeunit(s)\n\nI.e. the value returned by codeunit(s, i) is of the type returned by codeunit(s).\n\nExamples\n\njulia> a = codeunit(\"Hello\", 2)\n0x65\n\njulia> typeof(a)\nUInt8\n\nSee also: ncodeunits, checkbounds\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.codeunit-Tuple{AbstractString}","page":"References","title":"Base.codeunit","text":"codeunit(s::AbstractString) -> Type{<:Union{UInt8, UInt16, UInt32}}\n\nReturn the code unit type of the given string object. For ASCII, Latin-1, or UTF-8 encoded strings, this would be UInt8; for UCS-2 and UTF-16 it would be UInt16; for UTF-32 it would be UInt32. The code unit type need not be limited to these three types, but it's hard to think of widely used string encodings that don't use one of these units. codeunit(s) is the same as typeof(codeunit(s,1)) when s is a non-empty string.\n\nSee also: ncodeunits\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.codeunits-Tuple{AbstractString}","page":"References","title":"Base.codeunits","text":"codeunits(s::AbstractString)\n\nObtain a vector-like object containing the code units of a string. Returns a CodeUnits wrapper by default, but codeunits may optionally be defined for new string types if necessary.\n\nExamples\n\njulia> codeunits(\"Juλia\")\n6-element Base.CodeUnits{UInt8, String}:\n 0x4a\n 0x75\n 0xce\n 0xbb\n 0x69\n 0x61\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.collect-Tuple{Any}","page":"References","title":"Base.collect","text":"collect(collection)\n\nReturn an Array of all items in a collection or iterator. For dictionaries, returns Pair{KeyType, ValType}. If the argument is array-like or is an iterator with the HasShape trait, the result will have the same shape and number of dimensions as the argument.\n\nExamples\n\njulia> collect(1:2:13)\n7-element Vector{Int64}:\n  1\n  3\n  5\n  7\n  9\n 11\n 13\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.collect-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"References","title":"Base.collect","text":"collect(element_type, collection)\n\nReturn an Array with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as collection.\n\nExamples\n\njulia> collect(Float64, 1:2:5)\n3-element Vector{Float64}:\n 1.0\n 3.0\n 5.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.compilecache","page":"References","title":"Base.compilecache","text":"Base.compilecache(module::PkgId)\n\nCreates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in DEPOT_PATH[1]/compiled. See Module initialization and precompilation for important notes.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.complex-Tuple{Complex}","page":"References","title":"Base.complex","text":"complex(r, [i])\n\nConvert real numbers or arrays to complex. i defaults to zero.\n\nExamples\n\njulia> complex(7)\n7 + 0im\n\njulia> complex([1, 2, 3])\n3-element Vector{Complex{Int64}}:\n 1 + 0im\n 2 + 0im\n 3 + 0im\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.complex-Union{Tuple{Type{T}}, Tuple{T}} where T<:Real","page":"References","title":"Base.complex","text":"complex(T::Type)\n\nReturn an appropriate type which can represent a value of type T as a complex number. Equivalent to typeof(complex(zero(T))).\n\nExamples\n\njulia> complex(Complex{Int})\nComplex{Int64}\n\njulia> complex(Int)\nComplex{Int64}\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.conj!-Tuple{AbstractArray{var\"#s832\", N} where {var\"#s832\"<:Number, N}}","page":"References","title":"Base.conj!","text":"conj!(A)\n\nTransform an array to its complex conjugate in-place.\n\nSee also conj.\n\nExamples\n\njulia> A = [1+im 2-im; 2+2im 3+im]\n2×2 Matrix{Complex{Int64}}:\n 1+1im  2-1im\n 2+2im  3+1im\n\njulia> conj!(A);\n\njulia> A\n2×2 Matrix{Complex{Int64}}:\n 1-1im  2+1im\n 2-2im  3-1im\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.conj-Tuple{Complex}","page":"References","title":"Base.conj","text":"conj(z)\n\nCompute the complex conjugate of a complex number z.\n\nExamples\n\njulia> conj(1 + 3im)\n1 - 3im\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.contains-Tuple{AbstractString, Any}","page":"References","title":"Base.contains","text":"contains(haystack::AbstractString, needle)\n\nReturn true if haystack contains needle. This is the same as occursin(needle, haystack), but is provided for consistency with startswith(haystack, needle) and endswith(haystack, needle).\n\nExamples\n\njulia> contains(\"JuliaLang is pretty cool!\", \"Julia\")\ntrue\n\njulia> contains(\"JuliaLang is pretty cool!\", 'a')\ntrue\n\njulia> contains(\"aba\", r\"a.a\")\ntrue\n\njulia> contains(\"abba\", r\"a.a\")\nfalse\n\ncompat: Julia 1.5\nThe contains function requires at least Julia 1.5.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.contains-Tuple{Any}","page":"References","title":"Base.contains","text":"contains(needle)\n\nCreate a function that checks whether its argument contains needle, i.e. a function equivalent to haystack -> contains(haystack, needle).\n\nThe returned function is of type Base.Fix2{typeof(contains)}, which can be used to implement specialized methods.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.convert","page":"References","title":"Base.convert","text":"convert(T, x)\n\nConvert x to a value of type T.\n\nIf T is an Integer type, an InexactError will be raised if x is not representable by T, for example if x is not integer-valued, or is outside the range supported by T.\n\nExamples\n\njulia> convert(Int, 3.0)\n3\n\njulia> convert(Int, 3.5)\nERROR: InexactError: Int64(3.5)\nStacktrace:\n[...]\n\nIf T is a AbstractFloat or Rational type, then it will return the closest value to x representable by T.\n\njulia> x = 1/3\n0.3333333333333333\n\njulia> convert(Float32, x)\n0.33333334f0\n\njulia> convert(Rational{Int32}, x)\n1//3\n\njulia> convert(Rational{Int64}, x)\n6004799503160661//18014398509481984\n\nIf T is a collection type and x a collection, the result of convert(T, x) may alias all or part of x.\n\njulia> x = Int[1, 2, 3];\n\njulia> y = convert(Vector{Int}, x);\n\njulia> y === x\ntrue\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.copy","page":"References","title":"Base.copy","text":"copy(x)\n\nCreate a shallow copy of x: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.copy!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"References","title":"Base.copy!","text":"copy!(dst, src) -> dst\n\nIn-place copy of src into dst, discarding any pre-existing elements in dst. If dst and src are of the same type, dst == src should hold after the call. If dst and src are multidimensional arrays, they must have equal axes. See also copyto!.\n\ncompat: Julia 1.1\nThis method requires at least Julia 1.1. In Julia 1.0 this method is available from the Future standard library as Future.copy!.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.copyfirst!-Tuple{AbstractArray, AbstractArray}","page":"References","title":"Base.copyfirst!","text":"Extract first entry of slices of array A into existing array R.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.copymutable-Tuple{AbstractArray}","page":"References","title":"Base.copymutable","text":"copymutable(a)\n\nMake a mutable copy of an array or iterable a.  For a::Array, this is equivalent to copy(a), but for other array types it may differ depending on the type of similar(a).  For generic iterables this is equivalent to collect(a).\n\nExamples\n\njulia> tup = (1, 2, 3)\n(1, 2, 3)\n\njulia> Base.copymutable(tup)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.copysign-Tuple{Real, Real}","page":"References","title":"Base.copysign","text":"copysign(x, y) -> z\n\nReturn z which has the magnitude of x and the same sign as y.\n\nExamples\n\njulia> copysign(1, -2)\n-1\n\njulia> copysign(-1, 2)\n1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.copyto!-Tuple{AbstractArray, AbstractArray}","page":"References","title":"Base.copyto!","text":"copyto!(dest::AbstractArray, src) -> dest\n\nCopy all elements from collection src to array dest, whose length must be greater than or equal to the length n of src. The first n elements of dest are overwritten, the other elements are left untouched.\n\nExamples\n\njulia> x = [1., 0., 3., 0., 5.];\n\njulia> y = zeros(7);\n\njulia> copyto!(y, x);\n\njulia> y\n7-element Vector{Float64}:\n 1.0\n 0.0\n 3.0\n 0.0\n 5.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.copyto!-Tuple{AbstractArray, CartesianIndices, AbstractArray, CartesianIndices}","page":"References","title":"Base.copyto!","text":"copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -> dest\n\nCopy the block of src in the range of Rsrc to the block of dest in the range of Rdest. The sizes of the two regions must match.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.copyto!-Tuple{Array, Integer, Array, Integer, Integer}","page":"References","title":"Base.copyto!","text":"copyto!(dest, do, src, so, N)\n\nCopy N elements from collection src starting at offset so, to array dest starting at offset do. Return dest.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.count!-Tuple{AbstractArray, Union{Base.AbstractBroadcasted, AbstractArray}}","page":"References","title":"Base.count!","text":"count!([f=identity,] r, A)\n\nCount the number of elements in A for which f returns true over the singleton dimensions of r, writing the result into r in-place.\n\ncompat: Julia 1.5\ninplace count! was added in Julia 1.5.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> count!(<=(2), [1 1], A)\n1×2 Matrix{Int64}:\n 1  1\n\njulia> count!(<=(2), [1; 1], A)\n2-element Vector{Int64}:\n 2\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.count-Tuple{Any}","page":"References","title":"Base.count","text":"count([f=identity,] itr; init=0) -> Integer\n\nCount the number of elements in itr for which the function f returns true. If f is omitted, count the number of true elements in itr (which should be a collection of boolean values). init optionally specifies the value to start counting from and therefore also determines the output type.\n\ncompat: Julia 1.6\ninit keyword was added in Julia 1.6.\n\nExamples\n\njulia> count(i->(4<=i<=6), [2,3,4,5,6])\n3\n\njulia> count([true, false, true, true])\n3\n\njulia> count(>(3), 1:7, init=0x03)\n0x07\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.count-Tuple{Union{AbstractPattern, AbstractString}, AbstractString}","page":"References","title":"Base.count","text":"count(\n    pattern::Union{AbstractString,AbstractPattern},\n    string::AbstractString;\n    overlap::Bool = false,\n)\n\nReturn the number of matches for pattern in string. This is equivalent to calling length(findall(pattern, string)) but more efficient.\n\nIf overlap=true, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.count-Tuple{Union{Base.AbstractBroadcasted, AbstractArray}}","page":"References","title":"Base.count","text":"count([f=identity,] A::AbstractArray; dims=:)\n\nCount the number of elements in A for which f returns true over the given dimensions.\n\ncompat: Julia 1.5\ndims keyword was added in Julia 1.5.\n\ncompat: Julia 1.6\ninit keyword was added in Julia 1.6.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> count(<=(2), A, dims=1)\n1×2 Matrix{Int64}:\n 1  1\n\njulia> count(<=(2), A, dims=2)\n2×1 Matrix{Int64}:\n 2\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.count_ones-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}","page":"References","title":"Base.count_ones","text":"count_ones(x::Integer) -> Integer\n\nNumber of ones in the binary representation of x.\n\nExamples\n\njulia> count_ones(7)\n3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.count_zeros-Tuple{Integer}","page":"References","title":"Base.count_zeros","text":"count_zeros(x::Integer) -> Integer\n\nNumber of zeros in the binary representation of x.\n\nExamples\n\njulia> count_zeros(Int32(2 ^ 16 - 1))\n16\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.countlines-Tuple{IO}","page":"References","title":"Base.countlines","text":"countlines(io::IO; eol::AbstractChar = '\\n')\n\nRead io until the end of the stream/file and count the number of lines. To specify a file pass the filename as the first argument. EOL markers other than '\\n' are supported by passing them as the second argument.  The last non-empty line of io is counted even if it does not end with the EOL, matching the length returned by eachline and readlines.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\\n\");\n\njulia> countlines(io)\n1\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> countlines(io)\n1\n\njulia> countlines(io, eol = '.')\n0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cumprod!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"References","title":"Base.cumprod!","text":"cumprod!(y::AbstractVector, x::AbstractVector)\n\nCumulative product of a vector x, storing the result in y. See also cumprod.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cumprod!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T","page":"References","title":"Base.cumprod!","text":"cumprod!(B, A; dims::Integer)\n\nCumulative product of A along the dimension dims, storing the result in B. See also cumprod.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cumprod-Tuple{AbstractArray}","page":"References","title":"Base.cumprod","text":"cumprod(A; dims::Integer)\n\nCumulative product along the dimension dim. See also cumprod! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\nExamples\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> cumprod(a, dims=1)\n2×3 Matrix{Int64}:\n 1   2   3\n 4  10  18\n\njulia> cumprod(a, dims=2)\n2×3 Matrix{Int64}:\n 1   2    6\n 4  20  120\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cumprod-Tuple{AbstractVector{T} where T}","page":"References","title":"Base.cumprod","text":"cumprod(itr)\n\nCumulative product of an iterator. See also cumprod! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\ncompat: Julia 1.5\ncumprod on a non-array iterator requires at least Julia 1.5.\n\nExamples\n\njulia> cumprod(fill(1//2, 3))\n3-element Vector{Rational{Int64}}:\n 1//2\n 1//4\n 1//8\n\njulia> cumprod([fill(1//3, 2, 2) for i in 1:3])\n3-element Vector{Matrix{Rational{Int64}}}:\n [1//3 1//3; 1//3 1//3]\n [2//9 2//9; 2//9 2//9]\n [4//27 4//27; 4//27 4//27]\n\njulia> cumprod((1, 2, 1))\n(1, 2, 2)\n\njulia> cumprod(x^2 for x in 1:3)\n3-element Vector{Int64}:\n  1\n  4\n 36\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cumsum!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T","page":"References","title":"Base.cumsum!","text":"cumsum!(B, A; dims::Integer)\n\nCumulative sum of A along the dimension dims, storing the result in B. See also cumsum.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cumsum-Tuple{AbstractVector{T} where T}","page":"References","title":"Base.cumsum","text":"cumsum(itr)\n\nCumulative sum an iterator. See also cumsum! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\ncompat: Julia 1.5\ncumsum on a non-array iterator requires at least Julia 1.5.\n\nExamples\n\njulia> cumsum([1, 1, 1])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> cumsum([fill(1, 2) for i in 1:3])\n3-element Vector{Vector{Int64}}:\n [1, 1]\n [2, 2]\n [3, 3]\n\njulia> cumsum((1, 1, 1))\n(1, 2, 3)\n\njulia> cumsum(x^2 for x in 1:3)\n3-element Vector{Int64}:\n  1\n  5\n 14\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.cumsum-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T","page":"References","title":"Base.cumsum","text":"cumsum(A; dims::Integer)\n\nCumulative sum along the dimension dims. See also cumsum! to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).\n\nExamples\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> cumsum(a, dims=1)\n2×3 Matrix{Int64}:\n 1  2  3\n 5  7  9\n\njulia> cumsum(a, dims=2)\n2×3 Matrix{Int64}:\n 1  3   6\n 4  9  15\n\nnote: Note\nThe return array's eltype is Int for signed integers of less than system word size  and UInt for unsigned integers of less than system word size. To preserve eltype of arrays with small signed or unsigned integer accumulate(+, A) should be used.julia> cumsum(Int8[100, 28])\n2-element Vector{Int64}:\n 100\n 128\n\njulia> accumulate(+,Int8[100, 28])\n2-element Vector{Int8}:\n  100\n -128In the former case, the integers are widened to system word size and therefore the result is Int64[100, 128]. In the latter case, no such widening happens and integer overflow results in Int8[100, -128].\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.current_task-Tuple{}","page":"References","title":"Base.current_task","text":"current_task()\n\nGet the currently running Task.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.dataids-Tuple{AbstractArray}","page":"References","title":"Base.dataids","text":"Base.dataids(A::AbstractArray)\n\nReturn a tuple of UInts that represent the mutable data segments of an array.\n\nCustom arrays that would like to opt-in to aliasing detection of their component parts can specialize this method to return the concatenation of the dataids of their component parts.  A typical definition for an array that wraps a parent is Base.dataids(C::CustomArray) = dataids(C.parent).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.datatype_alignment-Tuple{DataType}","page":"References","title":"Base.datatype_alignment","text":"Base.datatype_alignment(dt::DataType) -> Int\n\nMemory allocation minimum alignment for instances of this type. Can be called on any isconcretetype.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.datatype_fielddesc_type-Tuple{DataType}","page":"References","title":"Base.datatype_fielddesc_type","text":"Base.datatype_fielddesc_type(dt::DataType) -> Int\n\nReturn the size in bytes of each field-description entry in the layout array, located at (dt.layout + sizeof(DataTypeLayout)). Can be called on any isconcretetype.\n\nSee also fieldoffset.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.datatype_haspadding-Tuple{DataType}","page":"References","title":"Base.datatype_haspadding","text":"Base.datatype_haspadding(dt::DataType) -> Bool\n\nReturn whether the fields of instances of this type are packed in memory, with no intervening padding bytes. Can be called on any isconcretetype.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.datatype_nfields-Tuple{DataType}","page":"References","title":"Base.datatype_nfields","text":"Base.datatype_nfields(dt::DataType) -> Bool\n\nReturn the number of fields known to this datatype's layout. Can be called on any isconcretetype.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.datatype_pointerfree-Tuple{DataType}","page":"References","title":"Base.datatype_pointerfree","text":"Base.datatype_pointerfree(dt::DataType) -> Bool\n\nReturn whether instances of this type can contain references to gc-managed memory. Can be called on any isconcretetype.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.decode_overlong","page":"References","title":"Base.decode_overlong","text":"decode_overlong(c::AbstractChar) -> Integer\n\nWhen isoverlong(c) is true, decode_overlong(c) returns the Unicode codepoint value of c. AbstractChar implementations that support overlong encodings should implement Base.decode_overlong.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.deepcopy-Tuple{Any}","page":"References","title":"Base.deepcopy","text":"deepcopy(x)\n\nCreate a deep copy of x: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling deepcopy on an object should generally have the same effect as serializing and then deserializing it.\n\nWhile it isn't normally necessary, user-defined types can override the default deepcopy behavior by defining a specialized version of the function deepcopy_internal(x::T, dict::IdDict) (which shouldn't otherwise be used), where T is the type to be specialized for, and dict keeps track of objects copied so far within the recursion. Within the definition, deepcopy_internal should be used in place of deepcopy, and the dict variable should be updated as appropriate before returning.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.delete!-Tuple{Any, Any}","page":"References","title":"Base.delete!","text":"delete!(collection, key)\n\nDelete the mapping for the given key in a collection, if any, and return the collection.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2)\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> delete!(d, \"b\")\nDict{String, Int64} with 1 entry:\n  \"a\" => 1\n\njulia> delete!(d, \"b\") # d is left unchanged\nDict{String, Int64} with 1 entry:\n  \"a\" => 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.delete_method-Tuple{Method}","page":"References","title":"Base.delete_method","text":"delete_method(m::Method)\n\nMake method m uncallable and force recompilation of any methods that use(d) it.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.deleteat!-Tuple{Vector{T} where T, Any}","page":"References","title":"Base.deleteat!","text":"deleteat!(a::Vector, inds)\n\nRemove the items at the indices given by inds, and return the modified a. Subsequent items are shifted to fill the resulting gap.\n\ninds can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as a with true indicating entries to delete.\n\nExamples\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)\n3-element Vector{Int64}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])\n3-element Vector{Int64}:\n 5\n 3\n 1\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], (2, 2))\nERROR: ArgumentError: indices must be unique and sorted\nStacktrace:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.deleteat!-Tuple{Vector{T} where T, Integer}","page":"References","title":"Base.deleteat!","text":"deleteat!(a::Vector, i::Integer)\n\nRemove the item at the given i and return the modified a. Subsequent items are shifted to fill the resulting gap.\n\nExamples\n\njulia> deleteat!([6, 5, 4, 3, 2, 1], 2)\n5-element Vector{Int64}:\n 6\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.denominator-Tuple{Integer}","page":"References","title":"Base.denominator","text":"denominator(x)\n\nDenominator of the rational representation of x.\n\nExamples\n\njulia> denominator(2//3)\n3\n\njulia> denominator(4)\n1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.detach-Tuple{Cmd}","page":"References","title":"Base.detach","text":"detach(command)\n\nMark a command object so that it will be run in a new process group, allowing it to outlive the julia process, and not have Ctrl-C interrupts passed to it.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.diff-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"References","title":"Base.diff","text":"diff(A::AbstractVector)\ndiff(A::AbstractArray; dims::Integer)\n\nFinite difference operator on a vector or a multidimensional array A. In the latter case the dimension to operate on needs to be specified with the dims keyword argument.\n\ncompat: Julia 1.1\ndiff for arrays with dimension higher than 2 requires at least Julia 1.1.\n\nExamples\n\njulia> a = [2 4; 6 16]\n2×2 Matrix{Int64}:\n 2   4\n 6  16\n\njulia> diff(a, dims=2)\n2×1 Matrix{Int64}:\n  2\n 10\n\njulia> diff(vec(a))\n3-element Vector{Int64}:\n  4\n -2\n 12\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.digits!-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T<:Integer","page":"References","title":"Base.digits!","text":"digits!(array, n::Integer; base::Integer = 10)\n\nFills an array of the digits of n in the given base. More significant digits are at higher indices. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.\n\nExamples\n\njulia> digits!([2,2,2,2], 10, base = 2)\n4-element Vector{Int64}:\n 0\n 1\n 0\n 1\n\njulia> digits!([2,2,2,2,2,2], 10, base = 2)\n6-element Vector{Int64}:\n 0\n 1\n 0\n 1\n 0\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.digits-Tuple{Integer}","page":"References","title":"Base.digits","text":"digits([T<:Integer], n::Integer; base::T = 10, pad::Integer = 1)\n\nReturn an array with element type T (default Int) of the digits of n in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indices, such that n == sum(digits[k]*base^(k-1) for k=1:length(digits)).\n\nExamples\n\njulia> digits(10, base = 10)\n2-element Vector{Int64}:\n 0\n 1\n\njulia> digits(10, base = 2)\n4-element Vector{Int64}:\n 0\n 1\n 0\n 1\n\njulia> digits(10, base = 2, pad = 6)\n6-element Vector{Int64}:\n 0\n 1\n 0\n 1\n 0\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.disable_sigint-Tuple{Function}","page":"References","title":"Base.disable_sigint","text":"disable_sigint(f::Function)\n\nDisable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using do block syntax as follows:\n\ndisable_sigint() do\n    # interrupt-unsafe code\n    ...\nend\n\nThis is not needed on worker threads (Threads.threadid() != 1) since the InterruptException will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.displaysize-Tuple{IO}","page":"References","title":"Base.displaysize","text":"displaysize([io::IO]) -> (lines, columns)\n\nReturn the nominal size of the screen that may be used for rendering output to this IO object. If no input is provided, the environment variables LINES and COLUMNS are read. If those are not set, a default size of (24, 80) is returned.\n\nExamples\n\njulia> withenv(\"LINES\" => 30, \"COLUMNS\" => 100) do\n           displaysize()\n       end\n(30, 100)\n\nTo get your TTY size,\n\njulia> displaysize(stdout)\n(34, 147)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.div","page":"References","title":"Base.div","text":"div(x, y)\n÷(x, y)\n\nThe quotient from Euclidean division. Computes x/y, truncated to an integer.\n\nExamples\n\njulia> 9 ÷ 4\n2\n\njulia> -5 ÷ 3\n-1\n\njulia> 5.0 ÷ 2\n2.0\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.div-Tuple{Any, Any, RoundingMode}","page":"References","title":"Base.div","text":"div(x, y, r::RoundingMode=RoundToZero)\n\nThe quotient from Euclidean division. Computes x/y, rounded to an integer according to the rounding mode r. In other words, the quantity\n\nround(x/y,r)\n\nwithout any intermediate rounding.\n\nSee also: fld, cld which are special cases of this function\n\nExamples:\n\njulia> div(4, 3, RoundDown) # Matches fld(4, 3)\n1\njulia> div(4, 3, RoundUp) # Matches cld(4, 3)\n2\njulia> div(5, 2, RoundNearest)\n2\njulia> div(5, 2, RoundNearestTiesAway)\n3\njulia> div(-5, 2, RoundNearest)\n-2\njulia> div(-5, 2, RoundNearestTiesAway)\n-3\njulia> div(-5, 2, RoundNearestTiesUp)\n-2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.div12-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","page":"References","title":"Base.div12","text":"zhi, zlo = div12(x, y)\n\nA high-precision representation of x / y for floating-point numbers. Mathematically, zhi + zlo ≈ x / y, where zhi contains the most significant bits and zlo the least significant.\n\nExample: ```julia julia> x, y = Float32(π), 3.1f0 (3.1415927f0, 3.1f0)\n\njulia> x / y 1.013417f0\n\njulia> Float64(x) / Float64(y) 1.0134170444063078\n\njulia> hi, lo = Base.div12(x, y) (1.013417f0, 3.8867366f-8)\n\njulia> Float64(hi) + Float64(lo) 1.0134170444063066\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.divrem-Tuple{Any, Any}","page":"References","title":"Base.divrem","text":"divrem(x, y, r::RoundingMode=RoundToZero)\n\nThe quotient and remainder from Euclidean division. Equivalent to (div(x,y,r), rem(x,y,r)). Equivalently, with the default value of r, this call is equivalent to (x÷y, x%y).\n\nExamples\n\njulia> divrem(3,7)\n(0, 3)\n\njulia> divrem(7,3)\n(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.download-Tuple{AbstractString, AbstractString}","page":"References","title":"Base.download","text":"download(url::AbstractString, [path::AbstractString = tempname()]) -> path\n\nDownload a file from the given url, saving it to the location path, or if not specified, a temporary path. Returns the path of the downloaded file.\n\nnote: Note\nSince Julia 1.6, this function is deprecated and is just a thin wrapper around Downloads.download. In new code, you should use that function directly instead of calling this.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.dropdims-Tuple{Any}","page":"References","title":"Base.dropdims","text":"dropdims(A; dims)\n\nRemove the dimensions specified by dims from array A. Elements of dims must be unique and within the range 1:ndims(A). size(A,i) must equal 1 for all i in dims.\n\nExamples\n\njulia> a = reshape(Vector(1:4),(2,2,1,1))\n2×2×1×1 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\njulia> dropdims(a; dims=3)\n2×2×1 Array{Int64, 3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.dump-Tuple{Any}","page":"References","title":"Base.dump","text":"dump(x; maxdepth=8)\n\nShow every part of the representation of a value. The depth of the output is truncated at maxdepth.\n\nExamples\n\njulia> struct MyStruct\n           x\n           y\n       end\n\njulia> x = MyStruct(1, (2,3));\n\njulia> dump(x)\nMyStruct\n  x: Int64 1\n  y: Tuple{Int64, Int64}\n    1: Int64 2\n    2: Int64 3\n\njulia> dump(x; maxdepth = 1)\nMyStruct\n  x: Int64 1\n  y: Tuple{Int64, Int64}\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.eachcol-Tuple{AbstractVecOrMat{T} where T}","page":"References","title":"Base.eachcol","text":"eachcol(A::AbstractVecOrMat)\n\nCreate a generator that iterates over the second dimension of matrix A, returning the columns as AbstractVector views.\n\nSee also eachrow and eachslice.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExample\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> first(eachcol(a))\n2-element view(::Matrix{Int64}, :, 1) with eltype Int64:\n 1\n 3\n\njulia> collect(eachcol(a))\n2-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:\n [1, 3]\n [2, 4]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.eachindex-Tuple{AbstractArray}","page":"References","title":"Base.eachindex","text":"eachindex(A...)\n\nCreate an iterable object for visiting each index of an AbstractArray A in an efficient manner. For array types that have opted into fast linear indexing (like Array), this is simply the range 1:length(A). For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).\n\nIf you supply more than one AbstractArray argument, eachindex will create an iterable object that is fast for all arguments (a UnitRange if all inputs have fast linear indexing, a CartesianIndices otherwise). If the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception will be thrown.\n\nExamples\n\njulia> A = [1 2; 3 4];\n\njulia> for i in eachindex(A) # linear indexing\n           println(i)\n       end\n1\n2\n3\n4\n\njulia> for i in eachindex(view(A, 1:2, 1:1)) # Cartesian indexing\n           println(i)\n       end\nCartesianIndex(1, 1)\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.eachline","page":"References","title":"Base.eachline","text":"eachline(io::IO=stdin; keep::Bool=false)\neachline(filename::AbstractString; keep::Bool=false)\n\nCreate an iterable EachLine object that will yield each line from an I/O stream or a file. Iteration calls readline on the stream argument repeatedly with keep passed through, determining whether trailing end-of-line characters are retained. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the EachLine object is garbage collected.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\n It has many members.\\n\");\n       end;\n\njulia> for line in eachline(\"my_file.txt\")\n           print(line)\n       end\nJuliaLang is a GitHub organization. It has many members.\n\njulia> rm(\"my_file.txt\");\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.eachmatch-Tuple{Regex, AbstractString}","page":"References","title":"Base.eachmatch","text":"eachmatch(r::Regex, s::AbstractString; overlap::Bool=false)\n\nSearch for all matches of the regular expression r in s and return an iterator over the matches. If overlap is true, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.\n\nExamples\n\njulia> rx = r\"a.a\"\nr\"a.a\"\n\njulia> m = eachmatch(rx, \"a1a2a3a\")\nBase.RegexMatchIterator(r\"a.a\", \"a1a2a3a\", false)\n\njulia> collect(m)\n2-element Vector{RegexMatch}:\n RegexMatch(\"a1a\")\n RegexMatch(\"a3a\")\n\njulia> collect(eachmatch(rx, \"a1a2a3a\", overlap = true))\n3-element Vector{RegexMatch}:\n RegexMatch(\"a1a\")\n RegexMatch(\"a2a\")\n RegexMatch(\"a3a\")\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.eachrow-Tuple{AbstractVecOrMat{T} where T}","page":"References","title":"Base.eachrow","text":"eachrow(A::AbstractVecOrMat)\n\nCreate a generator that iterates over the first dimension of vector or matrix A, returning the rows as AbstractVector views.\n\nSee also eachcol and eachslice.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExample\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> first(eachrow(a))\n2-element view(::Matrix{Int64}, 1, :) with eltype Int64:\n 1\n 2\n\njulia> collect(eachrow(a))\n2-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Int64, Base.Slice{Base.OneTo{Int64}}}, true}}:\n [1, 2]\n [3, 4]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.eachslice-Tuple{AbstractArray}","page":"References","title":"Base.eachslice","text":"eachslice(A::AbstractArray; dims)\n\nCreate a generator that iterates over dimensions dims of A, returning views that select all the data from the other dimensions in A.\n\nOnly a single dimension in dims is currently supported. Equivalent to (view(A,:,:,...,i,:,: ...)) for i in axes(A, dims)), where i is in position dims.\n\nSee also eachrow, eachcol, and selectdim.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExample\n\njulia> M = [1 2 3; 4 5 6; 7 8 9]\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\njulia> first(eachslice(M, dims=1))\n3-element view(::Matrix{Int64}, 1, :) with eltype Int64:\n 1\n 2\n 3\n\njulia> collect(eachslice(M, dims=2))\n3-element Vector{SubArray{Int64, 1, Matrix{Int64}, Tuple{Base.Slice{Base.OneTo{Int64}}, Int64}, true}}:\n [1, 4, 7]\n [2, 5, 8]\n [3, 6, 9]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.elsize-Tuple{AbstractArray}","page":"References","title":"Base.elsize","text":"elsize(type)\n\nCompute the memory stride in bytes between consecutive elements of eltype stored inside the given type, if the array elements are stored densely with a uniform linear stride.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.eltype-Tuple{Type}","page":"References","title":"Base.eltype","text":"eltype(type)\n\nDetermine the type of the elements generated by iterating a collection of the given type. For dictionary types, this will be a Pair{KeyType,ValType}. The definition eltype(x) = eltype(typeof(x)) is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.\n\nExamples\n\njulia> eltype(fill(1f0, (2,2)))\nFloat32\n\njulia> eltype(fill(0x1, (2,2)))\nUInt8\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.empty!-Union{Tuple{Dict{K, V}}, Tuple{V}, Tuple{K}} where {K, V}","page":"References","title":"Base.empty!","text":"empty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String, Int64}()\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.empty-Tuple{AbstractDict}","page":"References","title":"Base.empty","text":"empty(a::AbstractDict, [index_type=keytype(a)], [value_type=valtype(a)])\n\nCreate an empty AbstractDict container which can accept indices of type index_type and values of type value_type. The second and third arguments are optional and default to the input's keytype and valtype, respectively. (If only one of the two types is specified, it is assumed to be the value_type, and the index_type we default to keytype(a)).\n\nCustom AbstractDict subtypes may choose which specific dictionary type is best suited to return for the given index and value types, by specializing on the three-argument signature. The default is to return an empty Dict.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.empty-Tuple{Tuple}","page":"References","title":"Base.empty","text":"empty(x::Tuple)\n\nReturns an empty tuple, ().\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.empty-Union{Tuple{AbstractVector{T}}, Tuple{U}, Tuple{T}, Tuple{AbstractVector{T}, Type{U}}} where {T, U}","page":"References","title":"Base.empty","text":"empty(v::AbstractVector, [eltype])\n\nCreate an empty vector similar to v, optionally changing the eltype.\n\nExamples\n\njulia> empty([1.0, 2.0, 3.0])\nFloat64[]\n\njulia> empty([1.0, 2.0, 3.0], String)\nString[]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.endswith-Tuple{AbstractString, AbstractString}","page":"References","title":"Base.endswith","text":"endswith(s::AbstractString, suffix::AbstractString)\n\nReturn true if s ends with suffix. If suffix is a vector or set of characters, test whether the last character of s belongs to that set.\n\nSee also startswith.\n\nExamples\n\njulia> endswith(\"Sunday\", \"day\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.endswith-Tuple{AbstractString, Regex}","page":"References","title":"Base.endswith","text":"endswith(s::AbstractString, suffix::Regex)\n\nReturn true if s ends with the regex pattern, suffix.\n\nnote: Note\nendswith does not compile the anchoring into the regular expression, but instead passes the anchoring as match_option to PCRE. If compile time is amortized, occursin(r\"...$\", s) is faster than endswith(s, r\"...\").\n\nSee also occursin and startswith.\n\ncompat: Julia 1.2\nThis method requires at least Julia 1.2.\n\nExamples\n\njulia> endswith(\"JuliaLang\", r\"Lang|Roberts\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.endswith-Tuple{Any}","page":"References","title":"Base.endswith","text":"endswith(suffix)\n\nCreate a function that checks whether its argument ends with suffix, i.e. a function equivalent to y -> endswith(y, suffix).\n\nThe returned function is of type Base.Fix2{typeof(endswith)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.5\nThe single argument endswith(suffix) requires at least Julia 1.5.\n\nExamples\n\njulia> endswith_julia = endswith(\"Julia\");\n\njulia> endswith_julia(\"Julia\")\ntrue\n\njulia> endswith_julia(\"JuliaLang\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.eof-Tuple{Base.AbstractPipe}","page":"References","title":"Base.eof","text":"eof(stream) -> Bool\n\nTest whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return false. Therefore it is always safe to read one byte after seeing eof return false. eof will return false as long as buffered data is still available, even if the remote end of a connection is closed.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.eps-Tuple{AbstractFloat}","page":"References","title":"Base.eps","text":"eps(x::AbstractFloat)\n\nReturn the unit in last place (ulp) of x. This is the distance between consecutive representable floating point values at x. In most cases, if the distance on either side of x is different, then the larger of the two is taken, that is\n\neps(x) == max(x-prevfloat(x), nextfloat(x)-x)\n\nThe exceptions to this rule are the smallest and largest finite values (e.g. nextfloat(-Inf) and prevfloat(Inf) for Float64), which round to the smaller of the values.\n\nThe rationale for this behavior is that eps bounds the floating point rounding error. Under the default RoundNearest rounding mode, if y is a real number and x is the nearest floating point number to y, then\n\ny-x leq operatornameeps(x)2\n\nExamples\n\njulia> eps(1.0)\n2.220446049250313e-16\n\njulia> eps(prevfloat(2.0))\n2.220446049250313e-16\n\njulia> eps(2.0)\n4.440892098500626e-16\n\njulia> x = prevfloat(Inf)      # largest finite Float64\n1.7976931348623157e308\n\njulia> x + eps(x)/2            # rounds up\nInf\n\njulia> x + prevfloat(eps(x)/2) # rounds down\n1.7976931348623157e308\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.eps-Tuple{Type{var\"#s832\"} where var\"#s832\"<:AbstractFloat}","page":"References","title":"Base.eps","text":"eps(::Type{T}) where T<:AbstractFloat\neps()\n\nReturn the machine epsilon of the floating point type T (T = Float64 by default). This is defined as the gap between 1 and the next largest value representable by typeof(one(T)), and is equivalent to eps(one(T)).  (Since eps(T) is a bound on the relative error of T, it is a \"dimensionless\" quantity like one.)\n\nExamples\n\njulia> eps()\n2.220446049250313e-16\n\njulia> eps(Float32)\n1.1920929f-7\n\njulia> 1.0 + eps()\n1.0000000000000002\n\njulia> 1.0 + eps()/2\n1.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.error-Tuple{AbstractString}","page":"References","title":"Base.error","text":"error(message::AbstractString)\n\nRaise an ErrorException with the given message.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.error-Union{Tuple{Vararg{Any, N}}, Tuple{N}} where N","page":"References","title":"Base.error","text":"error(msg...)\n\nRaise an ErrorException with the given message.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.esc-Tuple{Any}","page":"References","title":"Base.esc","text":"esc(e)\n\nOnly valid in the context of an Expr returned from a macro. Prevents the macro hygiene pass from turning embedded variables into gensym variables. See the Macros section of the Metaprogramming chapter of the manual for more details and examples.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.escape_microsoft_c_args-Tuple{IO, Vararg{AbstractString, N} where N}","page":"References","title":"Base.escape_microsoft_c_args","text":"escape_microsoft_c_args(args::Union{Cmd,AbstractString...})\nescape_microsoft_c_args(io::IO, args::Union{Cmd,AbstractString...})\n\nConvert a collection of string arguments into a string that can be passed to many Windows command-line applications.\n\nMicrosoft Windows passes the entire command line as a single string to the application (unlike POSIX systems, where the shell splits the command line into a list of arguments). Many Windows API applications (including julia.exe), use the conventions of the Microsoft C/C++ runtime to split that command line into a list of strings.\n\nThis function implements an inverse for a parser compatible with these rules. It joins command-line arguments to be passed to a Windows C/C++/Julia application into a command line, escaping or quoting the meta characters space, TAB, double quote and backslash where needed.\n\nSee also: shell_escape_wincmd, escape_raw_string\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.escape_raw_string-Tuple{Any, AbstractString}","page":"References","title":"Base.escape_raw_string","text":"escape_raw_string(s::AbstractString)\nescape_raw_string(io, s::AbstractString)\n\nEscape a string in the manner used for parsing raw string literals. For each double-quote (\") character in input string s, this function counts the number n of preceeding backslash (\\) characters, and then increases there the number of backslashes from n to 2n+1 (even for n = 0). It also doubles a sequence of backslashes at the end of the string.\n\nThis escaping convention is used in raw strings and other non-standard string literals. (It also happens to be the escaping convention expected by the Microsoft C/C++ compiler runtime when it parses a command-line string into the argv[] array.)\n\nSee also: escape_string\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.escape_string","page":"References","title":"Base.escape_string","text":"escape_string(str::AbstractString[, esc])::AbstractString\nescape_string(io, str::AbstractString[, esc::])::Nothing\n\nGeneral escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to io.\n\nBackslashes (\\) are escaped with a double-backslash (\"\\\\\"). Non-printable characters are escaped either with their standard C escape codes, \"\\0\" for NUL (if unambiguous), unicode code point (\"\\u\" prefix) or hex (\"\\x\" prefix).\n\nThe optional esc argument specifies any additional characters that should also be escaped by a prepending backslash (\" is also escaped by default in the first form).\n\nExamples\n\njulia> escape_string(\"aaa\\nbbb\")\n\"aaa\\\\nbbb\"\n\njulia> escape_string(\"\\xfe\\xff\") # invalid utf-8\n\"\\\\xfe\\\\xff\"\n\njulia> escape_string(string('\\u2135','\\0')) # unambiguous\n\"ℵ\\\\0\"\n\njulia> escape_string(string('\\u2135','\\0','0')) # \\0 would be ambiguous\n\"ℵ\\\\x000\"\n\nSee also\n\nunescape_string for the reverse operation.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.evalfile","page":"References","title":"Base.evalfile","text":"evalfile(path::AbstractString, args::Vector{String}=String[])\n\nLoad the file using include, evaluate all expressions, and return the value of the last one.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.exit-Tuple{Any}","page":"References","title":"Base.exit","text":"exit(code=0)\n\nStop the program with an exit code. The default exit code is zero, indicating that the program completed successfully. In an interactive session, exit() can be called with the keyboard shortcut ^D.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.exit_on_sigint-Tuple{Bool}","page":"References","title":"Base.exit_on_sigint","text":"exit_on_sigint(on::Bool)\n\nSet exit_on_sigint flag of the julia runtime.  If false, Ctrl-C (SIGINT) is capturable as InterruptException in try block. This is the default behavior in REPL, any code run via -e and -E and in Julia script run with -i option.\n\nIf true, InterruptException is not thrown by Ctrl-C.  Running code upon such event requires atexit.  This is the default behavior in Julia script run without -i option.\n\ncompat: Julia 1.5\nFunction exit_on_sigint requires at least Julia 1.5.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.extrema-Tuple{AbstractArray}","page":"References","title":"Base.extrema","text":"extrema(A::AbstractArray; dims) -> Array{Tuple}\n\nCompute the minimum and maximum elements of an array over the given dimensions.\n\nExamples\n\njulia> A = reshape(Vector(1:2:16), (2,2,2))\n2×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  5\n 3  7\n\n[:, :, 2] =\n  9  13\n 11  15\n\njulia> extrema(A, dims = (1,2))\n1×1×2 Array{Tuple{Int64, Int64}, 3}:\n[:, :, 1] =\n (1, 7)\n\n[:, :, 2] =\n (9, 15)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.extrema-Tuple{Any, AbstractArray}","page":"References","title":"Base.extrema","text":"extrema(f, A::AbstractArray; dims) -> Array{Tuple}\n\nCompute the minimum and maximum of f applied to each element in the given dimensions of A.\n\ncompat: Julia 1.2\nThis method requires Julia 1.2 or later.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.extrema-Tuple{Any, Any}","page":"References","title":"Base.extrema","text":"extrema(f, itr) -> Tuple\n\nCompute both the minimum and maximum of f applied to each element in itr and return them as a 2-tuple. Only one pass is made over itr.\n\ncompat: Julia 1.2\nThis method requires Julia 1.2 or later.\n\nExamples\n\njulia> extrema(sin, 0:π)\n(0.0, 0.9092974268256817)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.extrema-Tuple{Any}","page":"References","title":"Base.extrema","text":"extrema(itr) -> Tuple\n\nCompute both the minimum and maximum element in a single pass, and return them as a 2-tuple.\n\nExamples\n\njulia> extrema(2:10)\n(2, 10)\n\njulia> extrema([9,pi,4.5])\n(3.141592653589793, 9.0)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.factorial-Tuple{Integer}","page":"References","title":"Base.factorial","text":"factorial(n::Integer)\n\nFactorial of n. If n is an Integer, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if n is not small, but you can use factorial(big(n)) to compute the result exactly in arbitrary precision.\n\nExamples\n\njulia> factorial(6)\n720\n\njulia> factorial(21)\nERROR: OverflowError: 21 is too large to look up in the table; consider using `factorial(big(21))` instead\nStacktrace:\n[...]\n\njulia> factorial(big(21))\n51090942171709440000\n\nSee also\n\nbinomial\n\nExternal links\n\nFactorial on Wikipedia.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.falses-Tuple{Vararg{Union{Integer, AbstractUnitRange}, N} where N}","page":"References","title":"Base.falses","text":"falses(dims)\n\nCreate a BitArray with all values set to false.\n\nExamples\n\njulia> falses(2,3)\n2×3 BitMatrix:\n 0  0  0\n 0  0  0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fd-Tuple{IOStream}","page":"References","title":"Base.fd","text":"fd(stream)\n\nReturn the file descriptor backing the stream or file. Note that this function only applies to synchronous File's and IOStream's not to any of the asynchronous streams.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fdio","page":"References","title":"Base.fdio","text":"fdio([name::AbstractString, ]fd::Integer[, own::Bool=false]) -> IOStream\n\nCreate an IOStream object from an integer file descriptor. If own is true, closing this object will close the underlying descriptor. By default, an IOStream is closed when it is garbage collected. name allows you to associate the descriptor with a named file.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.fetch-Tuple{Channel}","page":"References","title":"Base.fetch","text":"fetch(c::Channel)\n\nWait for and get the first available item from the channel. Does not remove the item. fetch is unsupported on an unbuffered (0-size) channel.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fetch-Tuple{Task}","page":"References","title":"Base.fetch","text":"fetch(t::Task)\n\nWait for a Task to finish, then return its result value. If the task fails with an exception, a TaskFailedException (which wraps the failed task) is thrown.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fieldcount-Tuple{Any}","page":"References","title":"Base.fieldcount","text":"fieldcount(t::Type)\n\nGet the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fieldindex","page":"References","title":"Base.fieldindex","text":"Base.fieldindex(T, name::Symbol, err:Bool=true)\n\nGet the index of a named field, throwing an error if the field does not exist (when err==true) or returning 0 (when err==false).\n\nExamples\n\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> Base.fieldindex(Foo, :z)\nERROR: type Foo has no field z\nStacktrace:\n[...]\n\njulia> Base.fieldindex(Foo, :z, false)\n0\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.fieldname-Tuple{DataType, Integer}","page":"References","title":"Base.fieldname","text":"fieldname(x::DataType, i::Integer)\n\nGet the name of field i of a DataType.\n\nExamples\n\njulia> fieldname(Rational, 1)\n:num\n\njulia> fieldname(Rational, 2)\n:den\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fieldnames-Tuple{DataType}","page":"References","title":"Base.fieldnames","text":"fieldnames(x::DataType)\n\nGet a tuple with the names of the fields of a DataType.\n\nExamples\n\njulia> fieldnames(Rational)\n(:num, :den)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fieldoffset-Tuple{DataType, Integer}","page":"References","title":"Base.fieldoffset","text":"fieldoffset(type, i)\n\nThe byte offset of field i of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:\n\njulia> structinfo(T) = [(fieldoffset(T,i), fieldname(T,i), fieldtype(T,i)) for i = 1:fieldcount(T)];\n\njulia> structinfo(Base.Filesystem.StatStruct)\n12-element Vector{Tuple{UInt64, Symbol, DataType}}:\n (0x0000000000000000, :device, UInt64)\n (0x0000000000000008, :inode, UInt64)\n (0x0000000000000010, :mode, UInt64)\n (0x0000000000000018, :nlink, Int64)\n (0x0000000000000020, :uid, UInt64)\n (0x0000000000000028, :gid, UInt64)\n (0x0000000000000030, :rdev, UInt64)\n (0x0000000000000038, :size, Int64)\n (0x0000000000000040, :blksize, Int64)\n (0x0000000000000048, :blocks, Int64)\n (0x0000000000000050, :mtime, Float64)\n (0x0000000000000058, :ctime, Float64)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fieldtypes-Tuple{Type}","page":"References","title":"Base.fieldtypes","text":"fieldtypes(T::Type)\n\nThe declared types of all fields in a composite DataType T as a tuple.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\nExamples\n\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> fieldtypes(Foo)\n(Int64, String)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fill","page":"References","title":"Base.fill","text":"fill(x, dims::Tuple)\nfill(x, dims...)\n\nCreate an array filled with the value x. For example, fill(1.0, (5,5)) returns a 5×5 array of floats, with each element initialized to 1.0.\n\ndims may be specified as either a tuple or a sequence of arguments. For example, the common idiom fill(x) creates a zero-dimensional array containing the single value x.\n\nExamples\n\njulia> fill(1.0, (2,3))\n2×3 Matrix{Float64}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> fill(42)\n0-dimensional Array{Int64, 0}:\n42\n\nIf x is an object reference, all elements will refer to the same object:\n\njulia> A = fill(zeros(2), 2);\n\njulia> A[1][1] = 42; # modifies both A[1][1] and A[2][1]\n\njulia> A\n2-element Vector{Vector{Float64}}:\n [42.0, 0.0]\n [42.0, 0.0]\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.fill!-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, Any}} where T","page":"References","title":"Base.fill!","text":"fill!(A, x)\n\nFill array A with the value x. If x is an object reference, all elements will refer to the same object. fill!(A, Foo()) will return A filled with the result of evaluating Foo() once.\n\nExamples\n\njulia> A = zeros(2,3)\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> fill!(A, 2.)\n2×3 Matrix{Float64}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\njulia> a = [1, 1, 1]; A = fill!(Vector{Vector{Int}}(undef, 3), a); a[1] = 2; A\n3-element Vector{Vector{Int64}}:\n [2, 1, 1]\n [2, 1, 1]\n [2, 1, 1]\n\njulia> x = 0; f() = (global x += 1; x); fill!(Vector{Int}(undef, 3), f())\n3-element Vector{Int64}:\n 1\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.filter!-Tuple{Any, AbstractDict}","page":"References","title":"Base.filter!","text":"filter!(f, d::AbstractDict)\n\nUpdate d, removing elements for which f is false. The function f is passed key=>value pairs.\n\nExample\n\njulia> d = Dict(1=>\"a\", 2=>\"b\", 3=>\"c\")\nDict{Int64, String} with 3 entries:\n  2 => \"b\"\n  3 => \"c\"\n  1 => \"a\"\n\njulia> filter!(p->isodd(p.first), d)\nDict{Int64, String} with 2 entries:\n  3 => \"c\"\n  1 => \"a\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.filter!-Tuple{Any, AbstractVector{T} where T}","page":"References","title":"Base.filter!","text":"filter!(f, a)\n\nUpdate collection a, removing elements for which f is false. The function f is passed one argument.\n\nExamples\n\njulia> filter!(isodd, Vector(1:10))\n5-element Vector{Int64}:\n 1\n 3\n 5\n 7\n 9\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.filter-Tuple{Any, AbstractDict}","page":"References","title":"Base.filter","text":"filter(f, d::AbstractDict)\n\nReturn a copy of d, removing elements for which f is false. The function f is passed key=>value pairs.\n\nExamples\n\njulia> d = Dict(1=>\"a\", 2=>\"b\")\nDict{Int64, String} with 2 entries:\n  2 => \"b\"\n  1 => \"a\"\n\njulia> filter(p->isodd(p.first), d)\nDict{Int64, String} with 1 entry:\n  1 => \"a\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.filter-Tuple{Any, Base.SkipMissing{var\"#s832\"} where var\"#s832\"<:AbstractArray}","page":"References","title":"Base.filter","text":"filter(f, itr::SkipMissing{<:AbstractArray})\n\nReturn a vector similar to the array wrapped by the given SkipMissing iterator but with all missing elements and those for which f returns false removed.\n\ncompat: Julia 1.2\nThis method requires Julia 1.2 or later.\n\nExamples\n\njulia> x = [1 2; missing 4]\n2×2 Matrix{Union{Missing, Int64}}:\n 1         2\n  missing  4\n\njulia> filter(isodd, skipmissing(x))\n1-element Vector{Int64}:\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.filter-Union{Tuple{N}, Tuple{T}, Tuple{Any, Array{T, N}}} where {T, N}","page":"References","title":"Base.filter","text":"filter(f, a)\n\nReturn a copy of collection a, removing elements for which f is false. The function f is passed one argument.\n\ncompat: Julia 1.4\nSupport for a as a tuple requires at least Julia 1.4.\n\nExamples\n\njulia> a = 1:10\n1:10\n\njulia> filter(isodd, a)\n5-element Vector{Int64}:\n 1\n 3\n 5\n 7\n 9\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.finalize-Tuple{Any}","page":"References","title":"Base.finalize","text":"finalize(x)\n\nImmediately run finalizers registered for object x.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.finalizer-Tuple{Any, Any}","page":"References","title":"Base.finalizer","text":"finalizer(f, x)\n\nRegister a function f(x) to be called when there are no program-accessible references to x, and return x. The type of x must be a mutable struct, otherwise the behavior of this function is unpredictable.\n\nf must not cause a task switch, which excludes most I/O operations such as println. Using the @async macro (to defer context switching to outside of the finalizer) or ccall to directly invoke IO functions in C may be helpful for debugging purposes.\n\nExamples\n\nfinalizer(my_mutable_struct) do x\n    @async println(\"Finalizing $x.\")\nend\n\nfinalizer(my_mutable_struct) do x\n    ccall(:jl_safe_printf, Cvoid, (Cstring, Cstring), \"Finalizing %s.\", repr(x))\nend\n\nA finalizer may be registered at object construction. In the following example note that we implicitly rely on the finalizer returning the newly created mutable struct x.\n\nExample\n\nmutable struct MyMutableStruct\n    bar\n    function MyMutableStruct(bar)\n        x = new(bar)\n        f(t) = @async println(\"Finalizing $t.\")\n        finalizer(f, x)\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findall-Tuple{Any}","page":"References","title":"Base.findall","text":"findall(A)\n\nReturn a vector I of the true indices or keys of A. If there are no such elements of A, return an empty array. To search for other kinds of values, pass a predicate as the first argument.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [true, false, false, true]\n4-element Vector{Bool}:\n 1\n 0\n 0\n 1\n\njulia> findall(A)\n2-element Vector{Int64}:\n 1\n 4\n\njulia> A = [true false; false true]\n2×2 Matrix{Bool}:\n 1  0\n 0  1\n\njulia> findall(A)\n2-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 2)\n\njulia> findall(falses(3))\nInt64[]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findall-Tuple{Function, Any}","page":"References","title":"Base.findall","text":"findall(f::Function, A)\n\nReturn a vector I of the indices or keys of A where f(A[I]) returns true. If there are no such elements of A, return an empty array.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> x = [1, 3, 4]\n3-element Vector{Int64}:\n 1\n 3\n 4\n\njulia> findall(isodd, x)\n2-element Vector{Int64}:\n 1\n 2\n\njulia> A = [1 2 0; 3 4 0]\n2×3 Matrix{Int64}:\n 1  2  0\n 3  4  0\njulia> findall(isodd, A)\n2-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n\njulia> findall(!iszero, A)\n4-element Vector{CartesianIndex{2}}:\n CartesianIndex(1, 1)\n CartesianIndex(2, 1)\n CartesianIndex(1, 2)\n CartesianIndex(2, 2)\n\njulia> d = Dict(:A => 10, :B => -1, :C => 0)\nDict{Symbol, Int64} with 3 entries:\n  :A => 10\n  :B => -1\n  :C => 0\n\njulia> findall(x -> x >= 0, d)\n2-element Vector{Symbol}:\n :A\n :C\n\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findall-Tuple{Union{AbstractPattern, AbstractString}, AbstractString}","page":"References","title":"Base.findall","text":"findall(\n    pattern::Union{AbstractString,AbstractPattern},\n    string::AbstractString;\n    overlap::Bool = false,\n)\n\nReturn a Vector{UnitRange{Int}} of all the matches for pattern in string. Each element of the returned vector is a range of indices where the matching sequence is found, like the return value of findnext.\n\nIf overlap=true, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.\n\nExamples\n\njulia> findall(\"a\", \"apple\")\n1-element Vector{UnitRange{Int64}}:\n 1:1\n\njulia> findall(\"nana\", \"banana\")\n1-element Vector{UnitRange{Int64}}:\n 3:6\n\njulia> findall(\"a\", \"banana\")\n3-element Vector{UnitRange{Int64}}:\n 2:2\n 4:4\n 6:6\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findfirst-Tuple{AbstractChar, AbstractString}","page":"References","title":"Base.findfirst","text":"findfirst(ch::AbstractChar, string::AbstractString)\n\nFind the first occurrence of character ch in string.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\nExamples\n\njulia> findfirst('a', \"happy\")\n2\n\njulia> findfirst('z', \"happy\") === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findfirst-Tuple{AbstractString, AbstractString}","page":"References","title":"Base.findfirst","text":"findfirst(pattern::AbstractString, string::AbstractString)\nfindfirst(pattern::AbstractPattern, string::String)\n\nFind the first occurrence of pattern in string. Equivalent to findnext(pattern, string, firstindex(s)).\n\nExamples\n\njulia> findfirst(\"z\", \"Hello to the world\") # returns nothing, but not printed in the REPL\n\njulia> findfirst(\"Julia\", \"JuliaLang\")\n1:5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findfirst-Tuple{AbstractVector{var\"#s832\"} where var\"#s832\"<:Union{Int8, UInt8}, AbstractVector{var\"#s831\"} where var\"#s831\"<:Union{Int8, UInt8}}","page":"References","title":"Base.findfirst","text":"findfirst(pattern::AbstractVector{<:Union{Int8,UInt8}},\n          A::AbstractVector{<:Union{Int8,UInt8}})\n\nFind the first occurrence of sequence pattern in vector A.\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> findfirst([0x52, 0x62], [0x40, 0x52, 0x62, 0x63])\n2:3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findfirst-Tuple{Any}","page":"References","title":"Base.findfirst","text":"findfirst(A)\n\nReturn the index or key of the first true value in A. Return nothing if no such value is found. To search for other kinds of values, pass a predicate as the first argument.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [false, false, true, false]\n4-element Vector{Bool}:\n 0\n 0\n 1\n 0\n\njulia> findfirst(A)\n3\n\njulia> findfirst(falses(3)) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true false]\n2×2 Matrix{Bool}:\n 0  0\n 1  0\n\njulia> findfirst(A)\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findfirst-Tuple{Function, Any}","page":"References","title":"Base.findfirst","text":"findfirst(predicate::Function, A)\n\nReturn the index or key of the first element of A for which predicate returns true. Return nothing if there is no such element.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [1, 4, 2, 2]\n4-element Vector{Int64}:\n 1\n 4\n 2\n 2\n\njulia> findfirst(iseven, A)\n2\n\njulia> findfirst(x -> x>10, A) # returns nothing, but not printed in the REPL\n\njulia> findfirst(isequal(4), A)\n2\n\njulia> A = [1 4; 2 2]\n2×2 Matrix{Int64}:\n 1  4\n 2  2\n\njulia> findfirst(iseven, A)\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findlast-Tuple{AbstractChar, AbstractString}","page":"References","title":"Base.findlast","text":"findlast(ch::AbstractChar, string::AbstractString)\n\nFind the last occurrence of character ch in string.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\nExamples\n\njulia> findlast('p', \"happy\")\n4\n\njulia> findlast('z', \"happy\") === nothing\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findlast-Tuple{AbstractString, AbstractString}","page":"References","title":"Base.findlast","text":"findlast(pattern::AbstractString, string::AbstractString)\n\nFind the last occurrence of pattern in string. Equivalent to findprev(pattern, string, lastindex(string)).\n\nExamples\n\njulia> findlast(\"o\", \"Hello to the world\")\n15:15\n\njulia> findfirst(\"Julia\", \"JuliaLang\")\n1:5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findlast-Tuple{AbstractVector{var\"#s832\"} where var\"#s832\"<:Union{Int8, UInt8}, AbstractVector{var\"#s831\"} where var\"#s831\"<:Union{Int8, UInt8}}","page":"References","title":"Base.findlast","text":"findlast(pattern::AbstractVector{<:Union{Int8,UInt8}},\n         A::AbstractVector{<:Union{Int8,UInt8}})\n\nFind the last occurrence of pattern in array A. Equivalent to findprev(pattern, A, lastindex(A)).\n\nExamples\n\njulia> findlast([0x52, 0x62], [0x52, 0x62, 0x52, 0x62])\n3:4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findlast-Tuple{Any}","page":"References","title":"Base.findlast","text":"findlast(A)\n\nReturn the index or key of the last true value in A. Return nothing if there is no true value in A.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [true, false, true, false]\n4-element Vector{Bool}:\n 1\n 0\n 1\n 0\n\njulia> findlast(A)\n3\n\njulia> A = falses(2,2);\n\njulia> findlast(A) # returns nothing, but not printed in the REPL\n\njulia> A = [true false; true false]\n2×2 Matrix{Bool}:\n 1  0\n 1  0\n\njulia> findlast(A)\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findlast-Tuple{Function, Any}","page":"References","title":"Base.findlast","text":"findlast(predicate::Function, A)\n\nReturn the index or key of the last element of A for which predicate returns true. Return nothing if there is no such element.\n\nIndices or keys are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [1, 2, 3, 4]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> findlast(isodd, A)\n3\n\njulia> findlast(x -> x > 5, A) # returns nothing, but not printed in the REPL\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> findlast(isodd, A)\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findmax!-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"References","title":"Base.findmax!","text":"findmax!(rval, rind, A) -> (maxval, index)\n\nFind the maximum of A and the corresponding linear index along singleton dimensions of rval and rind, and store the results in rval and rind. NaN is treated as greater than all other values.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findmax-Tuple{AbstractArray}","page":"References","title":"Base.findmax","text":"findmax(A; dims) -> (maxval, index)\n\nFor an array input, returns the value and index of the maximum over the given dimensions. NaN is treated as greater than all other values.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> findmax(A, dims=1)\n([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])\n\njulia> findmax(A, dims=2)\n([2.0; 4.0], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2)])\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findmax-Tuple{Any}","page":"References","title":"Base.findmax","text":"findmax(itr) -> (x, index)\n\nReturn the maximum element of the collection itr and its index or key. If there are multiple maximal elements, then the first one will be returned. If any data element is NaN, this element is returned. The result is in line with max.\n\nThe collection must not be empty.\n\nExamples\n\njulia> findmax([8,0.1,-9,pi])\n(8.0, 1)\n\njulia> findmax([1,7,7,6])\n(7, 2)\n\njulia> findmax([1,7,7,NaN])\n(NaN, 4)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findmin!-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"References","title":"Base.findmin!","text":"findmin!(rval, rind, A) -> (minval, index)\n\nFind the minimum of A and the corresponding linear index along singleton dimensions of rval and rind, and store the results in rval and rind. NaN is treated as less than all other values.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findmin-Tuple{AbstractArray}","page":"References","title":"Base.findmin","text":"findmin(A; dims) -> (minval, index)\n\nFor an array input, returns the value and index of the minimum over the given dimensions. NaN is treated as less than all other values.\n\nExamples\n\njulia> A = [1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> findmin(A, dims=1)\n([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])\n\njulia> findmin(A, dims=2)\n([1.0; 3.0], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1)])\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findmin-Tuple{Any}","page":"References","title":"Base.findmin","text":"findmin(itr) -> (x, index)\n\nReturn the minimum element of the collection itr and its index or key. If there are multiple minimal elements, then the first one will be returned. If any data element is NaN, this element is returned. The result is in line with min.\n\nThe collection must not be empty.\n\nExamples\n\njulia> findmin([8,0.1,-9,pi])\n(-9.0, 3)\n\njulia> findmin([7,1,1,6])\n(1, 2)\n\njulia> findmin([7,1,1,NaN])\n(NaN, 4)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findnext-Tuple{AbstractChar, AbstractString, Integer}","page":"References","title":"Base.findnext","text":"findnext(ch::AbstractChar, string::AbstractString, start::Integer)\n\nFind the next occurrence of character ch in string starting at position start.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\nExamples\n\njulia> findnext('z', \"Hello to the world\", 1) === nothing\ntrue\n\njulia> findnext('o', \"Hello to the world\", 6)\n8\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findnext-Tuple{AbstractString, AbstractString, Integer}","page":"References","title":"Base.findnext","text":"findnext(pattern::AbstractString, string::AbstractString, start::Integer)\nfindnext(pattern::AbstractPattern, string::String, start::Integer)\n\nFind the next occurrence of pattern in string starting at position start. pattern can be either a string, or a regular expression, in which case string must be of type String.\n\nThe return value is a range of indices where the matching sequence is found, such that s[findnext(x, s, i)] == x:\n\nfindnext(\"substring\", string, i) == start:stop such that string[start:stop] == \"substring\" and i <= start, or nothing if unmatched.\n\nExamples\n\njulia> findnext(\"z\", \"Hello to the world\", 1) === nothing\ntrue\n\njulia> findnext(\"o\", \"Hello to the world\", 6)\n8:8\n\njulia> findnext(\"Lang\", \"JuliaLang\", 2)\n6:9\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findnext-Tuple{AbstractVector{var\"#s832\"} where var\"#s832\"<:Union{Int8, UInt8}, AbstractVector{var\"#s831\"} where var\"#s831\"<:Union{Int8, UInt8}, Integer}","page":"References","title":"Base.findnext","text":"findnext(pattern::AbstractVector{<:Union{Int8,UInt8}},\n         A::AbstractVector{<:Union{Int8,UInt8}},\n         start::Integer)\n\nFind the next occurrence of the sequence pattern in vector A starting at position start.\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> findnext([0x52, 0x62], [0x52, 0x62, 0x72], 3) === nothing\ntrue\n\njulia> findnext([0x52, 0x62], [0x40, 0x52, 0x62, 0x52, 0x62], 3)\n4:5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findnext-Tuple{Any, Any}","page":"References","title":"Base.findnext","text":"findnext(A, i)\n\nFind the next index after or including i of a true element of A, or nothing if not found.\n\nIndices are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [false, false, true, false]\n4-element Vector{Bool}:\n 0\n 0\n 1\n 0\n\njulia> findnext(A, 1)\n3\n\njulia> findnext(A, 4) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true false]\n2×2 Matrix{Bool}:\n 0  0\n 1  0\n\njulia> findnext(A, CartesianIndex(1, 1))\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findnext-Tuple{Function, Any, Any}","page":"References","title":"Base.findnext","text":"findnext(predicate::Function, A, i)\n\nFind the next index after or including i of an element of A for which predicate returns true, or nothing if not found.\n\nIndices are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [1, 4, 2, 2];\n\njulia> findnext(isodd, A, 1)\n1\n\njulia> findnext(isodd, A, 2) # returns nothing, but not printed in the REPL\n\njulia> A = [1 4; 2 2];\n\njulia> findnext(isodd, A, CartesianIndex(1, 1))\nCartesianIndex(1, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findprev-Tuple{AbstractChar, AbstractString, Integer}","page":"References","title":"Base.findprev","text":"findprev(ch::AbstractChar, string::AbstractString, start::Integer)\n\nFind the previous occurrence of character ch in string starting at position start.\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\nExamples\n\njulia> findprev('z', \"Hello to the world\", 18) === nothing\ntrue\n\njulia> findprev('o', \"Hello to the world\", 18)\n15\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findprev-Tuple{AbstractString, AbstractString, Integer}","page":"References","title":"Base.findprev","text":"findprev(pattern::AbstractString, string::AbstractString, start::Integer)\n\nFind the previous occurrence of pattern in string starting at position start.\n\nThe return value is a range of indices where the matching sequence is found, such that s[findprev(x, s, i)] == x:\n\nfindprev(\"substring\", string, i) == start:stop such that string[start:stop] == \"substring\" and stop <= i, or nothing if unmatched.\n\nExamples\n\njulia> findprev(\"z\", \"Hello to the world\", 18) === nothing\ntrue\n\njulia> findprev(\"o\", \"Hello to the world\", 18)\n15:15\n\njulia> findprev(\"Julia\", \"JuliaLang\", 6)\n1:5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findprev-Tuple{AbstractVector{var\"#s832\"} where var\"#s832\"<:Union{Int8, UInt8}, AbstractVector{var\"#s831\"} where var\"#s831\"<:Union{Int8, UInt8}, Integer}","page":"References","title":"Base.findprev","text":"findprev(pattern::AbstractVector{<:Union{Int8,UInt8}},\n         A::AbstractVector{<:Union{Int8,UInt8}},\n         start::Integer)\n\nFind the previous occurrence of the sequence pattern in vector A starting at position start.\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> findprev([0x52, 0x62], [0x40, 0x52, 0x62, 0x52, 0x62], 3)\n2:3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findprev-Tuple{Any, Any}","page":"References","title":"Base.findprev","text":"findprev(A, i)\n\nFind the previous index before or including i of a true element of A, or nothing if not found.\n\nIndices are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [false, false, true, true]\n4-element Vector{Bool}:\n 0\n 0\n 1\n 1\n\njulia> findprev(A, 3)\n3\n\njulia> findprev(A, 1) # returns nothing, but not printed in the REPL\n\njulia> A = [false false; true true]\n2×2 Matrix{Bool}:\n 0  0\n 1  1\n\njulia> findprev(A, CartesianIndex(2, 1))\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.findprev-Tuple{Function, Any, Any}","page":"References","title":"Base.findprev","text":"findprev(predicate::Function, A, i)\n\nFind the previous index before or including i of an element of A for which predicate returns true, or nothing if not found.\n\nIndices are of the same type as those returned by keys(A) and pairs(A).\n\nExamples\n\njulia> A = [4, 6, 1, 2]\n4-element Vector{Int64}:\n 4\n 6\n 1\n 2\n\njulia> findprev(isodd, A, 1) # returns nothing, but not printed in the REPL\n\njulia> findprev(isodd, A, 3)\n3\n\njulia> A = [4 6; 1 2]\n2×2 Matrix{Int64}:\n 4  6\n 1  2\n\njulia> findprev(isodd, A, CartesianIndex(1, 2))\nCartesianIndex(2, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.first-Tuple{AbstractString, Integer}","page":"References","title":"Base.first","text":"first(s::AbstractString, n::Integer)\n\nGet a string consisting of the first n characters of s.\n\nExamples\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 1)\n\"∀\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 3)\n\"∀ϵ≠\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.first-Tuple{Any, Integer}","page":"References","title":"Base.first","text":"first(itr, n::Integer)\n\nGet the first n elements of the iterable collection itr, or fewer elements if v is not long enough.\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> first([\"foo\", \"bar\", \"qux\"], 2)\n2-element Vector{String}:\n \"foo\"\n \"bar\"\n\njulia> first(1:6, 10)\n1:6\n\njulia> first(Bool[], 1)\nBool[]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.first-Tuple{Any}","page":"References","title":"Base.first","text":"first(coll)\n\nGet the first element of an iterable collection. Return the start point of an AbstractRange even if it is empty.\n\nExamples\n\njulia> first(2:2:10)\n2\n\njulia> first([1; 2; 3; 4])\n1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.firstindex-Tuple{AbstractArray}","page":"References","title":"Base.firstindex","text":"firstindex(collection) -> Integer\nfirstindex(collection, d) -> Integer\n\nReturn the first index of collection. If d is given, return the first index of collection along dimension d.\n\nExamples\n\njulia> firstindex([1,2,4])\n1\n\njulia> firstindex(rand(3,4,5), 2)\n1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fld-Tuple{Any, Any}","page":"References","title":"Base.fld","text":"fld(x, y)\n\nLargest integer less than or equal to x/y. Equivalent to div(x, y, RoundDown).\n\nSee also: div\n\nExamples\n\njulia> fld(7.3,5.5)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fld1-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"References","title":"Base.fld1","text":"fld1(x, y)\n\nFlooring division, returning a value consistent with mod1(x,y)\n\nSee also: mod1, fldmod1.\n\nExamples\n\njulia> x = 15; y = 4;\n\njulia> fld1(x, y)\n4\n\njulia> x == fld(x, y) * y + mod(x, y)\ntrue\n\njulia> x == (fld1(x, y) - 1) * y + mod1(x, y)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fldmod-Tuple{Any, Any}","page":"References","title":"Base.fldmod","text":"fldmod(x, y)\n\nThe floored quotient and modulus after division. A convenience wrapper for divrem(x, y, RoundDown). Equivalent to (fld(x,y), mod(x,y)).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fldmod1-Tuple{Any, Any}","page":"References","title":"Base.fldmod1","text":"fldmod1(x, y)\n\nReturn (fld1(x,y), mod1(x,y)).\n\nSee also: fld1, mod1.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.flipsign-Tuple{Real, Real}","page":"References","title":"Base.flipsign","text":"flipsign(x, y)\n\nReturn x with its sign flipped if y is negative. For example abs(x) = flipsign(x,x).\n\nExamples\n\njulia> flipsign(5, 3)\n5\n\njulia> flipsign(5, -3)\n-5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.float-Tuple{Any}","page":"References","title":"Base.float","text":"float(x)\n\nConvert a number or array to a floating point data type.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.float-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"References","title":"Base.float","text":"float(T::Type)\n\nReturn an appropriate type to represent a value of type T as a floating point value. Equivalent to typeof(float(zero(T))).\n\nExamples\n\njulia> float(Complex{Int})\nComplexF64 (alias for Complex{Float64})\n\njulia> float(Int)\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.floatmax-Tuple{T} where T<:AbstractFloat","page":"References","title":"Base.floatmax","text":"floatmax(T = Float64)\n\nReturn the largest finite number representable by the floating-point type T.\n\nExamples\n\njulia> floatmax(Float16)\nFloat16(6.55e4)\n\njulia> floatmax(Float32)\n3.4028235f38\n\njulia> floatmax()\n1.7976931348623157e308\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.floatmin-Tuple{T} where T<:AbstractFloat","page":"References","title":"Base.floatmin","text":"floatmin(T = Float64)\n\nReturn the smallest positive normal number representable by the floating-point type T.\n\nExamples\n\njulia> floatmin(Float16)\nFloat16(6.104e-5)\n\njulia> floatmin(Float32)\n1.1754944f-38\n\njulia> floatmin()\n2.2250738585072014e-308\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.floor","page":"References","title":"Base.floor","text":"floor([T,] x)\nfloor(x; digits::Integer= [, base = 10])\nfloor(x; sigdigits::Integer= [, base = 10])\n\nfloor(x) returns the nearest integral value of the same type as x that is less than or equal to x.\n\nfloor(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\n\ndigits, sigdigits and base work as for round.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.flush-Tuple{IO}","page":"References","title":"Base.flush","text":"flush(stream)\n\nCommit all currently buffered writes to the given stream.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fma","page":"References","title":"Base.fma","text":"fma(x, y, z)\n\nComputes x*y+z without rounding the intermediate result x*y. On some systems this is significantly more expensive than x*y+z. fma is used to improve accuracy in certain algorithms. See muladd.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.foldl-Tuple{Any, Any}","page":"References","title":"Base.foldl","text":"foldl(op, itr; [init])\n\nLike reduce, but with guaranteed left associativity. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\n\nExamples\n\njulia> foldl(=>, 1:4)\n((1 => 2) => 3) => 4\n\njulia> foldl(=>, 1:4; init=0)\n(((0 => 1) => 2) => 3) => 4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.foldr-Tuple{Any, Any}","page":"References","title":"Base.foldr","text":"foldr(op, itr; [init])\n\nLike reduce, but with guaranteed right associativity. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\n\nExamples\n\njulia> foldr(=>, 1:4)\n1 => (2 => (3 => 4))\n\njulia> foldr(=>, 1:4; init=0)\n1 => (2 => (3 => (4 => 0)))\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.foreach-Tuple{Any}","page":"References","title":"Base.foreach","text":"foreach(f, c...) -> Nothing\n\nCall function f on each element of iterable c. For multiple iterable arguments, f is called elementwise. foreach should be used instead of map when the results of f are not needed, for example in foreach(println, array).\n\nExamples\n\njulia> a = 1:3:7;\n\njulia> foreach(x -> println(x^2), a)\n1\n16\n49\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.front-Tuple{Tuple}","page":"References","title":"Base.front","text":"front(x::Tuple)::Tuple\n\nReturn a Tuple consisting of all but the last component of x.\n\nExamples\n\njulia> Base.front((1,2,3))\n(1, 2)\n\njulia> Base.front(())\nERROR: ArgumentError: Cannot call front on an empty tuple.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.fullname-Tuple{Module}","page":"References","title":"Base.fullname","text":"fullname(m::Module)\n\nGet the fully-qualified name of a module as a tuple of symbols. For example,\n\nExamples\n\njulia> fullname(Base.Iterators)\n(:Base, :Iterators)\n\njulia> fullname(Main)\n(:Main,)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.functionloc-Tuple{Any, Any}","page":"References","title":"Base.functionloc","text":"functionloc(f::Function, types)\n\nReturns a tuple (filename,line) giving the location of a generic Function definition.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.functionloc-Tuple{Method}","page":"References","title":"Base.functionloc","text":"functionloc(m::Method)\n\nReturns a tuple (filename,line) giving the location of a Method definition.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.gc_live_bytes-Tuple{}","page":"References","title":"Base.gc_live_bytes","text":"Base.gc_live_bytes()\n\nReturn the total size (in bytes) of objects currently in memory. This is computed as the total size of live objects after the last garbage collection, plus the number of bytes allocated since then.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.gcd-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"References","title":"Base.gcd","text":"gcd(x, y...)\n\nGreatest common (positive) divisor (or zero if all arguments are zero). The arguments may be integer and rational numbers.\n\ncompat: Julia 1.4\nRational arguments require Julia 1.4 or later.\n\nExamples\n\njulia> gcd(6,9)\n3\n\njulia> gcd(6,-9)\n3\n\njulia> gcd(6,0)\n6\n\njulia> gcd(0,0)\n0\n\njulia> gcd(1//3,2//3)\n1//3\n\njulia> gcd(1//3,-2//3)\n1//3\n\njulia> gcd(1//3,2)\n1//3\n\njulia> gcd(0, 0, 10, 15)\n5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.gcdx-Tuple{Integer, Integer}","page":"References","title":"Base.gcdx","text":"gcdx(a, b)\n\nComputes the greatest common (positive) divisor of a and b and their Bézout coefficients, i.e. the integer coefficients u and v that satisfy ua+vb = d = gcd(a b). gcdx(a b) returns (d u v).\n\nThe arguments may be integer and rational numbers.\n\ncompat: Julia 1.4\nRational arguments require Julia 1.4 or later.\n\nExamples\n\njulia> gcdx(12, 42)\n(6, -3, 1)\n\njulia> gcdx(240, 46)\n(2, -9, 47)\n\nnote: Note\nBézout coefficients are not uniquely defined. gcdx returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients u and v are minimal in the sense that u  yd and v  xd. Furthermore, the signs of u and v are chosen so that d is positive. For unsigned integers, the coefficients u and v might be near their typemax, and the identity then holds only via the unsigned integers' modulo arithmetic.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.gensym-Tuple{}","page":"References","title":"Base.gensym","text":"gensym([tag])\n\nGenerates a symbol which will not conflict with other variable names.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.get!-Tuple{Any, Any, Any}","page":"References","title":"Base.get!","text":"get!(collection, key, default)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store key => default, and return default.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> get!(d, \"a\", 5)\n1\n\njulia> get!(d, \"d\", 4)\n4\n\njulia> d\nDict{String, Int64} with 4 entries:\n  \"c\" => 3\n  \"b\" => 2\n  \"a\" => 1\n  \"d\" => 4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.get!-Tuple{Function, Any, Any}","page":"References","title":"Base.get!","text":"get!(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, store key => f(), and return f().\n\nThis is intended to be called using do block syntax.\n\nExamples\n\njulia> squares = Dict{Int, Int}();\n\njulia> function get_square!(d, i)\n           get!(d, i) do\n               i^2\n           end\n       end\nget_square! (generic function with 1 method)\n\njulia> get_square!(squares, 2)\n4\n\njulia> squares\nDict{Int64, Int64} with 1 entry:\n  2 => 4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.get-Tuple{Any, Any, Any}","page":"References","title":"Base.get","text":"get(collection, key, default)\n\nReturn the value stored for the given key, or the given default value if no mapping for the key is present.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> get(d, \"a\", 3)\n1\n\njulia> get(d, \"c\", 3)\n3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.get-Tuple{Function, Any, Any}","page":"References","title":"Base.get","text":"get(f::Function, collection, key)\n\nReturn the value stored for the given key, or if no mapping for the key is present, return f().  Use get! to also store the default value in the dictionary.\n\nThis is intended to be called using do block syntax\n\nget(dict, key) do\n    # default value calculated here\n    time()\nend\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.getindex","page":"References","title":"Base.getindex","text":"getindex(collection, key...)\n\nRetrieve the value(s) stored at the given key or index within a collection. The syntax a[i,j,...] is converted by the compiler to getindex(a, i, j, ...).\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> getindex(A, \"a\")\n1\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.getindex-Tuple{AbstractArray, Vararg{Any, N} where N}","page":"References","title":"Base.getindex","text":"getindex(A, inds...)\n\nReturn a subset of array A as specified by inds, where each ind may be, for example, an Int, an AbstractRange, or a Vector. See the manual section on array indexing for details.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> getindex(A, 1)\n1\n\njulia> getindex(A, [2, 1])\n2-element Vector{Int64}:\n 3\n 1\n\njulia> getindex(A, 2:4)\n3-element Vector{Int64}:\n 3\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.getindex-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T","page":"References","title":"Base.getindex","text":"getindex(type[, elements...])\n\nConstruct a 1-d array of the specified type. This is usually called with the syntax Type[]. Element values can be specified using Type[a,b,c,...].\n\nExamples\n\njulia> Int8[1, 2, 3]\n3-element Vector{Int8}:\n 1\n 2\n 3\n\njulia> getindex(Int8, 1, 2, 3)\n3-element Vector{Int8}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.getkey-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K, V}, Any, Any}} where {K, V}","page":"References","title":"Base.getkey","text":"getkey(collection, key, default)\n\nReturn the key matching argument key if one exists in collection, otherwise return default.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> getkey(D, 'a', 1)\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> getkey(D, 'd', 'a')\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.getpass","page":"References","title":"Base.getpass","text":"Base.getpass(message::AbstractString) -> Base.SecretBuffer\n\nDisplay a message and wait for the user to input a secret, returning an IO object containing the secret.\n\nNote that on Windows, the secret might be displayed as it is typed; see Base.winprompt for securely retrieving username/password pairs from a graphical interface.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.has_bottom_parameter-Tuple{DataType}","page":"References","title":"Base.has_bottom_parameter","text":"has_bottom_parameter(t) -> Bool\n\nDetermine whether t is a Type for which one or more of its parameters is Union{}.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.has_offset_axes-Tuple{Any}","page":"References","title":"Base.has_offset_axes","text":"has_offset_axes(A)\nhas_offset_axes(A, B, ...)\n\nReturn true if the indices of A start with something other than 1 along any axis. If multiple arguments are passed, equivalent to has_offset_axes(A) | has_offset_axes(B) | ....\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.hasfastin-Tuple{Type}","page":"References","title":"Base.hasfastin","text":"hasfastin(T)\n\nDetermine whether the computation x ∈ collection where collection::T can be considered as a \"fast\" operation (typically constant or logarithmic complexity). The definition hasfastin(x) = hasfastin(typeof(x)) is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.hasfield-Tuple{Type, Symbol}","page":"References","title":"Base.hasfield","text":"hasfield(T::Type, name::Symbol)\n\nReturn a boolean indicating whether T has name as one of its own fields.\n\ncompat: Julia 1.2\nThis function requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.hash-Tuple{Any}","page":"References","title":"Base.hash","text":"hash(x[, h::UInt])\n\nCompute an integer hash code such that isequal(x,y) implies hash(x)==hash(y). The optional second argument h is a hash code to be mixed with the result.\n\nNew types should implement the 2-argument form, typically by calling the 2-argument hash method recursively in order to mix hashes of the contents with each other (and with h). Typically, any type that implements hash should also implement its own == (hence isequal) to guarantee the property mentioned above. Types supporting subtraction (operator -) should also implement widen, which is required to hash values inside heterogeneous arrays.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.haskey-Tuple{Dict, Any}","page":"References","title":"Base.haskey","text":"haskey(collection, key) -> Bool\n\nDetermine whether a collection has a mapping for a given key.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> haskey(D, 'a')\ntrue\n\njulia> haskey(D, 'c')\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.hasmethod-Tuple{Any, Any}","page":"References","title":"Base.hasmethod","text":"hasmethod(f, t::Type{<:Tuple}[, kwnames]; world=typemax(UInt)) -> Bool\n\nDetermine whether the given generic function has a method matching the given Tuple of argument types with the upper bound of world age given by world.\n\nIf a tuple of keyword argument names kwnames is provided, this also checks whether the method of f matching t has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with kwargs..., any names given in kwnames are considered valid. Otherwise the provided names must be a subset of the method's keyword arguments.\n\nSee also applicable.\n\ncompat: Julia 1.2\nProviding keyword argument names requires Julia 1.2 or later.\n\nExamples\n\njulia> hasmethod(length, Tuple{Array})\ntrue\n\njulia> f(; oranges=0) = oranges;\n\njulia> hasmethod(f, Tuple{}, (:oranges,))\ntrue\n\njulia> hasmethod(f, Tuple{}, (:apples, :bananas))\nfalse\n\njulia> g(; xs...) = 4;\n\njulia> hasmethod(g, Tuple{}, (:a, :b, :c, :d))  # g accepts arbitrary kwargs\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.hasproperty-Tuple{Any, Symbol}","page":"References","title":"Base.hasproperty","text":"hasproperty(x, s::Symbol)\n\nReturn a boolean indicating whether the object x has s as one of its own properties.\n\ncompat: Julia 1.2\nThis function requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.hastypemax-Tuple{Union{Type{Int128}, Type{Int16}, Type{Int32}, Type{Int64}, Type{Int8}, Type{UInt128}, Type{UInt16}, Type{UInt32}, Type{UInt64}, Type{UInt8}}}","page":"References","title":"Base.hastypemax","text":"hastypemax(T::Type) -> Bool\n\nReturn true if and only if the extrema typemax(T) and typemin(T) are defined.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.hcat-Tuple","page":"References","title":"Base.hcat","text":"hcat(A...)\n\nConcatenate along dimension 2.\n\nExamples\n\njulia> a = [1; 2; 3; 4; 5]\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> b = [6 7; 8 9; 10 11; 12 13; 14 15]\n5×2 Matrix{Int64}:\n  6   7\n  8   9\n 10  11\n 12  13\n 14  15\n\njulia> hcat(a,b)\n5×3 Matrix{Int64}:\n 1   6   7\n 2   8   9\n 3  10  11\n 4  12  13\n 5  14  15\n\njulia> c = ([1; 2; 3], [4; 5; 6])\n([1, 2, 3], [4, 5, 6])\n\njulia> hcat(c...)\n3×2 Matrix{Int64}:\n 1  4\n 2  5\n 3  6\n\njulia> x = Matrix(undef, 3, 0)  # x = [] would have created an Array{Any, 1}, but need an Array{Any, 2}\n3×0 Matrix{Any}\n\njulia> hcat(x, [1; 2; 3])\n3×1 Matrix{Any}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.hex2bytes","page":"References","title":"Base.hex2bytes","text":"hex2bytes(s::Union{AbstractString,AbstractVector{UInt8}})\n\nGiven a string or array s of ASCII codes for a sequence of hexadecimal digits, returns a Vector{UInt8} of bytes  corresponding to the binary representation: each successive pair of hexadecimal digits in s gives the value of one byte in the return vector.\n\nThe length of s must be even, and the returned array has half of the length of s. See also hex2bytes! for an in-place version, and bytes2hex for the inverse.\n\nExamples\n\njulia> s = string(12345, base = 16)\n\"3039\"\n\njulia> hex2bytes(s)\n2-element Vector{UInt8}:\n 0x30\n 0x39\n\njulia> a = b\"01abEF\"\n6-element Base.CodeUnits{UInt8, String}:\n 0x30\n 0x31\n 0x61\n 0x62\n 0x45\n 0x46\n\njulia> hex2bytes(a)\n3-element Vector{UInt8}:\n 0x01\n 0xab\n 0xef\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.hex2bytes!-Tuple{AbstractVector{UInt8}, Union{String, AbstractVector{UInt8}}}","page":"References","title":"Base.hex2bytes!","text":"hex2bytes!(d::AbstractVector{UInt8}, s::Union{String,AbstractVector{UInt8}})\n\nConvert an array s of bytes representing a hexadecimal string to its binary representation, similar to hex2bytes except that the output is written in-place in d.   The length of s must be exactly twice the length of d.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.htol-Tuple{Any}","page":"References","title":"Base.htol","text":"htol(x)\n\nConvert the endianness of a value from that used by the Host to Little-endian.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.hton-Tuple{Any}","page":"References","title":"Base.hton","text":"hton(x)\n\nConvert the endianness of a value from that used by the Host to Network byte order (big-endian).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.hvcat-Tuple{Tuple{Vararg{Int64, N} where N}, Vararg{AbstractVecOrMat{T} where T, N} where N}","page":"References","title":"Base.hvcat","text":"hvcat(rows::Tuple{Vararg{Int}}, values...)\n\nHorizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.\n\nExamples\n\njulia> a, b, c, d, e, f = 1, 2, 3, 4, 5, 6\n(1, 2, 3, 4, 5, 6)\n\njulia> [a b c; d e f]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> hvcat((3,3), a,b,c,d,e,f)\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> [a b;c d; e f]\n3×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\n\njulia> hvcat((2,2,2), a,b,c,d,e,f)\n3×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\n\nIf the first argument is a single integer n, then all block rows are assumed to have n block columns.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.identity-Tuple{Any}","page":"References","title":"Base.identity","text":"identity(x)\n\nThe identity function. Returns its argument.\n\nExamples\n\njulia> identity(\"Well, what did you expect?\")\n\"Well, what did you expect?\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ignorestatus-Tuple{Cmd}","page":"References","title":"Base.ignorestatus","text":"ignorestatus(command)\n\nMark a command object so that running it will not throw an error if the result code is non-zero.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.imag-Tuple{Complex}","page":"References","title":"Base.imag","text":"imag(z)\n\nReturn the imaginary part of the complex number z.\n\nExamples\n\njulia> imag(1 + 3im)\n3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.in","page":"References","title":"Base.in","text":"in(item, collection) -> Bool\n∈(item, collection) -> Bool\n\nDetermine whether an item is in the given collection, in the sense that it is == to one of the values generated by iterating over the collection. Returns a Bool value, except if item is missing or collection contains missing but not item, in which case missing is returned (three-valued logic, matching the behavior of any and ==).\n\nSome collections follow a slightly different definition. For example, Sets check whether the item isequal to one of the elements. Dicts look for key=>value pairs, and the key is compared using isequal. To test for the presence of a key in a dictionary, use haskey or k in keys(dict). For these collections, the result is always a Bool and never missing.\n\nTo determine whether an item is not in a given collection, see :∉. You may also negate the in by doing !(a in b) which is logically similar to \"not in\".\n\nWhen broadcasting with in.(items, collection) or items .∈ collection, both item and collection are broadcasted over, which is often not what is intended. For example, if both arguments are vectors (and the dimensions match), the result is a vector indicating whether each value in collection items is in the value at the corresponding position in collection. To get a vector indicating whether each value in items is in collection, wrap collection in a tuple or a Ref like this: in.(items, Ref(collection)) or items .∈ Ref(collection).\n\nExamples\n\njulia> a = 1:3:20\n1:3:19\n\njulia> 4 in a\ntrue\n\njulia> 5 in a\nfalse\n\njulia> missing in [1, 2]\nmissing\n\njulia> 1 in [2, missing]\nmissing\n\njulia> 1 in [1, missing]\ntrue\n\njulia> missing in Set([1, 2])\nfalse\n\njulia> !(21 in a)\ntrue\n\njulia> !(19 in a)\nfalse\n\njulia> [1, 2] .∈ [2, 3]\n2-element BitVector:\n 0\n 0\n\njulia> [1, 2] .∈ ([2, 3],)\n2-element BitVector:\n 0\n 1\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.in-Tuple{Any}","page":"References","title":"Base.in","text":"in(collection)\n∈(collection)\n\nCreate a function that checks whether its argument is in collection, i.e. a function equivalent to y -> y in collection. See also insorted for use with sorted collections.\n\nThe returned function is of type Base.Fix2{typeof(in)}, which can be used to implement specialized methods.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.include","page":"References","title":"Base.include","text":"Base.include([mapexpr::Function,] [m::Module,] path::AbstractString)\n\nEvaluate the contents of the input source file in the global scope of module m. Every module (except those defined with baremodule) has its own definition of include omitting the m argument, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to include will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.\n\nThe optional first argument mapexpr can be used to transform the included code before it is evaluated: for each parsed expression expr in path, the include function actually evaluates mapexpr(expr).  If it is omitted, mapexpr defaults to identity.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.include_dependency-Tuple{AbstractString}","page":"References","title":"Base.include_dependency","text":"include_dependency(path::AbstractString)\n\nIn a module, declare that the file specified by path (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.\n\nThis is only needed if your module depends on a file that is not used via include. It has no effect outside of compilation.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.include_string","page":"References","title":"Base.include_string","text":"include_string([mapexpr::Function,] m::Module, code::AbstractString, filename::AbstractString=\"string\")\n\nLike include, except reads code from the given string rather than from a file.\n\nThe optional first argument mapexpr can be used to transform the included code before it is evaluated: for each parsed expression expr in code, the include_string function actually evaluates mapexpr(expr).  If it is omitted, mapexpr defaults to identity.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.indentation-Tuple{AbstractString}","page":"References","title":"Base.indentation","text":"indentation(str::AbstractString; tabwidth=8) -> (Int, Bool)\n\nCalculate the width of leading white space. Return the width and a flag to indicate if the string is empty.\n\nExamples\n\njulia> Base.indentation(\"\")\n(0, true)\n\njulia> Base.indentation(\"  a\")\n(2, false)\n\njulia> Base.indentation(\"\\ta\"; tabwidth=3)\n(3, false)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.indexin-Tuple{Any, AbstractArray}","page":"References","title":"Base.indexin","text":"indexin(a, b)\n\nReturn an array containing the first index in b for each value in a that is a member of b. The output array contains nothing wherever a is not a member of b.\n\nExamples\n\njulia> a = ['a', 'b', 'c', 'b', 'd', 'a'];\n\njulia> b = ['a', 'b', 'c'];\n\njulia> indexin(a, b)\n6-element Vector{Union{Nothing, Int64}}:\n 1\n 2\n 3\n 2\n  nothing\n 1\n\njulia> indexin(b, a)\n3-element Vector{Union{Nothing, Int64}}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.insert!-Union{Tuple{T}, Tuple{Vector{T}, Integer, Any}} where T","page":"References","title":"Base.insert!","text":"insert!(a::Vector, index::Integer, item)\n\nInsert an item into a at the given index. index is the index of item in the resulting a.\n\nExamples\n\njulia> insert!([6, 5, 4, 2, 1], 4, 3)\n6-element Vector{Int64}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.instances","page":"References","title":"Base.instances","text":"instances(T::Type)\n\nReturn a collection of all instances of the given type, if applicable. Mostly used for enumerated types (see @enum).\n\nExample\n\njulia> @enum Color red blue green\n\njulia> instances(Color)\n(red, blue, green)\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.intersect!-Tuple{AbstractSet, Vararg{Any, N} where N}","page":"References","title":"Base.intersect!","text":"intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nIntersect all passed in sets and overwrite s with the result. Maintain order with arrays.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.intersect-Tuple{AbstractSet, Any, Vararg{Any, N} where N}","page":"References","title":"Base.intersect","text":"intersect(s, itrs...)\n∩(s, itrs...)\n\nConstruct the intersection of sets. Maintain order with arrays.\n\nExamples\n\njulia> intersect([1, 2, 3], [3, 4, 5])\n1-element Vector{Int64}:\n 3\n\njulia> intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])\n2-element Vector{Int64}:\n 4\n 6\n\njulia> intersect(Set([1, 2]), BitSet([2, 3]))\nSet{Int64} with 1 element:\n  2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.inv-Tuple{Number}","page":"References","title":"Base.inv","text":"inv(x)\n\nReturn the multiplicative inverse of x, such that x*inv(x) or inv(x)*x yields one(x) (the multiplicative identity) up to roundoff errors.\n\nIf x is a number, this is essentially the same as one(x)/x, but for some types inv(x) may be slightly more efficient.\n\nExamples\n\njulia> inv(2)\n0.5\n\njulia> inv(1 + 2im)\n0.2 - 0.4im\n\njulia> inv(1 + 2im) * (1 + 2im)\n1.0 + 0.0im\n\njulia> inv(2//3)\n3//2\n\ncompat: Julia 1.2\ninv(::Missing) requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.invmod-Tuple{Integer, Integer}","page":"References","title":"Base.invmod","text":"invmod(n, m)\n\nTake the inverse of n modulo m: y such that n y = 1 pmod m, and div(ym) = 0. This will throw an error if m = 0, or if gcd(nm) neq 1.\n\nExamples\n\njulia> invmod(2,5)\n3\n\njulia> invmod(2,3)\n2\n\njulia> invmod(5,6)\n5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.invoke_in_world-Tuple{UInt64, Any, Vararg{Any, N} where N}","page":"References","title":"Base.invoke_in_world","text":"invoke_in_world(world, f, args...; kwargs...)\n\nCall f(args...; kwargs...) in a fixed world age, world.\n\nThis is useful for infrastructure running in the user's Julia session which is not part of the user's program. For example, things related to the REPL, editor support libraries, etc. In these cases it can be useful to prevent unwanted method invalidation and recompilation latency, and to prevent the user from breaking supporting infrastructure by mistake.\n\nThe current world age can be queried using Base.get_world_counter() and stored for later use within the lifetime of the current Julia session, or when serializing and reloading the system image.\n\nTechnically, invoke_in_world will prevent any function called by f from being extended by the user during their Julia session. That is, generic function method tables seen by f (and any functions it calls) will be frozen as they existed at the given world age. In a sense, this is like the opposite of invokelatest.\n\nnote: Note\nIt is not valid to store world ages obtained in precompilation for later use. This is because precompilation generates a \"parallel universe\" where the world age refers to system state unrelated to the main Julia session.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.invokelatest-Tuple{Any, Vararg{Any, N} where N}","page":"References","title":"Base.invokelatest","text":"invokelatest(f, args...; kwargs...)\n\nCalls f(args...; kwargs...), but guarantees that the most recent method of f will be executed.   This is useful in specialized circumstances, e.g. long-running event loops or callback functions that may call obsolete versions of a function f. (The drawback is that invokelatest is somewhat slower than calling f directly, and the type of the result cannot be inferred by the compiler.)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.invperm-Tuple{AbstractVector{T} where T}","page":"References","title":"Base.invperm","text":"invperm(v)\n\nReturn the inverse permutation of v. If B = A[v], then A == B[invperm(v)].\n\nExamples\n\njulia> v = [2; 4; 3; 1];\n\njulia> invperm(v)\n4-element Vector{Int64}:\n 4\n 1\n 3\n 2\n\njulia> A = ['a','b','c','d'];\n\njulia> B = A[v]\n4-element Vector{Char}:\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n 'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> B[invperm(v)]\n4-element Vector{Char}:\n 'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n 'd': ASCII/Unicode U+0064 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.invpermute!-Tuple{Any, AbstractVector{T} where T}","page":"References","title":"Base.invpermute!","text":"invpermute!(v, p)\n\nLike permute!, but the inverse of the given permutation is applied.\n\nExamples\n\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> invpermute!(A, perm);\n\njulia> A\n4-element Vector{Int64}:\n 4\n 1\n 3\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isabstracttype-Tuple{Any}","page":"References","title":"Base.isabstracttype","text":"isabstracttype(T)\n\nDetermine whether type T was declared as an abstract type (i.e. using the abstract keyword).\n\nExamples\n\njulia> isabstracttype(AbstractArray)\ntrue\n\njulia> isabstracttype(Vector)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isambiguous-Tuple{Method, Method}","page":"References","title":"Base.isambiguous","text":"Base.isambiguous(m1, m2; ambiguous_bottom=false) -> Bool\n\nDetermine whether two methods m1 and m2 may be ambiguous for some call signature. This test is performed in the context of other methods of the same function; in isolation, m1 and m2 might be ambiguous, but if a third method resolving the ambiguity has been defined, this returns false. Alternatively, in isolation m1 and m2 might be ordered, but if a third method cannot be sorted with them, they may cause an ambiguity together.\n\nFor parametric types, the ambiguous_bottom keyword argument controls whether Union{} counts as an ambiguous intersection of type parameters – when true, it is considered ambiguous, when false it is not.\n\nExamples\n\njulia> foo(x::Complex{<:Integer}) = 1\nfoo (generic function with 1 method)\n\njulia> foo(x::Complex{<:Rational}) = 2\nfoo (generic function with 2 methods)\n\njulia> m1, m2 = collect(methods(foo));\n\njulia> typeintersect(m1.sig, m2.sig)\nTuple{typeof(foo), Complex{Union{}}}\n\njulia> Base.isambiguous(m1, m2, ambiguous_bottom=true)\ntrue\n\njulia> Base.isambiguous(m1, m2, ambiguous_bottom=false)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isapprox-Tuple{Any}","page":"References","title":"Base.isapprox","text":"isapprox(x; kwargs...) / ≈(x; kwargs...)\n\nCreate a function that compares its argument to x using ≈, i.e. a function equivalent to y -> y ≈ x.\n\nThe keyword arguments supported here are the same as those in the 2-argument isapprox.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isapprox-Tuple{Number, Number}","page":"References","title":"Base.isapprox","text":"isapprox(x, y; atol::Real=0, rtol::Real=atol>0 ? 0 : √eps, nans::Bool=false[, norm::Function])\n\nInexact equality comparison: true if norm(x-y) <= max(atol, rtol*max(norm(x), norm(y))). The default atol is zero and the default rtol depends on the types of x and y. The keyword argument nans determines whether or not NaN values are considered equal (defaults to false).\n\nFor real or complex floating-point values, if an atol > 0 is not specified, rtol defaults to the square root of eps of the type of x or y, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an atol > 0 is supplied, rtol defaults to zero.\n\nThe norm keyword defaults to abs for numeric (x,y) and to LinearAlgebra.norm for arrays (where an alternative norm choice is sometimes useful). When x and y are arrays, if norm(x-y) is not finite (i.e. ±Inf or NaN), the comparison falls back to checking whether all elements of x and y are approximately equal component-wise.\n\nThe binary operator ≈ is equivalent to isapprox with the default arguments, and x ≉ y is equivalent to !isapprox(x,y).\n\nNote that x ≈ 0 (i.e., comparing to zero with the default tolerances) is equivalent to x == 0 since the default atol is 0.  In such cases, you should either supply an appropriate atol (or use norm(x) ≤ atol) or rearrange your code (e.g. use x ≈ y rather than x - y ≈ 0).   It is not possible to pick a nonzero atol automatically because it depends on the overall scaling (the \"units\") of your problem: for example, in x - y ≈ 0, atol=1e-9 is an absurdly small tolerance if x is the radius of the Earth in meters, but an absurdly large tolerance if x is the radius of a Hydrogen atom in meters.\n\ncompat: Julia 1.6\nPassing the norm keyword argument when comparing numeric (non-array) arguments requires Julia 1.6 or later.\n\nExamples\n\njulia> 0.1 ≈ (0.1 - 1e-10)\ntrue\n\njulia> isapprox(10, 11; atol = 2)\ntrue\n\njulia> isapprox([10.0^9, 1.0], [10.0^9, 2.0])\ntrue\n\njulia> 1e-10 ≈ 0\nfalse\n\njulia> isapprox(1e-10, 0, atol=1e-8)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isascii-Tuple{Char}","page":"References","title":"Base.isascii","text":"isascii(c::Union{AbstractChar,AbstractString}) -> Bool\n\nTest whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.\n\nExamples\n\njulia> isascii('a')\ntrue\n\njulia> isascii('α')\nfalse\n\njulia> isascii(\"abc\")\ntrue\n\njulia> isascii(\"αβγ\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isassigned","page":"References","title":"Base.isassigned","text":"isassigned(array, i) -> Bool\n\nTest whether the given array has a value associated with index i. Return false if the index is out of bounds, or has an undefined reference.\n\nExamples\n\njulia> isassigned(rand(3, 3), 5)\ntrue\n\njulia> isassigned(rand(3, 3), 3 * 3 + 1)\nfalse\n\njulia> mutable struct Foo end\n\njulia> v = similar(rand(3), Foo)\n3-element Vector{Foo}:\n #undef\n #undef\n #undef\n\njulia> isassigned(v, 1)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.isassigned-Tuple{Base.RefValue}","page":"References","title":"Base.isassigned","text":"isassigned(ref::RefValue) -> Bool\n\nTest whether the given Ref is associated with a value. This is always true for a Ref of a bitstype object. Return false if the reference is undefined.\n\nExamples\n\njulia> ref = Ref{Function}()\nBase.RefValue{Function}(#undef)\n\njulia> isassigned(ref)\nfalse\n\njulia> ref[] = (foobar(x) = x)\nfoobar (generic function with 1 method)\n\njulia> isassigned(ref)\ntrue\n\njulia> isassigned(Ref{Int}())\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isbinaryoperator-Tuple{Symbol}","page":"References","title":"Base.isbinaryoperator","text":"isbinaryoperator(s::Symbol)\n\nReturn true if the symbol can be used as a binary (infix) operator, false otherwise.\n\nExamples\n\njulia> Meta.isbinaryoperator(:-), Meta.isbinaryoperator(:√), Meta.isbinaryoperator(:f)\n(true, false, false)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isbits-Tuple{Any}","page":"References","title":"Base.isbits","text":"isbits(x)\n\nReturn true if x is an instance of an isbitstype type.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isbitstype-Tuple{Type}","page":"References","title":"Base.isbitstype","text":"isbitstype(T)\n\nReturn true if type T is a \"plain data\" type, meaning it is immutable and contains no references to other values, only primitive types and other isbitstype types. Typical examples are numeric types such as UInt8, Float64, and Complex{Float64}. This category of types is significant since they are valid as type parameters, may not track isdefined / isassigned status, and have a defined layout that is compatible with C.\n\nExamples\n\njulia> isbitstype(Complex{Float64})\ntrue\n\njulia> isbitstype(Complex)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isbitsunion-Tuple{Union}","page":"References","title":"Base.isbitsunion","text":"Base.isbitsunion(::Type{T})\n\nReturn whether a type is an \"is-bits\" Union type, meaning each type included in a Union is isbitstype.\n\nExamples\n\njulia> Base.isbitsunion(Union{Float64, UInt8})\ntrue\n\njulia> Base.isbitsunion(Union{Float64, String})\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isconcretetype-Tuple{Any}","page":"References","title":"Base.isconcretetype","text":"isconcretetype(T)\n\nDetermine whether type T is a concrete type, meaning it could have direct instances (values x such that typeof(x) === T).\n\nExamples\n\njulia> isconcretetype(Complex)\nfalse\n\njulia> isconcretetype(Complex{Float32})\ntrue\n\njulia> isconcretetype(Vector{Complex})\ntrue\n\njulia> isconcretetype(Vector{Complex{Float32}})\ntrue\n\njulia> isconcretetype(Union{})\nfalse\n\njulia> isconcretetype(Union{Int,String})\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isconst-Tuple{Module, Symbol}","page":"References","title":"Base.isconst","text":"isconst(m::Module, s::Symbol) -> Bool\n\nDetermine whether a global is declared const in a given Module.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isdisjoint-Tuple{Any, Any}","page":"References","title":"Base.isdisjoint","text":"isdisjoint(v1, v2) -> Bool\n\nReturn whether the collections v1 and v2 are disjoint, i.e. whether their intersection is empty.\n\ncompat: Julia 1.5\nThis function requires at least Julia 1.5.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isdispatchtuple-Tuple{Any}","page":"References","title":"Base.isdispatchtuple","text":"isdispatchtuple(T)\n\nDetermine whether type T is a tuple \"leaf type\", meaning it could appear as a type signature in dispatch and has no subtypes (or supertypes) which could appear in a call.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isdone-Tuple{Any, Vararg{Any, N} where N}","page":"References","title":"Base.isdone","text":"isdone(itr, state...) -> Union{Bool, Missing}\n\nThis function provides a fast-path hint for iterator completion. This is useful for mutable iterators that want to avoid having elements consumed, if they are not going to be exposed to the user (e.g. to check for done-ness in isempty or zip). Mutable iterators that want to opt into this feature should define an isdone method that returns true/false depending on whether the iterator is done or not. Stateless iterators need not implement this function. If the result is missing, callers may go ahead and compute iterate(x, state...) === nothing to compute a definite answer.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isempty-Tuple{Any}","page":"References","title":"Base.isempty","text":"isempty(collection) -> Bool\n\nDetermine whether a collection is empty (has no elements).\n\nExamples\n\njulia> isempty([])\ntrue\n\njulia> isempty([1 2 3])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isempty-Tuple{Base.GenericCondition}","page":"References","title":"Base.isempty","text":"isempty(condition)\n\nReturn true if no tasks are waiting on the condition, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isequal-Tuple{Any, Any}","page":"References","title":"Base.isequal","text":"isequal(x, y)\n\nSimilar to ==, except for the treatment of floating point numbers and of missing values. isequal treats all floating-point NaN values as equal to each other, treats -0.0 as unequal to 0.0, and missing as equal to missing. Always returns a Bool value.\n\nImplementation\n\nThe default implementation of isequal calls ==, so a type that does not involve floating-point values generally only needs to define ==.\n\nisequal is the comparison function used by hash tables (Dict). isequal(x,y) must imply that hash(x) == hash(y).\n\nThis typically means that types for which a custom == or isequal method exists must implement a corresponding hash method (and vice versa). Collections typically implement isequal by calling isequal recursively on all contents.\n\nScalar types generally do not need to implement isequal separate from ==, unless they represent floating-point numbers amenable to a more efficient implementation than that provided as a generic fallback (based on isnan, signbit, and ==).\n\nExamples\n\njulia> isequal([1., NaN], [1., NaN])\ntrue\n\njulia> [1., NaN] == [1., NaN]\nfalse\n\njulia> 0.0 == -0.0\ntrue\n\njulia> isequal(0.0, -0.0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isequal-Tuple{Any}","page":"References","title":"Base.isequal","text":"isequal(x)\n\nCreate a function that compares its argument to x using isequal, i.e. a function equivalent to y -> isequal(y, x).\n\nThe returned function is of type Base.Fix2{typeof(isequal)}, which can be used to implement specialized methods.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.iseven-Tuple{Integer}","page":"References","title":"Base.iseven","text":"iseven(x::Integer) -> Bool\n\nReturn true if x is even (that is, divisible by 2), and false otherwise.\n\nExamples\n\njulia> iseven(9)\nfalse\n\njulia> iseven(10)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isfinite-Tuple{Number}","page":"References","title":"Base.isfinite","text":"isfinite(f) -> Bool\n\nTest whether a number is finite.\n\nExamples\n\njulia> isfinite(5)\ntrue\n\njulia> isfinite(NaN32)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isidentifier-Tuple{AbstractString}","page":"References","title":"Base.isidentifier","text":" isidentifier(s) -> Bool\n\nReturn whether the symbol or string s contains characters that are parsed as a valid identifier in Julia code.\n\nInternally Julia allows any sequence of characters in a Symbol (except \\0s), and macros automatically use variable names containing # in order to avoid naming collision with the surrounding code. In order for the parser to recognize a variable, it uses a limited set of characters (greatly extended by Unicode). isidentifier() makes it possible to query the parser directly whether a symbol contains valid characters.\n\nExamples\n\njulia> Meta.isidentifier(:x), Meta.isidentifier(\"1x\")\n(true, false)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isimmutable-Tuple{Any}","page":"References","title":"Base.isimmutable","text":"isimmutable(v) -> Bool\n\nwarning: Warning\nConsider using !ismutable(v) instead, as isimmutable(v) will be replaced by !ismutable(v) in a future release. (Since Julia 1.5)\n\nReturn true iff value v is immutable.  See Mutable Composite Types for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of DataType is mutable.\n\nExamples\n\njulia> isimmutable(1)\ntrue\n\njulia> isimmutable([1,2])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isinf-Tuple{Real}","page":"References","title":"Base.isinf","text":"isinf(f) -> Bool\n\nTest whether a number is infinite.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isinteger-Tuple{Integer}","page":"References","title":"Base.isinteger","text":"isinteger(x) -> Bool\n\nTest whether x is numerically equal to some integer.\n\nExamples\n\njulia> isinteger(4.0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isinteractive-Tuple{}","page":"References","title":"Base.isinteractive","text":"isinteractive() -> Bool\n\nDetermine whether Julia is running an interactive session.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isiterable-Tuple{Any}","page":"References","title":"Base.isiterable","text":"isiterable(T) -> Bool\n\nTest if type T is an iterable collection type or not, that is whether it has an iterate method or not.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isless","page":"References","title":"Base.isless","text":"isless(x, y)\n\nTest whether x is less than y, according to a fixed total order. isless is not defined on all pairs of values (x, y). However, if it is defined, it is expected to satisfy the following:\n\nIf isless(x, y) is defined, then so is isless(y, x) and isequal(x, y), and exactly one of those three yields true.\nThe relation defined by isless is transitive, i.e., isless(x, y) && isless(y, z) implies isless(x, z).\n\nValues that are normally unordered, such as NaN, are ordered in an arbitrary but consistent fashion. missing values are ordered last.\n\nThis is the default comparison used by sort.\n\nImplementation\n\nNon-numeric types with a total order should implement this function. Numeric types only need to implement it if they have special values such as NaN. Types with a partial order should implement <. See the documentation on Alternate orderings for how to define alternate ordering methods that can be used in sorting and related functions.\n\nExamples\n\njulia> isless(1, 3)\ntrue\n\njulia> isless(\"Red\", \"Blue\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.isless-Tuple{AbstractString, AbstractString}","page":"References","title":"Base.isless","text":"isless(a::AbstractString, b::AbstractString) -> Bool\n\nTest whether string a comes before string b in alphabetical order (technically, in lexicographical order by Unicode code points).\n\nExamples\n\njulia> isless(\"a\", \"b\")\ntrue\n\njulia> isless(\"β\", \"α\")\nfalse\n\njulia> isless(\"a\", \"a\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isless-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"References","title":"Base.isless","text":"isless(A::AbstractVector, B::AbstractVector)\n\nReturns true when A is less than B in lexicographic order.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isless-Tuple{Tuple, Tuple}","page":"References","title":"Base.isless","text":"isless(t1::Tuple, t2::Tuple)\n\nReturns true when t1 is less than t2 in lexicographic order.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.islocked-Tuple{ReentrantLock}","page":"References","title":"Base.islocked","text":"islocked(lock) -> Status (Boolean)\n\nCheck whether the lock is held by any task/thread. This should not be used for synchronization (see instead trylock).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ismalformed-Tuple{AbstractChar}","page":"References","title":"Base.ismalformed","text":"ismalformed(c::AbstractChar) -> Bool\n\nReturn true if c represents malformed (non-Unicode) data according to the encoding used by c.  Defaults to false for non-Char types.  See also show_invalid.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ismarked-Tuple{IO}","page":"References","title":"Base.ismarked","text":"ismarked(s)\n\nReturn true if stream s is marked.\n\nSee also mark, unmark, reset.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ismissing-Tuple{Any}","page":"References","title":"Base.ismissing","text":"ismissing(x)\n\nIndicate whether x is missing.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ismutable-Tuple{Any}","page":"References","title":"Base.ismutable","text":"ismutable(v) -> Bool\n\nReturn true iff value v is mutable.  See Mutable Composite Types for a discussion of immutability. Note that this function works on values, so if you give it a type, it will tell you that a value of DataType is mutable.\n\nExamples\n\njulia> ismutable(1)\nfalse\n\njulia> ismutable([1,2])\ntrue\n\ncompat: Julia 1.5\nThis function requires at least Julia 1.5.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isnan-Tuple{AbstractFloat}","page":"References","title":"Base.isnan","text":"isnan(f) -> Bool\n\nTest whether a number value is a NaN, an indeterminate value which is neither an infinity nor a finite number (\"not a number\").\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isnothing-Tuple{Any}","page":"References","title":"Base.isnothing","text":"isnothing(x)\n\nReturn true if x === nothing, and return false if not.\n\ncompat: Julia 1.1\nThis function requires at least Julia 1.1.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isodd-Tuple{Integer}","page":"References","title":"Base.isodd","text":"isodd(x::Integer) -> Bool\n\nReturn true if x is odd (that is, not divisible by 2), and false otherwise.\n\nExamples\n\njulia> isodd(9)\ntrue\n\njulia> isodd(10)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isone-Tuple{Any}","page":"References","title":"Base.isone","text":"isone(x)\n\nReturn true if x == one(x); if x is an array, this checks whether x is an identity matrix.\n\nExamples\n\njulia> isone(1.0)\ntrue\n\njulia> isone([1 0; 0 2])\nfalse\n\njulia> isone([1 0; 0 true])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isopen","page":"References","title":"Base.isopen","text":"isopen(object) -> Bool\n\nDetermine whether an object - such as a stream or timer – is not yet closed. Once an object is closed, it will never produce a new event. However, since a closed stream may still have data to read in its buffer, use eof to check for the ability to read data. Use the FileWatching package to be notified when a stream might be writable or readable.\n\nExamples\n\njulia> io = open(\"my_file.txt\", \"w+\");\n\njulia> isopen(io)\ntrue\n\njulia> close(io)\n\njulia> isopen(io)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.isoperator-Tuple{Union{AbstractString, Symbol}}","page":"References","title":"Base.isoperator","text":"isoperator(s::Symbol)\n\nReturn true if the symbol can be used as an operator, false otherwise.\n\nExamples\n\njulia> Meta.isoperator(:+), Meta.isoperator(:f)\n(true, false)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isoverlong-Tuple{AbstractChar}","page":"References","title":"Base.isoverlong","text":"isoverlong(c::AbstractChar) -> Bool\n\nReturn true if c represents an overlong UTF-8 sequence. Defaults to false for non-Char types.  See also decode_overlong and show_invalid.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isperm-Tuple{Any}","page":"References","title":"Base.isperm","text":"isperm(v) -> Bool\n\nReturn true if v is a valid permutation.\n\nExamples\n\njulia> isperm([1; 2])\ntrue\n\njulia> isperm([1; 3])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ispostfixoperator-Tuple{Union{AbstractString, Symbol}}","page":"References","title":"Base.ispostfixoperator","text":"ispostfixoperator(s::Union{Symbol,AbstractString})\n\nReturn true if the symbol can be used as a postfix operator, false otherwise.\n\nExamples\n\njulia> Meta.ispostfixoperator(Symbol(\"'\")), Meta.ispostfixoperator(Symbol(\"'ᵀ\")), Meta.ispostfixoperator(:-)\n(true, true, false)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ispow2-Tuple{Number}","page":"References","title":"Base.ispow2","text":"ispow2(n::Number) -> Bool\n\nTest whether n is an integer power of two.\n\nExamples\n\njulia> ispow2(4)\ntrue\n\njulia> ispow2(5)\nfalse\n\njulia> ispow2(4.5)\nfalse\n\njulia> ispow2(0.25)\ntrue\n\njulia> ispow2(1//8)\ntrue\n\ncompat: Julia 1.6\nSupport for non-Integer arguments was added in Julia 1.6.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isprimitivetype-Tuple{Type}","page":"References","title":"Base.isprimitivetype","text":"isprimitivetype(T) -> Bool\n\nDetermine whether type T was declared as a primitive type (i.e. using the primitive keyword).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isqrt-Tuple{Integer}","page":"References","title":"Base.isqrt","text":"isqrt(n::Integer)\n\nInteger square root: the largest integer m such that m*m <= n.\n\njulia> isqrt(5)\n2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isreadable","page":"References","title":"Base.isreadable","text":"isreadable(io) -> Bool\n\nReturn true if the specified IO object is readable (if that can be determined).\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           print(io, \"Hello world!\");\n           isreadable(io)\n       end\nfalse\n\njulia> open(\"myfile.txt\", \"r\") do io\n           isreadable(io)\n       end\ntrue\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.isreadonly-Tuple{Any}","page":"References","title":"Base.isreadonly","text":"isreadonly(io) -> Bool\n\nDetermine whether a stream is read-only.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> isreadonly(io)\ntrue\n\njulia> io = IOBuffer();\n\njulia> isreadonly(io)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isready-Tuple{Channel}","page":"References","title":"Base.isready","text":"isready(c::Channel)\n\nDetermine whether a Channel has a value stored to it. Returns immediately, does not block.\n\nFor unbuffered channels returns true if there are tasks waiting on a put!.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isreal-Tuple{Real}","page":"References","title":"Base.isreal","text":"isreal(x) -> Bool\n\nTest whether x or all its elements are numerically equal to some real number including infinities and NaNs. isreal(x) is true if isequal(x, real(x)) is true.\n\nExamples\n\njulia> isreal(5.)\ntrue\n\njulia> isreal(Inf + 0im)\ntrue\n\njulia> isreal([4.; complex(0,1)])\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.issetequal-Tuple{AbstractSet, AbstractSet}","page":"References","title":"Base.issetequal","text":"issetequal(a, b) -> Bool\n\nDetermine whether a and b have the same elements. Equivalent to a ⊆ b && b ⊆ a but more efficient when possible.\n\nExamples\n\njulia> issetequal([1, 2], [1, 2, 3])\nfalse\n\njulia> issetequal([1, 2], [2, 1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.issingletontype-Tuple{Any}","page":"References","title":"Base.issingletontype","text":"Base.issingletontype(T)\n\nDetermine whether type T has exactly one possible instance; for example, a struct type with no fields.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isstructtype-Tuple{Type}","page":"References","title":"Base.isstructtype","text":"isstructtype(T) -> Bool\n\nDetermine whether type T was declared as a struct type (i.e. using the struct or mutable struct keyword).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.issubnormal-Tuple{T} where T<:Union{Float16, Float32, Float64}","page":"References","title":"Base.issubnormal","text":"issubnormal(f) -> Bool\n\nTest whether a floating point number is subnormal.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.issubset","page":"References","title":"Base.issubset","text":"issubset(a, b) -> Bool\n⊆(a, b) -> Bool\n⊇(b, a) -> Bool\n\nDetermine whether every element of a is also in b, using in.\n\nExamples\n\njulia> issubset([1, 2], [1, 2, 3])\ntrue\n\njulia> [1, 2, 3] ⊆ [1, 2]\nfalse\n\njulia> [1, 2, 3] ⊇ [1, 2]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.istaskdone-Tuple{Task}","page":"References","title":"Base.istaskdone","text":"istaskdone(t::Task) -> Bool\n\nDetermine whether a task has exited.\n\nExamples\n\njulia> a2() = sum(i for i in 1:1000);\n\njulia> b = Task(a2);\n\njulia> istaskdone(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskdone(b)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.istaskfailed-Tuple{Task}","page":"References","title":"Base.istaskfailed","text":"istaskfailed(t::Task) -> Bool\n\nDetermine whether a task has exited because an exception was thrown.\n\nExamples\n\njulia> a4() = error(\"task failed\");\n\njulia> b = Task(a4);\n\njulia> istaskfailed(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskfailed(b)\ntrue\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.istaskstarted-Tuple{Task}","page":"References","title":"Base.istaskstarted","text":"istaskstarted(t::Task) -> Bool\n\nDetermine whether a task has started executing.\n\nExamples\n\njulia> a3() = sum(i for i in 1:1000);\n\njulia> b = Task(a3);\n\njulia> istaskstarted(b)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isunaryoperator-Tuple{Symbol}","page":"References","title":"Base.isunaryoperator","text":"isunaryoperator(s::Symbol)\n\nReturn true if the symbol can be used as a unary (prefix) operator, false otherwise.\n\nExamples\n\njulia> Meta.isunaryoperator(:-), Meta.isunaryoperator(:√), Meta.isunaryoperator(:f)\n(true, true, false)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.isvalid-Tuple{AbstractString, Integer}","page":"References","title":"Base.isvalid","text":"isvalid(s::AbstractString, i::Integer) -> Bool\n\nPredicate indicating whether the given index is the start of the encoding of a character in s or not. If isvalid(s, i) is true then s[i] will return the character whose encoding starts at that index, if it's false, then s[i] will raise an invalid index error or a bounds error depending on if i is in bounds. In order for isvalid(s, i) to be an O(1) function, the encoding of s must be self-synchronizing. This is a basic assumption of Julia's generic string support.\n\nSee also: getindex, iterate, thisind, nextind, prevind, length\n\nExamples\n\njulia> str = \"αβγdef\";\n\njulia> isvalid(str, 1)\ntrue\n\njulia> str[1]\n'α': Unicode U+03B1 (category Ll: Letter, lowercase)\n\njulia> isvalid(str, 2)\nfalse\n\njulia> str[2]\nERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'α', [3]=>'β'\nStacktrace:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.iswritable","page":"References","title":"Base.iswritable","text":"iswritable(io) -> Bool\n\nReturn true if the specified IO object is writable (if that can be determined).\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           print(io, \"Hello world!\");\n           iswritable(io)\n       end\ntrue\n\njulia> open(\"myfile.txt\", \"r\") do io\n           iswritable(io)\n       end\nfalse\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.iszero-Tuple{Any}","page":"References","title":"Base.iszero","text":"iszero(x)\n\nReturn true if x == zero(x); if x is an array, this checks whether all of the elements of x are zero.\n\nExamples\n\njulia> iszero(0.0)\ntrue\n\njulia> iszero([1, 9, 0])\nfalse\n\njulia> iszero([false, 0, 0])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.iterate","page":"References","title":"Base.iterate","text":"iterate(iter [, state]) -> Union{Nothing, Tuple{Any, Any}}\n\nAdvance the iterator to obtain the next element. If no elements remain, nothing should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.iterate-Tuple{AbstractString, Integer}","page":"References","title":"Base.iterate","text":"iterate(s::AbstractString, i::Integer) -> Union{Tuple{<:AbstractChar, Int}, Nothing}\n\nReturn a tuple of the character in s at index i with the index of the start of the following character in s. This is the key method that allows strings to be iterated, yielding a sequences of characters. If i is out of bounds in s then a bounds error is raised. The iterate function, as part of the iteration protocol may assume that i is the start of a character in s.\n\nSee also: getindex, checkbounds\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.jit_total_bytes-Tuple{}","page":"References","title":"Base.jit_total_bytes","text":"Base.jit_total_bytes()\n\nReturn the total amount (in bytes) allocated by the just-in-time compiler for e.g. native code and data.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.join-Tuple{IO, Any, Any, Any}","page":"References","title":"Base.join","text":"join([io::IO,] strings [, delim [, last]])\n\nJoin an array of strings into a single string, inserting the given delimiter (if any) between adjacent strings. If last is given, it will be used instead of delim between the last two strings. If io is given, the result is written to io rather than returned as a String.\n\nstrings can be any iterable over elements x which are convertible to strings via print(io::IOBuffer, x). strings will be printed to io.\n\nExamples\n\njulia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n\"apples, bananas and pineapples\"\n\njulia> join([1,2,3,4,5])\n\"12345\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.julia_cmd","page":"References","title":"Base.julia_cmd","text":"Base.julia_cmd(juliapath=joinpath(Sys.BINDIR::String, julia_exename()))\n\nReturn a julia command similar to the one of the running process. Propagates any of the --cpu-target, --sysimage, --compile, --sysimage-native-code, --compiled-modules, --inline, --check-bounds, --optimize, -g, --code-coverage, --track-allocation, --color, --startup-file, and --depwarn command line arguments that are not at their default values.\n\nAmong others, --math-mode, --warn-overwrite, and --trace-compile are notably not propagated currently.\n\ncompat: Julia 1.1\nOnly the --cpu-target, --sysimage, --depwarn, --compile and --check-bounds flags were propagated before Julia 1.1.\n\ncompat: Julia 1.5\nThe flags --color and --startup-file were added in Julia 1.5.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.keys","page":"References","title":"Base.keys","text":"keys(iterator)\n\nFor an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.keys-Tuple{AbstractDict}","page":"References","title":"Base.keys","text":"keys(a::AbstractDict)\n\nReturn an iterator over all keys in a dictionary. collect(keys(a)) returns an array of keys. When the keys are stored internally in a hash table, as is the case for Dict, the order in which they are returned may vary. But keys(a) and values(a) both iterate a and return the elements in the same order.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> collect(keys(D))\n2-element Vector{Char}:\n 'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.keytype-Tuple{AbstractArray}","page":"References","title":"Base.keytype","text":"keytype(T::Type{<:AbstractArray})\nkeytype(A::AbstractArray)\n\nReturn the key type of an array. This is equal to the eltype of the result of keys(...), and is provided mainly for compatibility with the dictionary interface.\n\nExamples\n\njulia> keytype([1, 2, 3]) == Int\ntrue\n\njulia> keytype([1 2; 3 4])\nCartesianIndex{2}\n\ncompat: Julia 1.2\nFor arrays, this function requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.keytype-Union{Tuple{Type{var\"#s832\"} where var\"#s832\"<:AbstractDict{K, V}}, Tuple{V}, Tuple{K}} where {K, V}","page":"References","title":"Base.keytype","text":"keytype(type)\n\nGet the key type of an dictionary type. Behaves similarly to eltype.\n\nExamples\n\njulia> keytype(Dict(Int32(1) => \"foo\"))\nInt32\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.kill","page":"References","title":"Base.kill","text":"kill(p::Process, signum=Base.SIGTERM)\n\nSend a signal to a process. The default is to terminate the process. Returns successfully if the process has already exited, but throws an error if killing the process failed for other reasons (e.g. insufficient permissions).\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.last-Tuple{AbstractString, Integer}","page":"References","title":"Base.last","text":"last(s::AbstractString, n::Integer)\n\nGet a string consisting of the last n characters of s.\n\nExamples\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 1)\n\"0\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 3)\n\"²>0\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.last-Tuple{Any, Integer}","page":"References","title":"Base.last","text":"last(itr, n::Integer)\n\nGet the last n elements of the iterable collection itr, or fewer elements if v is not long enough.\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> last([\"foo\", \"bar\", \"qux\"], 2)\n2-element Vector{String}:\n \"bar\"\n \"qux\"\n\njulia> last(1:6, 10)\n1:6\n\njulia> last(Float64[], 1)\nFloat64[]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.last-Tuple{Any}","page":"References","title":"Base.last","text":"last(coll)\n\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling lastindex to get the last index. Return the end point of an AbstractRange even if it is empty.\n\nExamples\n\njulia> last(1:2:10)\n9\n\njulia> last([1; 2; 3; 4])\n4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.lastindex-Tuple{AbstractArray}","page":"References","title":"Base.lastindex","text":"lastindex(collection) -> Integer\nlastindex(collection, d) -> Integer\n\nReturn the last index of collection. If d is given, return the last index of collection along dimension d.\n\nThe syntaxes A[end] and A[end, end] lower to A[lastindex(A)] and A[lastindex(A, 1), lastindex(A, 2)], respectively.\n\nExamples\n\njulia> lastindex([1,2,4])\n3\n\njulia> lastindex(rand(3,4,5), 2)\n4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.lcm-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"References","title":"Base.lcm","text":"lcm(x, y...)\n\nLeast common (positive) multiple (or zero if any argument is zero). The arguments may be integer and rational numbers.\n\ncompat: Julia 1.4\nRational arguments require Julia 1.4 or later.\n\nExamples\n\njulia> lcm(2,3)\n6\n\njulia> lcm(-2,3)\n6\n\njulia> lcm(0,3)\n0\n\njulia> lcm(0,0)\n0\n\njulia> lcm(1//3,2//3)\n2//3\n\njulia> lcm(1//3,-2//3)\n2//3\n\njulia> lcm(1//3,2)\n2//1\n\njulia> lcm(1,3,5,7)\n105\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.leading_ones-Tuple{Integer}","page":"References","title":"Base.leading_ones","text":"leading_ones(x::Integer) -> Integer\n\nNumber of ones leading the binary representation of x.\n\nExamples\n\njulia> leading_ones(UInt32(2 ^ 32 - 2))\n31\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.leading_zeros-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}","page":"References","title":"Base.leading_zeros","text":"leading_zeros(x::Integer) -> Integer\n\nNumber of zeros leading the binary representation of x.\n\nExamples\n\njulia> leading_zeros(Int32(1))\n31\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.length","page":"References","title":"Base.length","text":"length(collection) -> Integer\n\nReturn the number of elements in the collection.\n\nUse lastindex to get the last valid index of an indexable collection.\n\nExamples\n\njulia> length(1:5)\n5\n\njulia> length([1, 2, 3, 4])\n4\n\njulia> length([1 2; 3 4])\n4\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.length-Tuple{AbstractArray}","page":"References","title":"Base.length","text":"length(A::AbstractArray)\n\nReturn the number of elements in the array, defaults to prod(size(A)).\n\nExamples\n\njulia> length([1, 2, 3, 4])\n4\n\njulia> length([1 2; 3 4])\n4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.length-Tuple{AbstractString}","page":"References","title":"Base.length","text":"length(s::AbstractString) -> Int\nlength(s::AbstractString, i::Integer, j::Integer) -> Int\n\nReturn the number of characters in string s from indices i through j.\n\nThis is computed as the number of code unit indices from i to j which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With i and j arguments it computes the number of indices between i and j inclusive that are valid indices in the string s. In addition to in-bounds values, i may take the out-of-bounds value ncodeunits(s) + 1 and j may take the out-of-bounds value 0.\n\nnote: Note\nThe time complexity of this operation is linear in general. That is, it will take the time proportional to the number of bytes or characters in the string because it counts the value on the fly. This is in contrast to the method for arrays, which is a constant-time operation.\n\nSee also: isvalid, ncodeunits, lastindex, thisind, nextind, prevind\n\nExamples\n\njulia> length(\"jμΛIα\")\n5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.lock-Tuple{Any, Base.AbstractLock}","page":"References","title":"Base.lock","text":"lock(f::Function, lock)\n\nAcquire the lock, execute f with the lock held, and release the lock when f returns. If the lock is already locked by a different task/thread, wait for it to become available.\n\nWhen this function returns, the lock has been released, so the caller should not attempt to unlock it.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.lock-Tuple{ReentrantLock}","page":"References","title":"Base.lock","text":"lock(lock)\n\nAcquire the lock when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.\n\nEach lock must be matched by an unlock.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.lpad","page":"References","title":"Base.lpad","text":"lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -> String\n\nStringify s and pad the resulting string on the left with p to make it n characters (code points) long. If s is already n characters long, an equal string is returned. Pad with spaces by default.\n\nExamples\n\njulia> lpad(\"March\", 10)\n\"     March\"\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.lstrip-Tuple{Any, AbstractString}","page":"References","title":"Base.lstrip","text":"lstrip([pred=isspace,] str::AbstractString) -> SubString\nlstrip(str::AbstractString, chars) -> SubString\n\nRemove leading characters from str, either those specified by chars or those for which the function pred returns true.\n\nThe default behaviour is to remove leading whitespace and delimiters: see isspace for precise details.\n\nThe optional chars argument specifies which characters to remove: it can be a single character, or a vector or set of characters.\n\nExamples\n\njulia> a = lpad(\"March\", 20)\n\"               March\"\n\njulia> lstrip(a)\n\"March\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ltoh-Tuple{Any}","page":"References","title":"Base.ltoh","text":"ltoh(x)\n\nConvert the endianness of a value from Little-endian to that used by the Host.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.macroexpand-Tuple{Module, Any}","page":"References","title":"Base.macroexpand","text":"macroexpand(m::Module, x; recursive=true)\n\nTake the expression x and return an equivalent expression with all macros removed (expanded) for executing in module m. The recursive keyword controls whether deeper levels of nested macros are also expanded. This is demonstrated in the example below:\n\njulia> module M\n           macro m1()\n               42\n           end\n           macro m2()\n               :(@m1())\n           end\n       end\nM\n\njulia> macroexpand(M, :(@m2()), recursive=true)\n42\n\njulia> macroexpand(M, :(@m2()), recursive=false)\n:(#= REPL[16]:6 =# M.@m1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.map!-Tuple{Any, Base.ValueIterator}","page":"References","title":"Base.map!","text":"map!(f, values(dict::AbstractDict))\n\nModifies dict by transforming each value from val to f(val). Note that the type of dict cannot be changed: if f(val) is not an instance of the value type of dict then it will be converted to the value type if possible and otherwise raise an error.\n\ncompat: Julia 1.2\nmap!(f, values(dict::AbstractDict)) requires Julia 1.2 or later.\n\nExamples\n\njulia> d = Dict(:a => 1, :b => 2)\nDict{Symbol, Int64} with 2 entries:\n  :a => 1\n  :b => 2\n\njulia> map!(v -> v-1, values(d))\nValueIterator for a Dict{Symbol, Int64} with 2 entries. Values:\n  0\n  1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.map!-Union{Tuple{F}, Tuple{F, AbstractArray, Vararg{AbstractArray, N} where N}} where F","page":"References","title":"Base.map!","text":"map!(function, destination, collection...)\n\nLike map, but stores the result in destination rather than a new collection. destination must be at least as large as the first collection.\n\nExamples\n\njulia> a = zeros(3);\n\njulia> map!(x -> x * 2, a, [1, 2, 3]);\n\njulia> a\n3-element Vector{Float64}:\n 2.0\n 4.0\n 6.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.map-Tuple{Any, Any}","page":"References","title":"Base.map","text":"map(f, c...) -> collection\n\nTransform collection c by applying f to each element. For multiple collection arguments, apply f elementwise.\n\nSee also: mapslices\n\nExamples\n\njulia> map(x -> x * 2, [1, 2, 3])\n3-element Vector{Int64}:\n 2\n 4\n 6\n\njulia> map(+, [1, 2, 3], [10, 20, 30])\n3-element Vector{Int64}:\n 11\n 22\n 33\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mapfoldl-Tuple{Any, Any, Any}","page":"References","title":"Base.mapfoldl","text":"mapfoldl(f, op, itr; [init])\n\nLike mapreduce, but with guaranteed left associativity, as in foldl. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mapfoldr-Tuple{Any, Any, Any}","page":"References","title":"Base.mapfoldr","text":"mapfoldr(f, op, itr; [init])\n\nLike mapreduce, but with guaranteed right associativity, as in foldr. If provided, the keyword argument init will be used exactly once. In general, it will be necessary to provide init to work with empty collections.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mapreduce-Tuple{Any, Any, Any}","page":"References","title":"Base.mapreduce","text":"mapreduce(f, op, itrs...; [init])\n\nApply function f to each element(s) in itrs, and then reduce the result using the binary function op. If provided, init must be a neutral element for op that will be returned for empty collections. It is unspecified whether init is used for non-empty collections. In general, it will be necessary to provide init to work with empty collections.\n\nmapreduce is functionally equivalent to calling reduce(op, map(f, itr); init=init), but will in general execute faster since no intermediate collection needs to be created. See documentation for reduce and map.\n\ncompat: Julia 1.2\nmapreduce with multiple iterators requires Julia 1.2 or later.\n\nExamples\n\njulia> mapreduce(x->x^2, +, [1:3;]) # == 1 + 4 + 9\n14\n\nThe associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of f for elements that appear multiple times in itr. Use mapfoldl or mapfoldr instead for guaranteed left or right associativity and invocation of f for every value.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mapreduce-Tuple{Any, Any, Union{Base.AbstractBroadcasted, AbstractArray}}","page":"References","title":"Base.mapreduce","text":"mapreduce(f, op, A::AbstractArray...; dims=:, [init])\n\nEvaluates to the same as reduce(op, map(f, A); dims=dims, init=init), but is generally faster because the intermediate array is avoided.\n\ncompat: Julia 1.2\nmapreduce with multiple iterators requires Julia 1.2 or later.\n\nExamples\n\njulia> a = reshape(Vector(1:16), (4,4))\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> mapreduce(isodd, *, a, dims=1)\n1×4 Matrix{Bool}:\n 0  0  0  0\n\njulia> mapreduce(isodd, |, a, dims=1)\n1×4 Matrix{Bool}:\n 1  1  1  1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mapreduce_empty-Tuple{Any, Any, Any}","page":"References","title":"Base.mapreduce_empty","text":"Base.mapreduce_empty(f, op, T)\n\nThe value to be returned when calling mapreduce, mapfoldl or mapfoldr with map f and reduction op over an empty array with element type of T.\n\nIf not defined, this will throw an ArgumentError.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mapreduce_first-Tuple{Any, Any, Any}","page":"References","title":"Base.mapreduce_first","text":"Base.mapreduce_first(f, op, x)\n\nThe value to be returned when calling mapreduce, mapfoldl or mapfoldr with map f and reduction op over an iterator which contains a single element x. This value may also used to initialise the recursion, so that mapreduce(f, op, [x, y]) may call op(reduce_first(op, f, x), f(y)).\n\nThe default is reduce_first(op, f(x)).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mapslices-Tuple{Any, AbstractArray}","page":"References","title":"Base.mapslices","text":"mapslices(f, A; dims)\n\nTransform the given dimensions of array A using function f. f is called on each slice of A of the form A[...,:,...,:,...]. dims is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if dims is [1,2] and A is 4-dimensional, f is called on A[:,:,i,j] for all i and j.\n\nExamples\n\njulia> a = reshape(Vector(1:16),(2,2,2,2))\n2×2×2×2 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> mapslices(sum, a, dims = [1,2])\n1×1×2×2 Array{Int64, 4}:\n[:, :, 1, 1] =\n 10\n\n[:, :, 2, 1] =\n 26\n\n[:, :, 1, 2] =\n 42\n\n[:, :, 2, 2] =\n 58\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mark-Tuple{IO}","page":"References","title":"Base.mark","text":"mark(s)\n\nAdd a mark at the current position of stream s. Return the marked position.\n\nSee also unmark, reset, ismarked.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.match","page":"References","title":"Base.match","text":"match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])\n\nSearch for the first match of the regular expression r in s and return a RegexMatch object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing m.match and the captured sequences can be retrieved by accessing m.captures The optional idx argument specifies an index at which to start the search.\n\nExamples\n\njulia> rx = r\"a(.)a\"\nr\"a(.)a\"\n\njulia> m = match(rx, \"cabac\")\nRegexMatch(\"aba\", 1=\"b\")\n\njulia> m.captures\n1-element Vector{Union{Nothing, SubString{String}}}:\n \"b\"\n\njulia> m.match\n\"aba\"\n\njulia> match(rx, \"cabac\", 3) === nothing\ntrue\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.max-Tuple{Any, Any}","page":"References","title":"Base.max","text":"max(x, y, ...)\n\nReturn the maximum of the arguments. See also the maximum function to take the maximum element from a collection.\n\nExamples\n\njulia> max(2, 5, 1)\n5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.maximum!-Tuple{Any, Any}","page":"References","title":"Base.maximum!","text":"maximum!(r, A)\n\nCompute the maximum value of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> maximum!([1; 1], A)\n2-element Vector{Int64}:\n 2\n 4\n\njulia> maximum!([1 1], A)\n1×2 Matrix{Int64}:\n 3  4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.maximum-Tuple{AbstractArray}","page":"References","title":"Base.maximum","text":"maximum(A::AbstractArray; dims)\n\nCompute the maximum value of an array over the given dimensions. See also the max(a,b) function to take the maximum of two or more arguments, which can be applied elementwise to arrays via max.(a,b).\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> maximum(A, dims=1)\n1×2 Matrix{Int64}:\n 3  4\n\njulia> maximum(A, dims=2)\n2×1 Matrix{Int64}:\n 2\n 4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.maximum-Tuple{Any, AbstractArray}","page":"References","title":"Base.maximum","text":"maximum(f, A::AbstractArray; dims)\n\nCompute the maximum value from of calling the function f on each element of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> maximum(abs2, A, dims=1)\n1×2 Matrix{Int64}:\n 9  16\n\njulia> maximum(abs2, A, dims=2)\n2×1 Matrix{Int64}:\n  4\n 16\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.maximum-Tuple{Any, Any}","page":"References","title":"Base.maximum","text":"maximum(f, itr; [init])\n\nReturns the largest result of calling function f on each element of itr.\n\nThe value returned for empty itr can be specified by init. It must be a neutral element for max (i.e. which is less than or equal to any other element) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> maximum(length, [\"Julion\", \"Julia\", \"Jule\"])\n6\n\njulia> maximum(length, []; init=-1)\n-1\n\njulia> maximum(sin, Real[]; init=-1.0)  # good, since output of sin is >= -1\n-1.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.maximum-Tuple{Any}","page":"References","title":"Base.maximum","text":"maximum(itr; [init])\n\nReturns the largest element in a collection.\n\nThe value returned for empty itr can be specified by init. It must be a neutral element for max (i.e. which is less than or equal to any other element) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> maximum(-20.5:10)\n9.5\n\njulia> maximum([1,2,3])\n3\n\njulia> maximum(())\nERROR: ArgumentError: reducing over an empty collection is not allowed\nStacktrace:\n[...]\n\njulia> maximum((); init=-Inf)\n-Inf\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.maxintfloat-Tuple{Type{Float64}}","page":"References","title":"Base.maxintfloat","text":"maxintfloat(T=Float64)\n\nThe largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type T (which defaults to Float64).\n\nThat is, maxintfloat returns the smallest positive integer-valued floating-point number n such that n+1 is not exactly representable in the type T.\n\nWhen an Integer-type value is needed, use Integer(maxintfloat(T)).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.maxintfloat-Union{Tuple{T}, Tuple{S}, Tuple{Type{S}, Type{T}}} where {S<:AbstractFloat, T<:Integer}","page":"References","title":"Base.maxintfloat","text":"maxintfloat(T, S)\n\nThe largest consecutive integer representable in the given floating-point type T that also does not exceed the maximum integer representable by the integer type S.  Equivalently, it is the minimum of maxintfloat(T) and typemax(S).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.may_invoke_generator-Tuple{Core.MethodInstance}","page":"References","title":"Base.may_invoke_generator","text":"may_invoke_generator(method, atypes, sparams)\n\nComputes whether or not we may invoke the generator for the given method on the given atypes and sparams. For correctness, all generated function are required to return monotonic answers. However, since we don't expect users to be able to successfully implement this criterion, we only call generated functions on concrete types. The one exception to this is that we allow calling generators with abstract types if the generator does not use said abstract type (and thus cannot incorrectly use it to break monotonicity). This function computes whether we are in either of these cases.\n\nUnlike normal functions, the compilation heuristics still can't generate good dispatch in some cases, but this may still allow inference not to fall over in some limited cases.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.merge!-Tuple{AbstractDict, Vararg{AbstractDict, N} where N}","page":"References","title":"Base.merge!","text":"merge!(d::AbstractDict, others::AbstractDict...)\n\nUpdate collection with pairs from the other collections. See also merge.\n\nExamples\n\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> merge!(d1, d2);\n\njulia> d1\nDict{Int64, Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.merge-Tuple{AbstractDict, Vararg{AbstractDict, N} where N}","page":"References","title":"Base.merge","text":"merge(d::AbstractDict, others::AbstractDict...)\n\nConstruct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed. See also mergewith for custom handling of values with the same key.\n\nExamples\n\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String, Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String, Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> merge(a, b)\nDict{String, Float64} with 3 entries:\n  \"bar\" => 4711.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\njulia> merge(b, a)\nDict{String, Float64} with 3 entries:\n  \"bar\" => 42.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.merge-Tuple{NamedTuple, Any}","page":"References","title":"Base.merge","text":"merge(a::NamedTuple, iterable)\n\nInterpret an iterable of key-value pairs as a named tuple, and perform a merge.\n\njulia> merge((a=1, b=2, c=3), [:b=>4, :d=>5])\n(a = 1, b = 4, c = 3, d = 5)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.merge-Union{Tuple{bn}, Tuple{an}, Tuple{NamedTuple{an, T} where T<:Tuple, NamedTuple{bn, T} where T<:Tuple}} where {an, bn}","page":"References","title":"Base.merge","text":"merge(a::NamedTuple, bs::NamedTuple...)\n\nConstruct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields present in both the leftmost and rightmost named tuples take the same position as they are found in the leftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that contains that field. Fields present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented for when only a single named tuple is supplied, with signature merge(a::NamedTuple).\n\ncompat: Julia 1.1\nMerging 3 or more NamedTuple requires at least Julia 1.1.\n\nExamples\n\njulia> merge((a=1, b=2, c=3), (b=4, d=5))\n(a = 1, b = 4, c = 3, d = 5)\n\njulia> merge((a=1, b=2), (b=3, c=(d=1,)), (c=(d=2,),))\n(a = 1, b = 3, c = (d = 2,))\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mergewith!-Tuple{Any, AbstractDict, Vararg{AbstractDict, N} where N}","page":"References","title":"Base.mergewith!","text":"mergewith!(combine, d::AbstractDict, others::AbstractDict...) -> d\nmergewith!(combine)\nmerge!(combine, d::AbstractDict, others::AbstractDict...) -> d\n\nUpdate collection with pairs from the other collections. Values with the same key will be combined using the combiner function.  The curried form mergewith!(combine) returns the function (args...) -> mergewith!(combine, args...).\n\nMethod merge!(combine::Union{Function,Type}, args...) as an alias of mergewith!(combine, args...) is still available for backward compatibility.\n\ncompat: Julia 1.5\nmergewith! requires Julia 1.5 or later.\n\nExamples\n\njulia> d1 = Dict(1 => 2, 3 => 4);\n\njulia> d2 = Dict(1 => 4, 4 => 5);\n\njulia> mergewith!(+, d1, d2);\n\njulia> d1\nDict{Int64, Int64} with 3 entries:\n  4 => 5\n  3 => 4\n  1 => 6\n\njulia> mergewith!(-, d1, d1);\n\njulia> d1\nDict{Int64, Int64} with 3 entries:\n  4 => 0\n  3 => 0\n  1 => 0\n\njulia> foldl(mergewith!(+), [d1, d2]; init=Dict{Int64, Int64}())\nDict{Int64, Int64} with 3 entries:\n  4 => 5\n  3 => 0\n  1 => 4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mergewith-Tuple{Any, AbstractDict, Vararg{AbstractDict, N} where N}","page":"References","title":"Base.mergewith","text":"mergewith(combine, d::AbstractDict, others::AbstractDict...)\nmergewith(combine)\nmerge(combine, d::AbstractDict, others::AbstractDict...)\n\nConstruct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.  The curried form mergewith(combine) returns the function (args...) -> mergewith(combine, args...).\n\nMethod merge(combine::Union{Function,Type}, args...) as an alias of mergewith(combine, args...) is still available for backward compatibility.\n\ncompat: Julia 1.5\nmergewith requires Julia 1.5 or later.\n\nExamples\n\njulia> a = Dict(\"foo\" => 0.0, \"bar\" => 42.0)\nDict{String, Float64} with 2 entries:\n  \"bar\" => 42.0\n  \"foo\" => 0.0\n\njulia> b = Dict(\"baz\" => 17, \"bar\" => 4711)\nDict{String, Int64} with 2 entries:\n  \"bar\" => 4711\n  \"baz\" => 17\n\njulia> mergewith(+, a, b)\nDict{String, Float64} with 3 entries:\n  \"bar\" => 4753.0\n  \"baz\" => 17.0\n  \"foo\" => 0.0\n\njulia> ans == mergewith(+)(a, b)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.methods","page":"References","title":"Base.methods","text":"methods(f, [types], [module])\n\nReturn the method table for f.\n\nIf types is specified, return an array of methods whose types match. If module is specified, return an array of methods defined in that module. A list of modules can also be specified as an array.\n\ncompat: Julia 1.4\nAt least Julia 1.4 is required for specifying a module.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.mightalias-Tuple{AbstractArray, AbstractArray}","page":"References","title":"Base.mightalias","text":"Base.mightalias(A::AbstractArray, B::AbstractArray)\n\nPerform a conservative test to check if arrays A and B might share the same memory.\n\nBy default, this simply checks if either of the arrays reference the same memory regions, as identified by their Base.dataids.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.min-Tuple{Any, Any}","page":"References","title":"Base.min","text":"min(x, y, ...)\n\nReturn the minimum of the arguments. See also the minimum function to take the minimum element from a collection.\n\nExamples\n\njulia> min(2, 5, 1)\n1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.minimum!-Tuple{Any, Any}","page":"References","title":"Base.minimum!","text":"minimum!(r, A)\n\nCompute the minimum value of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> minimum!([1; 1], A)\n2-element Vector{Int64}:\n 1\n 3\n\njulia> minimum!([1 1], A)\n1×2 Matrix{Int64}:\n 1  2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.minimum-Tuple{AbstractArray}","page":"References","title":"Base.minimum","text":"minimum(A::AbstractArray; dims)\n\nCompute the minimum value of an array over the given dimensions. See also the min(a,b) function to take the minimum of two or more arguments, which can be applied elementwise to arrays via min.(a,b).\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> minimum(A, dims=1)\n1×2 Matrix{Int64}:\n 1  2\n\njulia> minimum(A, dims=2)\n2×1 Matrix{Int64}:\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.minimum-Tuple{Any, AbstractArray}","page":"References","title":"Base.minimum","text":"minimum(f, A::AbstractArray; dims)\n\nCompute the minimum value from of calling the function f on each element of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> minimum(abs2, A, dims=1)\n1×2 Matrix{Int64}:\n 1  4\n\njulia> minimum(abs2, A, dims=2)\n2×1 Matrix{Int64}:\n 1\n 9\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.minimum-Tuple{Any, Any}","page":"References","title":"Base.minimum","text":"minimum(f, itr; [init])\n\nReturns the smallest result of calling function f on each element of itr.\n\nThe value returned for empty itr can be specified by init. It must be a neutral element for min (i.e. which is greater than or equal to any other element) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> minimum(length, [\"Julion\", \"Julia\", \"Jule\"])\n4\n\njulia> minimum(length, []; init=typemax(Int64))\n9223372036854775807\n\njulia> minimum(sin, Real[]; init=1.0)  # good, since output of sin is <= 1\n1.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.minimum-Tuple{Any}","page":"References","title":"Base.minimum","text":"minimum(itr; [init])\n\nReturns the smallest element in a collection.\n\nThe value returned for empty itr can be specified by init. It must be a neutral element for min (i.e. which is greater than or equal to any other element) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> minimum(-20.5:10)\n-20.5\n\njulia> minimum([1,2,3])\n1\n\njulia> minimum([])\nERROR: ArgumentError: reducing over an empty collection is not allowed\nStacktrace:\n[...]\n\njulia> minimum([]; init=Inf)\nInf\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.minmax-Tuple{Any, Any}","page":"References","title":"Base.minmax","text":"minmax(x, y)\n\nReturn (min(x,y), max(x,y)). See also: extrema that returns (minimum(x), maximum(x)).\n\nExamples\n\njulia> minmax('c','b')\n('b', 'c')\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mod-Tuple{Integer, Base.OneTo}","page":"References","title":"Base.mod","text":"mod(x::Integer, r::AbstractUnitRange)\n\nFind y in the range r such that x  y (mod n), where n = length(r), i.e. y = mod(x - first(r), n) + first(r).\n\nSee also: mod1.\n\nExamples\n\njulia> mod(0, Base.OneTo(3))\n3\n\njulia> mod(3, 0:2)\n0\n\ncompat: Julia 1.3\nThis method requires at least Julia 1.3.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mod-Tuple{Integer, Type{var\"#s832\"} where var\"#s832\"<:Integer}","page":"References","title":"Base.mod","text":"rem(x::Integer, T::Type{<:Integer}) -> T\nmod(x::Integer, T::Type{<:Integer}) -> T\n%(x::Integer, T::Type{<:Integer}) -> T\n\nFind y::T such that x ≡ y (mod n), where n is the number of integers representable in T, and y is an integer in [typemin(T),typemax(T)]. If T can represent any integer (e.g. T == BigInt), then this operation corresponds to a conversion to T.\n\nExamples\n\njulia> 129 % Int8\n-127\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mod-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"References","title":"Base.mod","text":"mod(x, y)\nrem(x, y, RoundDown)\n\nThe reduction of x modulo y, or equivalently, the remainder of x after floored division by y, i.e. x - y*fld(x,y) if computed without intermediate rounding.\n\nThe result will have the same sign as y, and magnitude less than abs(y) (with some exceptions, see note below).\n\nnote: Note\nWhen used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to y, then it may be rounded to y.\n\njulia> mod(8, 3)\n2\n\njulia> mod(9, 3)\n0\n\njulia> mod(8.9, 3)\n2.9000000000000004\n\njulia> mod(eps(), 3)\n2.220446049250313e-16\n\njulia> mod(-eps(), 3)\n3.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mod1-Union{Tuple{T}, Tuple{T, T}} where T<:Real","page":"References","title":"Base.mod1","text":"mod1(x, y)\n\nModulus after flooring division, returning a value r such that mod(r, y) == mod(x, y) in the range (0 y for positive y and in the range y0) for negative y.\n\nSee also: fld1, fldmod1.\n\nExamples\n\njulia> mod1(4, 2)\n2\n\njulia> mod1(4, 3)\n1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.moduleroot-Tuple{Module}","page":"References","title":"Base.moduleroot","text":"moduleroot(m::Module) -> Module\n\nFind the root module of a given module. This is the first module in the chain of parent modules of m which is either a registered root module or which is its own parent module.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mul12-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","page":"References","title":"Base.mul12","text":"zhi, zlo = mul12(x, y)\n\nA high-precision representation of x * y for floating-point numbers. Mathematically, zhi + zlo = x * y, where zhi contains the most significant bits and zlo the least significant.\n\nExample:\n\njulia> x = Float32(π)\n3.1415927f0\n\njulia> x * x\n9.869605f0\n\njulia> Float64(x) * Float64(x)\n9.869604950382893\n\njulia> hi, lo = Base.mul12(x, x)\n(9.869605f0, -1.140092f-7)\n\njulia> Float64(hi) + Float64(lo)\n9.869604950382893\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.mul_prod-Tuple{Any, Any}","page":"References","title":"Base.mul_prod","text":"Base.mul_prod(x, y)\n\nThe reduction operator used in prod. The main difference from * is that small integers are promoted to Int/UInt.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.nameof-Tuple{DataType}","page":"References","title":"Base.nameof","text":"nameof(t::DataType) -> Symbol\n\nGet the name of a (potentially UnionAll-wrapped) DataType (without its parent module) as a symbol.\n\nExamples\n\njulia> module Foo\n           struct S{T}\n           end\n       end\nFoo\n\njulia> nameof(Foo.S{T} where T)\n:S\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.nameof-Tuple{Function}","page":"References","title":"Base.nameof","text":"nameof(f::Function) -> Symbol\n\nGet the name of a generic Function as a symbol. For anonymous functions, this is a compiler-generated name. For explicitly-declared subtypes of Function, it is the name of the function's type.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.nameof-Tuple{Module}","page":"References","title":"Base.nameof","text":"nameof(m::Module) -> Symbol\n\nGet the name of a Module as a Symbol.\n\nExamples\n\njulia> nameof(Base.Broadcast)\n:Broadcast\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.names-Tuple{Module}","page":"References","title":"Base.names","text":"names(x::Module; all::Bool = false, imported::Bool = false)\n\nGet an array of the names exported by a Module, excluding deprecated names. If all is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If imported is true, then names explicitly imported from other modules are also included.\n\nAs a special case, all names defined in Main are considered \"exported\", since it is not idiomatic to explicitly export names from Main.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ncodeunits-Tuple{AbstractString}","page":"References","title":"Base.ncodeunits","text":"ncodeunits(s::AbstractString) -> Int\n\nReturn the number of code units in a string. Indices that are in bounds to access this string must satisfy 1 ≤ i ≤ ncodeunits(s). Not all such indices are valid – they may not be the start of a character, but they will return a code unit value when calling codeunit(s,i).\n\nExamples\n\njulia> ncodeunits(\"The Julia Language\")\n18\n\njulia> ncodeunits(\"∫eˣ\")\n6\n\njulia> ncodeunits('∫'), ncodeunits('e'), ncodeunits('ˣ')\n(3, 1, 2)\n\nSee also: codeunit, checkbounds, sizeof, length, lastindex\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ncodeunits-Tuple{Char}","page":"References","title":"Base.ncodeunits","text":"ncodeunits(c::Char) -> Int\n\nReturn the number of code units required to encode a character as UTF-8. This is the number of bytes which will be printed if the character is written to an output stream, or ncodeunits(string(c)) but computed efficiently.\n\ncompat: Julia 1.1\nThis method requires at least Julia 1.1. In Julia 1.0 consider using ncodeunits(string(c)).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ndigits-Tuple{Integer}","page":"References","title":"Base.ndigits","text":"ndigits(n::Integer; base::Integer=10, pad::Integer=1)\n\nCompute the number of digits in integer n written in base base (base must not be in [-1, 0, 1]), optionally padded with zeros to a specified size (the result will never be less than pad).\n\nExamples\n\njulia> ndigits(12345)\n5\n\njulia> ndigits(1022, base=16)\n3\n\njulia> string(1022, base=16)\n\"3fe\"\n\njulia> ndigits(123, pad=5)\n5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ndigits0z-Tuple{Integer, Integer}","page":"References","title":"Base.ndigits0z","text":"ndigits0z(n::Integer, b::Integer=10)\n\nReturn 0 if n == 0, otherwise compute the number of digits in integer n written in base b (i.e. equal to ndigits(n, base=b) in this case). The base b must not be in [-1, 0, 1].\n\nExamples\n\njulia> Base.ndigits0z(0, 16)\n0\n\njulia> Base.ndigits(0, base=16)\n1\n\njulia> Base.ndigits0z(0)\n0\n\njulia> Base.ndigits0z(10, 2)\n4\n\njulia> Base.ndigits0z(10)\n2\n\nSee also ndigits.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ndims-Union{Tuple{AbstractArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}","page":"References","title":"Base.ndims","text":"ndims(A::AbstractArray) -> Integer\n\nReturn the number of dimensions of A.\n\nExamples\n\njulia> A = fill(1, (3,4,5));\n\njulia> ndims(A)\n3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.nextfloat-Tuple{AbstractFloat}","page":"References","title":"Base.nextfloat","text":"nextfloat(x::AbstractFloat)\n\nReturn the smallest floating point number y of the same type as x such x < y. If no such y exists (e.g. if x is Inf or NaN), then return x.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.nextfloat-Tuple{Union{Float16, Float32, Float64}, Integer}","page":"References","title":"Base.nextfloat","text":"nextfloat(x::AbstractFloat, n::Integer)\n\nThe result of n iterative applications of nextfloat to x if n >= 0, or -n applications of prevfloat if n < 0.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.nextind-Tuple{AbstractString, Integer, Integer}","page":"References","title":"Base.nextind","text":"nextind(str::AbstractString, i::Integer, n::Integer=1) -> Int\n\nCase n == 1\nIf i is in bounds in s return the index of the start of the character whose encoding starts after index i. In other words, if i is the start of a character, return the start of the next character; if i is not the start of a character, move forward until the start of a character and return that index. If i is equal to 0 return 1. If i is in bounds but greater or equal to lastindex(str) return ncodeunits(str)+1. Otherwise throw BoundsError.\nCase n > 1\nBehaves like applying n times nextind for n==1. The only difference is that if n is so large that applying nextind would reach ncodeunits(str)+1 then each remaining iteration increases the returned value by 1. This means that in this case nextind can return a value greater than ncodeunits(str)+1.\nCase n == 0\nReturn i only if i is a valid index in s or is equal to 0. Otherwise StringIndexError or BoundsError is thrown.\n\nExamples\n\njulia> nextind(\"α\", 0)\n1\n\njulia> nextind(\"α\", 1)\n3\n\njulia> nextind(\"α\", 3)\nERROR: BoundsError: attempt to access 2-codeunit String at index [3]\n[...]\n\njulia> nextind(\"α\", 0, 2)\n3\n\njulia> nextind(\"α\", 1, 2)\n4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.nextpow-Tuple{Real, Real}","page":"References","title":"Base.nextpow","text":"nextpow(a, x)\n\nThe smallest a^n not less than x, where n is a non-negative integer. a must be greater than 1, and x must be greater than 0.\n\nExamples\n\njulia> nextpow(2, 7)\n8\n\njulia> nextpow(2, 9)\n16\n\njulia> nextpow(5, 20)\n25\n\njulia> nextpow(4, 16)\n16\n\nSee also prevpow.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.nextprod-Tuple{Union{Tuple{Vararg{Integer, N} where N}, AbstractVector{var\"#s831\"} where var\"#s831\"<:Integer}, Real}","page":"References","title":"Base.nextprod","text":"nextprod(factors::Union{Tuple,AbstractVector}, n)\n\nNext integer greater than or equal to n that can be written as prod k_i^p_i for integers p_1, p_2, etcetera, for factors k_i in factors.\n\nExamples\n\njulia> nextprod((2, 3), 105)\n108\n\njulia> 2^2 * 3^3\n108\n\ncompat: Julia 1.6\nThe method that accepts a tuple requires Julia 1.6 or later.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.nonmissingtype-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Base.nonmissingtype","text":"nonmissingtype(T::Type)\n\nIf T is a union of types containing Missing, return a new type with Missing removed.\n\nExamples\n\njulia> nonmissingtype(Union{Int64,Missing})\nInt64\n\njulia> nonmissingtype(Any)\nAny\n\ncompat: Julia 1.3\nThis function is exported as of Julia 1.3.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.notify-Tuple{Base.GenericCondition, Any}","page":"References","title":"Base.notify","text":"notify(condition, val=nothing; all=true, error=false)\n\nWake up tasks waiting for a condition, passing them val. If all is true (the default), all waiting tasks are woken, otherwise only one is. If error is true, the passed value is raised as an exception in the woken tasks.\n\nReturn the count of tasks woken up. Return 0 if no tasks are waiting on condition.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.notnothing-Tuple{Any}","page":"References","title":"Base.notnothing","text":"notnothing(x)\n\nThrow an error if x === nothing, and return x if not.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ntoh-Tuple{Any}","page":"References","title":"Base.ntoh","text":"ntoh(x)\n\nConvert the endianness of a value from Network byte order (big-endian) to that used by the Host.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ntuple-Union{Tuple{F}, Tuple{F, Integer}} where F","page":"References","title":"Base.ntuple","text":"ntuple(f::Function, n::Integer)\n\nCreate a tuple of length n, computing each element as f(i), where i is the index of the element.\n\nExamples\n\njulia> ntuple(i -> 2*i, 4)\n(2, 4, 6, 8)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ntuple-Union{Tuple{N}, Tuple{F}, Tuple{F, Val{N}}} where {F, N}","page":"References","title":"Base.ntuple","text":"ntuple(f, ::Val{N})\n\nCreate a tuple of length N, computing each element as f(i), where i is the index of the element. By taking a Val(N) argument, it is possible that this version of ntuple may generate more efficient code than the version taking the length as an integer. But ntuple(f, N) is preferable to ntuple(f, Val(N)) in cases where N cannot be determined at compile time.\n\nExamples\n\njulia> ntuple(i -> 2*i, Val(4))\n(2, 4, 6, 8)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.numerator-Tuple{Integer}","page":"References","title":"Base.numerator","text":"numerator(x)\n\nNumerator of the rational representation of x.\n\nExamples\n\njulia> numerator(2//3)\n2\n\njulia> numerator(4)\n4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.objectid-Tuple{Any}","page":"References","title":"Base.objectid","text":"objectid(x) -> UInt\n\nGet a hash value for x based on object identity. objectid(x)==objectid(y) if x === y.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.occursin-Tuple{Any}","page":"References","title":"Base.occursin","text":"occursin(haystack)\n\nCreate a function that checks whether its argument occurs in haystack, i.e. a function equivalent to needle -> occursin(needle, haystack).\n\nThe returned function is of type Base.Fix2{typeof(occursin)}.\n\ncompat: Julia 1.6\nThis method requires Julia 1.6 or later.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.occursin-Tuple{Union{AbstractChar, AbstractString}, AbstractString}","page":"References","title":"Base.occursin","text":"occursin(needle::Union{AbstractString,AbstractPattern,AbstractChar}, haystack::AbstractString)\n\nDetermine whether the first argument is a substring of the second. If needle is a regular expression, checks whether haystack contains a match.\n\nExamples\n\njulia> occursin(\"Julia\", \"JuliaLang is pretty cool!\")\ntrue\n\njulia> occursin('a', \"JuliaLang is pretty cool!\")\ntrue\n\njulia> occursin(r\"a.a\", \"aba\")\ntrue\n\njulia> occursin(r\"a.a\", \"abba\")\nfalse\n\nSee also: contains.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.oftype-Tuple{Any, Any}","page":"References","title":"Base.oftype","text":"oftype(x, y)\n\nConvert y to the type of x (convert(typeof(x), y)).\n\nExamples\n\njulia> x = 4;\n\njulia> y = 3.;\n\njulia> oftype(x, y)\n3\n\njulia> oftype(y, x)\n4.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.one-Union{Tuple{Type{T}}, Tuple{T}} where T<:Number","page":"References","title":"Base.one","text":"one(x)\none(T::type)\n\nReturn a multiplicative identity for x: a value such that one(x)*x == x*one(x) == x.  Alternatively one(T) can take a type T, in which case one returns a multiplicative identity for any x of type T.\n\nIf possible, one(x) returns a value of the same type as x, and one(T) returns a value of type T.  However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless.  In that case, one(x) should return an identity value of the same precision (and shape, for matrices) as x.\n\nIf you want a quantity that is of the same type as x, or of type T, even if x is dimensionful, use oneunit instead.\n\nExamples\n\njulia> one(3.7)\n1.0\n\njulia> one(Int)\n1\n\njulia> import Dates; one(Dates.Day(1))\n1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.ones","page":"References","title":"Base.ones","text":"ones([T=Float64,] dims::Tuple)\nones([T=Float64,] dims...)\n\nCreate an Array, with element type T, of all ones with size specified by dims. See also: fill, zeros.\n\nExamples\n\njulia> ones(1,2)\n1×2 Matrix{Float64}:\n 1.0  1.0\n\njulia> ones(ComplexF64, 2, 3)\n2×3 Matrix{ComplexF64}:\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.oneunit-Tuple{T} where T","page":"References","title":"Base.oneunit","text":"oneunit(x::T)\noneunit(T::Type)\n\nReturns T(one(x)), where T is either the type of the argument or (if a type is passed) the argument.  This differs from one for dimensionful quantities: one is dimensionless (a multiplicative identity) while oneunit is dimensionful (of the same type as x, or of type T).\n\nExamples\n\njulia> oneunit(3.7)\n1.0\n\njulia> import Dates; oneunit(Dates.Day)\n1 day\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.open","page":"References","title":"Base.open","text":"open(command, stdio=devnull; write::Bool = false, read::Bool = !write)\n\nStart running command asynchronously, and return a process::IO object.  If read is true, then reads from the process come from the process's standard output and stdio optionally specifies the process's standard input stream.  If write is true, then writes go to the process's standard input and stdio optionally specifies the process's standard output stream. The process's standard error stream is connected to the current global stderr.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.open-2","page":"References","title":"Base.open","text":"open(command, mode::AbstractString, stdio=devnull)\n\nRun command asynchronously. Like open(command, stdio; read, write) except specifying the read and write flags via a mode string instead of keyword arguments. Possible mode strings are:\n\nMode Description Keywords\nr read none\nw write write = true\nr+ read, write read = true, write = true\nw+ read, write read = true, write = true\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.open-Tuple{AbstractString, AbstractString}","page":"References","title":"Base.open","text":"open(filename::AbstractString, [mode::AbstractString]; lock = true) -> IOStream\n\nAlternate syntax for open, where a string-based mode specifier is used instead of the five booleans. The values of mode correspond to those from fopen(3) or Perl open, and are equivalent to setting the following boolean groups:\n\nMode Description Keywords\nr read none\nw write, create, truncate write = true\na write, create, append append = true\nr+ read, write read = true, write = true\nw+ read, write, create, truncate truncate = true, read = true\na+ read, write, create, append append = true, read = true\n\nThe lock keyword argument controls whether operations will be locked for safe multi-threaded access.\n\nExamples\n\njulia> io = open(\"myfile.txt\", \"w\");\n\njulia> write(io, \"Hello world!\");\n\njulia> close(io);\n\njulia> io = open(\"myfile.txt\", \"r\");\n\njulia> read(io, String)\n\"Hello world!\"\n\njulia> write(io, \"This file is read only\")\nERROR: ArgumentError: write failed, IOStream is not writeable\n[...]\n\njulia> close(io)\n\njulia> io = open(\"myfile.txt\", \"a\");\n\njulia> write(io, \"This stream is not read only\")\n28\n\njulia> close(io)\n\njulia> rm(\"myfile.txt\")\n\ncompat: Julia 1.5\nThe lock argument is available as of Julia 1.5.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.open-Tuple{AbstractString}","page":"References","title":"Base.open","text":"open(filename::AbstractString; lock = true, keywords...) -> IOStream\n\nOpen a file in a mode specified by five boolean keyword arguments:\n\nKeyword Description Default\nread open for reading !write\nwrite open for writing truncate | append\ncreate create if non-existent !read & write | truncate | append\ntruncate truncate to zero size !read & write\nappend seek to end false\n\nThe default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.\n\nThe lock keyword argument controls whether operations will be locked for safe multi-threaded access.\n\ncompat: Julia 1.5\nThe lock argument is available as of Julia 1.5.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.open-Tuple{Function, Base.AbstractCmd, Vararg{Any, N} where N}","page":"References","title":"Base.open","text":"open(f::Function, command, args...; kwargs...)\n\nSimilar to open(command, args...; kwargs...), but calls f(stream) on the resulting process stream, then closes the input stream and waits for the process to complete. Returns the value returned by f.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.open-Tuple{Function, Vararg{Any, N} where N}","page":"References","title":"Base.open","text":"open(f::Function, args...; kwargs....)\n\nApply the function f to the result of open(args...; kwargs...) and close the resulting file descriptor upon completion.\n\nExamples\n\njulia> open(\"myfile.txt\", \"w\") do io\n           write(io, \"Hello world!\")\n       end;\n\njulia> open(f->read(f, String), \"myfile.txt\")\n\"Hello world!\"\n\njulia> rm(\"myfile.txt\")\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.open-Tuple{RawFD}","page":"References","title":"Base.open","text":"open(fd::OS_HANDLE) -> IO\n\nTake a raw file descriptor wrap it in a Julia-aware IO type, and take ownership of the fd handle. Call open(Libc.dup(fd)) to avoid the ownership capture of the original handle.\n\nwarning: Warning\nDo not call this on a handle that's already owned by some other part of the system.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.open_flags-Tuple{}","page":"References","title":"Base.open_flags","text":"open_flags(; keywords...) -> NamedTuple\n\nCompute the read, write, create, truncate, append flag value for a given set of keyword arguments to open a NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.operator_associativity-Tuple{Symbol}","page":"References","title":"Base.operator_associativity","text":"operator_associativity(s::Symbol)\n\nReturn a symbol representing the associativity of operator s. Left- and right-associative operators return :left and :right, respectively. Return :none if s is non-associative or an invalid operator.\n\nExamples\n\njulia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)\n(:left, :none, :right)\n\njulia> Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)\n(:left, :none, :right)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.operator_precedence-Tuple{Symbol}","page":"References","title":"Base.operator_precedence","text":"operator_precedence(s::Symbol)\n\nReturn an integer representing the precedence of operator s, relative to other operators. Higher-numbered operators take precedence over lower-numbered operators. Return 0 if s is not a valid operator.\n\nExamples\n\njulia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)\n(11, 12, 17)\n\njulia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)\n(0, 1, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.padding-Tuple{Any}","page":"References","title":"Base.padding","text":"Compute the location of padding in a type.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.pairs-Tuple{Any}","page":"References","title":"Base.pairs","text":"pairs(collection)\n\nReturn an iterator over key => value pairs for any collection that maps a set of keys to a set of values. This includes arrays, where the keys are the array indices.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.parent-Tuple{AbstractArray}","page":"References","title":"Base.parent","text":"parent(A)\n\nReturn the underlying \"parent array”. This parent array of objects of types SubArray, ReshapedArray or LinearAlgebra.Transpose is what was passed as an argument to view, reshape, transpose, etc. during object creation. If the input is not a wrapped object, return the input itself.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> V = view(A, 1:2, :)\n2×2 view(::Matrix{Int64}, 1:2, :) with eltype Int64:\n 1  2\n 3  4\n\njulia> parent(V)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.parentindices-Tuple{AbstractArray}","page":"References","title":"Base.parentindices","text":"parentindices(A)\n\nReturn the indices in the parent which correspond to the array view A.\n\nExamples\n\njulia> A = [1 2; 3 4];\n\njulia> V = view(A, 1, :)\n2-element view(::Matrix{Int64}, 1, :) with eltype Int64:\n 1\n 2\n\njulia> parentindices(V)\n(1, Base.Slice(Base.OneTo(2)))\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.parentmodule-Tuple{Any, Any}","page":"References","title":"Base.parentmodule","text":"parentmodule(f::Function, types) -> Module\n\nDetermine the module containing a given definition of a generic function.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.parentmodule-Tuple{DataType}","page":"References","title":"Base.parentmodule","text":"parentmodule(t::DataType) -> Module\n\nDetermine the module containing the definition of a (potentially UnionAll-wrapped) DataType.\n\nExamples\n\njulia> module Foo\n           struct Int end\n       end\nFoo\n\njulia> parentmodule(Int)\nCore\n\njulia> parentmodule(Foo.Int)\nFoo\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.parentmodule-Tuple{Function}","page":"References","title":"Base.parentmodule","text":"parentmodule(f::Function) -> Module\n\nDetermine the module containing the (first) definition of a generic function.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.parentmodule-Tuple{Module}","page":"References","title":"Base.parentmodule","text":"parentmodule(m::Module) -> Module\n\nGet a module's enclosing Module. Main is its own parent.\n\nExamples\n\njulia> parentmodule(Main)\nMain\n\njulia> parentmodule(Base.Broadcast)\nBase\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.parse-Tuple{Type, Any}","page":"References","title":"Base.parse","text":"parse(type, str; base)\n\nParse a string as a number. For Integer types, a base can be specified (the default is 10). For floating-point types, the string is parsed as a decimal floating-point number.  Complex types are parsed from decimal strings of the form \"R±Iim\" as a Complex(R,I) of the requested type; \"i\" or \"j\" can also be used instead of \"im\", and \"R\" or \"Iim\" are also permitted. If the string does not contain a valid number, an error is raised.\n\ncompat: Julia 1.1\nparse(Bool, str) requires at least Julia 1.1.\n\nExamples\n\njulia> parse(Int, \"1234\")\n1234\n\njulia> parse(Int, \"1234\", base = 5)\n194\n\njulia> parse(Int, \"afc\", base = 16)\n2812\n\njulia> parse(Float64, \"1.2e-3\")\n0.0012\n\njulia> parse(Complex{Float64}, \"3.2e-1 + 4.5im\")\n0.32 + 4.5im\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.pathof-Tuple{Module}","page":"References","title":"Base.pathof","text":"pathof(m::Module)\n\nReturn the path of the m.jl file that was used to import module m, or nothing if m was not imported from a package.\n\nUse dirname to get the directory part and basename to get the file name part of the path.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.peek","page":"References","title":"Base.peek","text":"peek(stream[, T=UInt8])\n\nRead and return a value of type T from a stream without advancing the current position in the stream.\n\nExamples\n\njulia> b = IOBuffer(\"julia\");\n\njulia> peek(b)\n0x6a\n\njulia> position(b)\n0\n\njulia> peek(b, Char)\n'j': ASCII/Unicode U+006A (category Ll: Letter, lowercase)\n\ncompat: Julia 1.5\nThe method which accepts a type requires Julia 1.5 or later.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.permute!-Tuple{Any, AbstractVector{T} where T}","page":"References","title":"Base.permute!","text":"permute!(v, p)\n\nPermute vector v in-place, according to permutation p. No checking is done to verify that p is a permutation.\n\nTo return a new permutation, use v[p]. Note that this is generally faster than permute!(v,p) for large vectors.\n\nSee also invpermute!.\n\nExamples\n\njulia> A = [1, 1, 3, 4];\n\njulia> perm = [2, 4, 3, 1];\n\njulia> permute!(A, perm);\n\njulia> A\n4-element Vector{Int64}:\n 1\n 4\n 3\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.pipeline-Tuple{Any, Any, Any, Vararg{Any, N} where N}","page":"References","title":"Base.pipeline","text":"pipeline(from, to, ...)\n\nCreate a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other pipeline calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example, pipeline(a,b,c) is equivalent to pipeline(pipeline(a,b),c). This provides a more concise way to specify multi-stage pipelines.\n\nExamples:\n\nrun(pipeline(`ls`, `grep xyz`))\nrun(pipeline(`ls`, \"out.txt\"))\nrun(pipeline(\"out.txt\", `grep xyz`))\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.pipeline-Tuple{Base.AbstractCmd}","page":"References","title":"Base.pipeline","text":"pipeline(command; stdin, stdout, stderr, append=false)\n\nRedirect I/O to or from the given command. Keyword arguments specify which of the command's streams should be redirected. append controls whether file output appends to the file. This is a more general version of the 2-argument pipeline function. pipeline(from, to) is equivalent to pipeline(from, stdout=to) when from is a command, and to pipeline(to, stdin=from) when from is another kind of data source.\n\nExamples:\n\nrun(pipeline(`dothings`, stdout=\"out.txt\", stderr=\"errs.txt\"))\nrun(pipeline(`update`, stdout=\"log.txt\", append=true))\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.pkgdir-Tuple{Module}","page":"References","title":"Base.pkgdir","text":"pkgdir(m::Module)\n\nReturn the root directory of the package that imported module m, or nothing if m was not imported from a package.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.pointer","page":"References","title":"Base.pointer","text":"pointer(array [, index])\n\nGet the native address of an array or string, optionally at a given location index.\n\nThis function is \"unsafe\". Be careful to ensure that a Julia reference to array exists as long as this pointer will be used. The GC.@preserve macro should be used to protect the array argument from garbage collection within a given block of code.\n\nCalling Ref(array[, index]) is generally preferable to this function as it guarantees validity.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.pointer_from_objref-Tuple{Any}","page":"References","title":"Base.pointer_from_objref","text":"pointer_from_objref(x)\n\nGet the memory address of a Julia object as a Ptr. The existence of the resulting Ptr will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the Ptr will be used.\n\nThis function may not be called on immutable objects, since they do not have stable memory addresses.\n\nSee also: unsafe_pointer_to_objref.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.pop!-Tuple{Any, Any, Any}","page":"References","title":"Base.pop!","text":"pop!(collection, key[, default])\n\nDelete and return the mapping for key if it exists in collection, otherwise return default, or throw an error if default is not specified.\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2, \"c\"=>3);\n\njulia> pop!(d, \"a\")\n1\n\njulia> pop!(d, \"d\")\nERROR: KeyError: key \"d\" not found\nStacktrace:\n[...]\n\njulia> pop!(d, \"e\", 4)\n4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.pop!-Tuple{Vector{T} where T}","page":"References","title":"Base.pop!","text":"pop!(collection) -> item\n\nRemove an item in collection and return it. If collection is an ordered container, the last item is returned; for unordered containers, an arbitrary element is returned.\n\nExamples\n\njulia> A=[1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> pop!(A)\n3\n\njulia> A\n2-element Vector{Int64}:\n 1\n 2\n\njulia> S = Set([1, 2])\nSet{Int64} with 2 elements:\n  2\n  1\n\njulia> pop!(S)\n2\n\njulia> S\nSet{Int64} with 1 element:\n  1\n\njulia> pop!(Dict(1=>2))\n1 => 2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.popat!-Tuple{Vector{T} where T, Integer}","page":"References","title":"Base.popat!","text":"popat!(a::Vector, i::Integer, [default])\n\nRemove the item at the given i and return it. Subsequent items are shifted to fill the resulting gap. When i is not a valid index for a, return default, or throw an error if default is not specified. See also deleteat! and splice!.\n\ncompat: Julia 1.5\nThis function is available as of Julia 1.5.\n\nExamples\n\njulia> a = [4, 3, 2, 1]; popat!(a, 2)\n3\n\njulia> a\n3-element Vector{Int64}:\n 4\n 2\n 1\n\njulia> popat!(a, 4, missing)\nmissing\n\njulia> popat!(a, 4)\nERROR: BoundsError: attempt to access 3-element Vector{Int64} at index [4]\n[...]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.popfirst!-Tuple{Vector{T} where T}","page":"References","title":"Base.popfirst!","text":"popfirst!(collection) -> item\n\nRemove the first item from collection.\n\nExamples\n\njulia> A = [1, 2, 3, 4, 5, 6]\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\njulia> popfirst!(A)\n1\n\njulia> A\n5-element Vector{Int64}:\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.position-Tuple{IOStream}","page":"References","title":"Base.position","text":"position(s)\n\nGet the current position of a stream.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> position(io)\n5\n\njulia> skip(io, 10);\n\njulia> position(io)\n15\n\njulia> seekend(io);\n\njulia> position(io)\n35\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.powermod-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T<:Integer","page":"References","title":"Base.powermod","text":"powermod(x::Integer, p::Integer, m)\n\nCompute x^p pmod m.\n\nExamples\n\njulia> powermod(2, 6, 5)\n4\n\njulia> mod(2^6, 5)\n4\n\njulia> powermod(5, 2, 20)\n5\n\njulia> powermod(5, 2, 19)\n6\n\njulia> powermod(5, 3, 19)\n11\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.precision","page":"References","title":"Base.precision","text":"precision(num::AbstractFloat)\n\nGet the precision of a floating point number, as defined by the effective number of bits in the significand.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.precompile-Tuple{Any, Tuple}","page":"References","title":"Base.precompile","text":"precompile(f, args::Tuple{Vararg{Any}})\n\nCompile the given function f for the argument tuple (of types) args, but do not execute it.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.prepend!","page":"References","title":"Base.prepend!","text":"prepend!(a::Vector, collections...) -> collection\n\nInsert the elements of each collections to the beginning of a.\n\nWhen collections specifies multiple collections, order is maintained: elements of collections[1] will appear leftmost in a, and so on.\n\ncompat: Julia 1.6\nSpecifying multiple collections to be prepended requires at least Julia 1.6.\n\nExamples\n\njulia> prepend!([3], [1, 2])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> prepend!([6], [1, 2], [3, 4, 5])\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.prevfloat-Tuple{AbstractFloat, Integer}","page":"References","title":"Base.prevfloat","text":"prevfloat(x::AbstractFloat, n::Integer)\n\nThe result of n iterative applications of prevfloat to x if n >= 0, or -n applications of nextfloat if n < 0.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.prevfloat-Tuple{AbstractFloat}","page":"References","title":"Base.prevfloat","text":"prevfloat(x::AbstractFloat)\n\nReturn the largest floating point number y of the same type as x such y < x. If no such y exists (e.g. if x is -Inf or NaN), then return x.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.prevind-Tuple{AbstractString, Integer, Integer}","page":"References","title":"Base.prevind","text":"prevind(str::AbstractString, i::Integer, n::Integer=1) -> Int\n\nCase n == 1\nIf i is in bounds in s return the index of the start of the character whose encoding starts before index i. In other words, if i is the start of a character, return the start of the previous character; if i is not the start of a character, rewind until the start of a character and return that index. If i is equal to 1 return 0. If i is equal to ncodeunits(str)+1 return lastindex(str). Otherwise throw BoundsError.\nCase n > 1\nBehaves like applying n times prevind for n==1. The only difference is that if n is so large that applying prevind would reach 0 then each remaining iteration decreases the returned value by 1. This means that in this case prevind can return a negative value.\nCase n == 0\nReturn i only if i is a valid index in str or is equal to ncodeunits(str)+1. Otherwise StringIndexError or BoundsError is thrown.\n\nExamples\n\njulia> prevind(\"α\", 3)\n1\n\njulia> prevind(\"α\", 1)\n0\n\njulia> prevind(\"α\", 0)\nERROR: BoundsError: attempt to access 2-codeunit String at index [0]\n[...]\n\njulia> prevind(\"α\", 2, 2)\n0\n\njulia> prevind(\"α\", 2, 3)\n-1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.prevpow-Tuple{Real, Real}","page":"References","title":"Base.prevpow","text":"prevpow(a, x)\n\nThe largest a^n not greater than x, where n is a non-negative integer. a must be greater than 1, and x must not be less than 1.\n\nExamples\n\njulia> prevpow(2, 7)\n4\n\njulia> prevpow(2, 9)\n8\n\njulia> prevpow(5, 20)\n5\n\njulia> prevpow(4, 16)\n16\n\nSee also nextpow.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.print-Tuple{IO, Any}","page":"References","title":"Base.print","text":"print([io::IO], xs...)\n\nWrite to io (or to the default output stream stdout if io is not given) a canonical (un-decorated) text representation. The representation used by print includes minimal formatting and tries to avoid Julia-specific details.\n\nprint falls back to calling show, so most types should just define show. Define print if your type has a separate \"plain\" representation. For example, show displays strings with quotes, and print displays strings without quotes.\n\nstring returns the output of print as a string.\n\nExamples\n\njulia> print(\"Hello World!\")\nHello World!\njulia> io = IOBuffer();\n\njulia> print(io, \"Hello\", ' ', :World!)\n\njulia> String(take!(io))\n\"Hello World!\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.print_matrix","page":"References","title":"Base.print_matrix","text":"print_matrix(io::IO, mat, pre, sep, post, hdots, vdots, ddots, hmod, vmod)\n\nPrints a matrix with limited output size. If io sets :limit to true, then only the corners of the matrix are printed, separated with vertical, horizontal, and diagonal ellipses as appropriate. Optional arguments are string pre (printed before the matrix, e.g. an opening bracket) which will cause a corresponding same-size indent on following rows, and string post (printed at the end of the last row of the matrix). Also options to use different ellipsis characters hdots, vdots, ddots. These are repeated every hmod or vmod elements.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.print_matrix_row-Tuple{IO, AbstractVecOrMat{T} where T, Vector{T} where T, Integer, AbstractVector{T} where T, AbstractString}","page":"References","title":"Base.print_matrix_row","text":"print_matrix_row(io, X, A, i, cols, sep) produces the aligned output for a single matrix row X[i, cols] where the desired list of columns is given. The corresponding alignment A is used, and the separation between elements is specified as string sep. print_matrix_row will also respect compact output for elements.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.print_matrix_vdots","page":"References","title":"Base.print_matrix_vdots","text":"print_matrix_vdots is used to show a series of vertical ellipsis instead of a bunch of rows for long matrices. Not only is the string vdots shown but it also repeated every M elements if desired.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.print_range","page":"References","title":"Base.print_range","text":"print_range(io, r) prints out a nice looking range r in terms of its elements as if it were collect(r), dependent on the size of the terminal, and taking into account whether compact numbers should be shown. It figures out the width in characters of each element, and if they end up too wide, it shows the first and last elements separated by a horizontal ellipsis. Typical output will look like 1.0,2.0,3.0,…,4.0,5.0,6.0.\n\nprint_range(io, r, pre, sep, post, hdots) uses optional parameters pre and post characters for each printed row, sep separator string between printed elements, hdots string for the horizontal ellipsis.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.print_statement_costs-Tuple{IO, Any, Any}","page":"References","title":"Base.print_statement_costs","text":"print_statement_costs(io::IO, f, types)\n\nPrint type-inferred and optimized code for f given argument types types, prepending each line with its cost as estimated by the compiler's inlining engine.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.println-Tuple{IO, Vararg{Any, N} where N}","page":"References","title":"Base.println","text":"println([io::IO], xs...)\n\nPrint (using print) xs followed by a newline. If io is not supplied, prints to stdout.\n\nExamples\n\njulia> println(\"Hello, world\")\nHello, world\n\njulia> io = IOBuffer();\n\njulia> println(io, \"Hello, world\")\n\njulia> String(take!(io))\n\"Hello, world\\n\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.printstyled-Tuple{IO, Vararg{Any, N} where N}","page":"References","title":"Base.printstyled","text":"printstyled([io], xs...; bold::Bool=false, color::Union{Symbol,Int}=:normal)\n\nPrint xs in a color specified as a symbol or integer, optionally in bold.\n\ncolor may take any of the values :normal, :default, :bold, :black, :blink, :blue, :cyan, :green, :hidden, :light_black, :light_blue, :light_cyan, :light_green, :light_magenta, :light_red, :light_yellow, :magenta, :nothing, :red, :reverse, :underline, :white, or  :yellow or an integer between 0 and 255 inclusive. Note that not all terminals support 256 colors. If the keyword bold is given as true, the result will be printed in bold.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.process_exited-Tuple{Base.Process}","page":"References","title":"Base.process_exited","text":"process_exited(p::Process)\n\nDetermine whether a process has exited.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.process_running-Tuple{Base.Process}","page":"References","title":"Base.process_running","text":"process_running(p::Process)\n\nDetermine whether a process is currently running.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.prod!-Tuple{Any, Any}","page":"References","title":"Base.prod!","text":"prod!(r, A)\n\nMultiply elements of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> prod!([1; 1], A)\n2-element Vector{Int64}:\n  2\n 12\n\njulia> prod!([1 1], A)\n1×2 Matrix{Int64}:\n 3  8\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.prod-Tuple{AbstractArray}","page":"References","title":"Base.prod","text":"prod(A::AbstractArray; dims)\n\nMultiply elements of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> prod(A, dims=1)\n1×2 Matrix{Int64}:\n 3  8\n\njulia> prod(A, dims=2)\n2×1 Matrix{Int64}:\n  2\n 12\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.prod-Tuple{Any, AbstractArray}","page":"References","title":"Base.prod","text":"prod(f, A::AbstractArray; dims)\n\nMultiply the results of calling the function f on each element of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> prod(abs2, A, dims=1)\n1×2 Matrix{Int64}:\n 9  64\n\njulia> prod(abs2, A, dims=2)\n2×1 Matrix{Int64}:\n   4\n 144\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.prod-Tuple{Any, Any}","page":"References","title":"Base.prod","text":"prod(f, itr; [init])\n\nReturns the product of f applied to each element of itr.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be the multiplicative identity (i.e. one) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> prod(abs2, [2; 3; 4])\n576\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.prod-Tuple{Any}","page":"References","title":"Base.prod","text":"prod(itr; [init])\n\nReturns the product of all elements of a collection.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be the multiplicative identity (i.e. one) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> prod(1:5)\n120\n\njulia> prod(1:5; init = 1.0)\n120.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.promote","page":"References","title":"Base.promote","text":"promote(xs...)\n\nConvert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.\n\nExamples\n\njulia> promote(Int8(1), Float16(4.5), Float32(4.1))\n(1.0f0, 4.5f0, 4.1f0)\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.promote_op-Tuple{Any, Vararg{Type, N} where N}","page":"References","title":"Base.promote_op","text":"promote_op(f, argtypes...)\n\nGuess what an appropriate container eltype would be for storing results of f(::argtypes...). The guess is in part based on type inference, so can change any time.\n\nwarning: Warning\nDue to its fragility, use of promote_op should be avoided. It is preferable to base the container eltype on the type of the actual elements. Only in the absence of any elements (for an empty result container), it may be unavoidable to call promote_op.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.promote_rule","page":"References","title":"Base.promote_rule","text":"promote_rule(type1, type2)\n\nSpecifies what type should be used by promote when given values of types type1 and type2. This function should not be called directly, but should have definitions added to it for new types as appropriate.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.promote_shape-Tuple{Tuple{Vararg{Int64, N}} where N, Tuple{Vararg{Int64, N}} where N}","page":"References","title":"Base.promote_shape","text":"promote_shape(s1, s2)\n\nCheck two array shapes for compatibility, allowing trailing singleton dimensions, and return whichever shape has more dimensions.\n\nExamples\n\njulia> a = fill(1, (3,4,1,1,1));\n\njulia> b = fill(1, (3,4));\n\njulia> promote_shape(a,b)\n(Base.OneTo(3), Base.OneTo(4), Base.OneTo(1), Base.OneTo(1), Base.OneTo(1))\n\njulia> promote_shape((2,3,1,4), (2, 3, 1, 4, 1))\n(2, 3, 1, 4, 1)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.promote_type","page":"References","title":"Base.promote_type","text":"promote_type(type1, type2)\n\nPromotion refers to converting values of mixed types to a single common type. promote_type represents the default promotion behavior in Julia when operators (usually mathematical) are given arguments of differing types. promote_type generally tries to return a type which can at least approximate most values of either input type without excessively widening.  Some loss is tolerated; for example, promote_type(Int64, Float64) returns Float64 even though strictly, not all Int64 values can be represented exactly as Float64 values.\n\njulia> promote_type(Int64, Float64)\nFloat64\n\njulia> promote_type(Int32, Int64)\nInt64\n\njulia> promote_type(Float32, BigInt)\nBigFloat\n\njulia> promote_type(Int16, Float16)\nFloat16\n\njulia> promote_type(Int64, Float16)\nFloat16\n\njulia> promote_type(Int8, UInt16)\nUInt16\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.promote_typejoin-Tuple{Any, Any}","page":"References","title":"Base.promote_typejoin","text":"promote_typejoin(T, S)\n\nCompute a type that contains both T and S, which could be either a parent of both types, or a Union if appropriate. Falls back to typejoin.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.prompt-Tuple{IO, IO, AbstractString}","page":"References","title":"Base.prompt","text":"prompt(message; default=\"\") -> Union{String, Nothing}\n\nDisplays the message then waits for user input. Input is terminated when a newline (\\n) is encountered or EOF (^D) character is entered on a blank line. If a default is provided then the user can enter just a newline character to select the default.\n\nSee also Base.getpass and Base.winprompt for secure entry of passwords.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.propertynames-Tuple{Any}","page":"References","title":"Base.propertynames","text":"propertynames(x, private=false)\n\nGet a tuple or a vector of the properties (x.property) of an object x. This is typically the same as fieldnames(typeof(x)), but types that overload getproperty should generally overload propertynames as well to get the properties of an instance of the type.\n\npropertynames(x) may return only \"public\" property names that are part of the documented interface of x.   If you want it to also return \"private\" fieldnames intended for internal use, pass true for the optional second argument. REPL tab completion on x. shows only the private=false properties.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.push!","page":"References","title":"Base.push!","text":"push!(collection, items...) -> collection\n\nInsert one or more items in collection. If collection is an ordered container, the items are inserted at the end (in the given order).\n\nExamples\n\njulia> push!([1, 2, 3], 4, 5, 6)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n\nIf collection is ordered, use append! to add all the elements of another collection to it. The result of the preceding example is equivalent to append!([1, 2, 3], [4, 5, 6]). For AbstractSet objects, union! can be used instead.\n\nSee sizehint! for notes about the performance model.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.pushfirst!-Union{Tuple{T}, Tuple{Vector{T}, Any}} where T","page":"References","title":"Base.pushfirst!","text":"pushfirst!(collection, items...) -> collection\n\nInsert one or more items at the beginning of collection.\n\nExamples\n\njulia> pushfirst!([1, 2, 3, 4], 5, 6)\n6-element Vector{Int64}:\n 5\n 6\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.put!-Union{Tuple{T}, Tuple{Channel{T}, Any}} where T","page":"References","title":"Base.put!","text":"put!(c::Channel, v)\n\nAppend an item v to the channel c. Blocks if the channel is full.\n\nFor unbuffered channels, blocks until a take! is performed by a different task.\n\ncompat: Julia 1.1\nv now gets converted to the channel's type with convert as put! is called.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.range-Tuple{Any}","page":"References","title":"Base.range","text":"range(start[, stop]; length, stop, step=1)\n\nGiven a starting value, construct a range either by length or from start to stop, optionally with a given step (defaults to 1, a UnitRange). One of length or stop is required.  If length, stop, and step are all specified, they must agree.\n\nIf length and stop are provided and step is not, the step size will be computed automatically such that there are length linearly spaced elements in the range.\n\nIf step and stop are provided and length is not, the overall range length will be computed automatically such that the elements are step spaced.\n\nSpecial care is taken to ensure intermediate values are computed rationally. To avoid this induced overhead, see the LinRange constructor.\n\nstop may be specified as either a positional or keyword argument.\n\ncompat: Julia 1.1\nstop as a positional argument requires at least Julia 1.1.\n\nExamples\n\njulia> range(1, length=100)\n1:100\n\njulia> range(1, stop=100)\n1:100\n\njulia> range(1, step=5, length=100)\n1:5:496\n\njulia> range(1, step=5, stop=100)\n1:5:96\n\njulia> range(1, 10, length=101)\n1.0:0.09:10.0\n\njulia> range(1, 100, step=5)\n1:5:96\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rationalize-Union{Tuple{T}, Tuple{Type{T}, AbstractFloat, Real}} where T<:Integer","page":"References","title":"Base.rationalize","text":"rationalize([T<:Integer=Int,] x; tol::Real=eps(x))\n\nApproximate floating point number x as a Rational number with components of the given integer type. The result will differ from x by no more than tol.\n\nExamples\n\njulia> rationalize(5.6)\n28//5\n\njulia> a = rationalize(BigInt, 10.3)\n103//10\n\njulia> typeof(numerator(a))\nBigInt\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.read","page":"References","title":"Base.read","text":"read(s::IO, nb=typemax(Int))\n\nRead at most nb bytes from s, returning a Vector{UInt8} of the bytes read.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.read!","page":"References","title":"Base.read!","text":"read!(stream::IO, array::AbstractArray)\nread!(filename::AbstractString, array::AbstractArray)\n\nRead binary data from an I/O stream or file, filling in array.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.read-Tuple{AbstractString, Vararg{Any, N} where N}","page":"References","title":"Base.read","text":"read(filename::AbstractString, args...)\n\nOpen a file and read its contents. args is passed to read: this is equivalent to open(io->read(io, args...), filename).\n\nread(filename::AbstractString, String)\n\nRead the entire contents of a file as a string.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.read-Tuple{Any, Any}","page":"References","title":"Base.read","text":"read(io::IO, T)\n\nRead a single value of type T from io, in canonical binary representation.\n\nNote that Julia does not convert the endianness for you. Use ntoh or ltoh for this purpose.\n\nread(io::IO, String)\n\nRead the entirety of io, as a String (see also readchomp).\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization\");\n\njulia> read(io, String)\n\"JuliaLang is a GitHub organization\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.read-Tuple{Base.AbstractCmd, Type{String}}","page":"References","title":"Base.read","text":"read(command::Cmd, String)\n\nRun command and return the resulting output as a String.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.read-Tuple{Base.AbstractCmd}","page":"References","title":"Base.read","text":"read(command::Cmd)\n\nRun command and return the resulting output as an array of bytes.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.read-Tuple{IOStream, Integer}","page":"References","title":"Base.read","text":"read(s::IOStream, nb::Integer; all=true)\n\nRead at most nb bytes from s, returning a Vector{UInt8} of the bytes read.\n\nIf all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.readavailable","page":"References","title":"Base.readavailable","text":"readavailable(stream)\n\nRead available buffered data from a stream. Actual I/O is performed only if no data has already been buffered. The result is a Vector{UInt8}.\n\nwarning: Warning\nThe amount of data returned is implementation-dependent; for example it can depend on the internal choice of buffer size. Other functions such as read should generally be used instead.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.readbytes!","page":"References","title":"Base.readbytes!","text":"readbytes!(stream::IO, b::AbstractVector{UInt8}, nb=length(b))\n\nRead at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.readbytes!-2","page":"References","title":"Base.readbytes!","text":"readbytes!(stream::IOStream, b::AbstractVector{UInt8}, nb=length(b); all::Bool=true)\n\nRead at most nb bytes from stream into b, returning the number of bytes read. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\n\nIf all is true (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If all is false, at most one read call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the all option.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.readchomp-Tuple{Any}","page":"References","title":"Base.readchomp","text":"readchomp(x)\n\nRead the entirety of x as a string and remove a single trailing newline if there is one. Equivalent to chomp(read(x, String)).\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end;\n\njulia> readchomp(\"my_file.txt\")\n\"JuliaLang is a GitHub organization.\\nIt has many members.\"\n\njulia> rm(\"my_file.txt\");\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.readeach-Union{Tuple{IOT}, Tuple{IOT, Type}} where IOT<:IO","page":"References","title":"Base.readeach","text":"readeach(io::IO, T)\n\nReturn an iterable object yielding read(io, T).\n\nSee also: skipchars, eachline, readuntil\n\ncompat: Julia 1.6\nreadeach requires Julia 1.6 or later.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\\n It has many members.\\n\");\n\njulia> for c in readeach(io, Char)\n           c == '\\n' && break\n           print(c)\n       end\nJuliaLang is a GitHub organization.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.readline-Tuple{AbstractString}","page":"References","title":"Base.readline","text":"readline(io::IO=stdin; keep::Bool=false)\nreadline(filename::AbstractString; keep::Bool=false)\n\nRead a single line of text from the given I/O stream or file (defaults to stdin). When reading from a file, the text is assumed to be encoded in UTF-8. Lines in the input end with '\\n' or \"\\r\\n\" or the end of an input stream. When keep is false (as it is by default), these trailing newline characters are removed from the line before it is returned. When keep is true, they are returned as part of the line.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readline(\"my_file.txt\")\n\"JuliaLang is a GitHub organization.\"\n\njulia> readline(\"my_file.txt\", keep=true)\n\"JuliaLang is a GitHub organization.\\n\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.readlines-Tuple{AbstractString}","page":"References","title":"Base.readlines","text":"readlines(io::IO=stdin; keep::Bool=false)\nreadlines(filename::AbstractString; keep::Bool=false)\n\nRead all lines of an I/O stream or a file as a vector of strings. Behavior is equivalent to saving the result of reading readline repeatedly with the same arguments and saving the resulting lines as a vector of strings.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readlines(\"my_file.txt\")\n2-element Vector{String}:\n \"JuliaLang is a GitHub organization.\"\n \"It has many members.\"\n\njulia> readlines(\"my_file.txt\", keep=true)\n2-element Vector{String}:\n \"JuliaLang is a GitHub organization.\\n\"\n \"It has many members.\\n\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.readuntil-Tuple{AbstractString, Vararg{Any, N} where N}","page":"References","title":"Base.readuntil","text":"readuntil(stream::IO, delim; keep::Bool = false)\nreaduntil(filename::AbstractString, delim; keep::Bool = false)\n\nRead a string from an I/O stream or a file, up to the given delimiter. The delimiter can be a UInt8, AbstractChar, string, or vector. Keyword argument keep controls whether the delimiter is included in the result. The text is assumed to be encoded in UTF-8.\n\nExamples\n\njulia> open(\"my_file.txt\", \"w\") do io\n           write(io, \"JuliaLang is a GitHub organization.\\nIt has many members.\\n\");\n       end\n57\n\njulia> readuntil(\"my_file.txt\", 'L')\n\"Julia\"\n\njulia> readuntil(\"my_file.txt\", '.', keep = true)\n\"JuliaLang is a GitHub organization.\"\n\njulia> rm(\"my_file.txt\")\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.real-Tuple{Complex}","page":"References","title":"Base.real","text":"real(z)\n\nReturn the real part of the complex number z.\n\nExamples\n\njulia> real(1 + 3im)\n1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.real-Tuple{Type}","page":"References","title":"Base.real","text":"real(T::Type)\n\nReturn the type that represents the real part of a value of type T. e.g: for T == Complex{R}, returns R. Equivalent to typeof(real(zero(T))).\n\nExamples\n\njulia> real(Complex{Int})\nInt64\n\njulia> real(Float64)\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.recursive_prefs_merge-Tuple{Dict{String, Any}, Vararg{Dict{String, Any}, N} where N}","page":"References","title":"Base.recursive_prefs_merge","text":"recursive_prefs_merge(base::Dict, overrides::Dict...)\n\nHelper function to merge preference dicts recursively, honoring overrides in nested dictionaries properly.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.redirect_stderr","page":"References","title":"Base.redirect_stderr","text":"redirect_stderr([stream]) -> (rd, wr)\n\nLike redirect_stdout, but for stderr.\n\nnote: Note\nstream must be an IOStream, a TTY, a Pipe, a socket, or devnull.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.redirect_stderr-Tuple{Function, Any}","page":"References","title":"Base.redirect_stderr","text":"redirect_stderr(f::Function, stream)\n\nRun the function f while redirecting stderr to stream. Upon completion, stderr is restored to its prior setting.\n\nnote: Note\nstream must be a TTY, a Pipe, or a socket.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.redirect_stdin","page":"References","title":"Base.redirect_stdin","text":"redirect_stdin([stream]) -> (rd, wr)\n\nLike redirect_stdout, but for stdin. Note that the order of the return tuple is still (rd, wr), i.e. data to be read from stdin may be written to wr.\n\nnote: Note\nstream must be an IOStream, a TTY, a Pipe, a socket, or devnull.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.redirect_stdin-Tuple{Function, Any}","page":"References","title":"Base.redirect_stdin","text":"redirect_stdin(f::Function, stream)\n\nRun the function f while redirecting stdin to stream. Upon completion, stdin is restored to its prior setting.\n\nnote: Note\nstream must be a TTY, a Pipe, or a socket.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.redirect_stdout","page":"References","title":"Base.redirect_stdout","text":"redirect_stdout([stream]) -> (rd, wr)\n\nCreate a pipe to which all C and Julia level stdout output will be redirected. Returns a tuple (rd, wr) representing the pipe ends. Data written to stdout may now be read from the rd end of the pipe. The wr end is given for convenience in case the old stdout object was cached by the user and needs to be replaced elsewhere.\n\nIf called with the optional stream argument, then returns stream itself.\n\nnote: Note\nstream must be an IOStream, a TTY, a Pipe, a socket, or devnull.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.redirect_stdout-Tuple{Function, Any}","page":"References","title":"Base.redirect_stdout","text":"redirect_stdout(f::Function, stream)\n\nRun the function f while redirecting stdout to stream. Upon completion, stdout is restored to its prior setting.\n\nnote: Note\nstream must be a TTY, a Pipe, or a socket.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reduce-Tuple{Any, AbstractArray}","page":"References","title":"Base.reduce","text":"reduce(f, A; dims=:, [init])\n\nReduce 2-argument function f along dimensions of A. dims is a vector specifying the dimensions to reduce, and the keyword argument init is the initial value to use in the reductions. For +, *, max and min the init argument is optional.\n\nThe associativity of the reduction is implementation-dependent; if you need a particular associativity, e.g. left-to-right, you should write your own loop or consider using foldl or foldr. See documentation for reduce.\n\nExamples\n\njulia> a = reshape(Vector(1:16), (4,4))\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> reduce(max, a, dims=2)\n4×1 Matrix{Int64}:\n 13\n 14\n 15\n 16\n\njulia> reduce(max, a, dims=1)\n1×4 Matrix{Int64}:\n 4  8  12  16\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reduce-Tuple{Any, Any}","page":"References","title":"Base.reduce","text":"reduce(op, itr; [init])\n\nReduce the given collection itr with the given binary operator op. If provided, the initial value init must be a neutral element for op that will be returned for empty collections. It is unspecified whether init is used for non-empty collections.\n\nFor empty collections, providing init will be necessary, except for some special cases (e.g. when op is one of +, *, max, min, &, |) when Julia can determine the neutral element of op.\n\nReductions for certain commonly-used operators may have special implementations, and should be used instead: maximum(itr), minimum(itr), sum(itr), prod(itr),  any(itr), all(itr).\n\nThe associativity of the reduction is implementation dependent. This means that you can't use non-associative operations like - because it is undefined whether reduce(-,[1,2,3]) should be evaluated as (1-2)-3 or 1-(2-3). Use foldl or foldr instead for guaranteed left or right associativity.\n\nSome operations accumulate error. Parallelism will be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.\n\nExamples\n\njulia> reduce(*, [2; 3; 4])\n24\n\njulia> reduce(*, [2; 3; 4]; init=-1)\n-24\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reduce_empty-Union{Tuple{T}, Tuple{Any, Type{T}}} where T","page":"References","title":"Base.reduce_empty","text":"Base.reduce_empty(op, T)\n\nThe value to be returned when calling reduce, foldl or foldr with reduction op over an empty array with element type of T.\n\nIf not defined, this will throw an ArgumentError.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reduce_first-Tuple{Any, Any}","page":"References","title":"Base.reduce_first","text":"Base.reduce_first(op, x)\n\nThe value to be returned when calling reduce, foldl or foldr with reduction op over an iterator which contains a single element x. This value may also used to initialise the recursion, so that reduce(op, [x, y]) may call op(reduce_first(op, x), y).\n\nThe default is x for most types. The main purpose is to ensure type stability, so additional methods should only be defined for cases where op gives a result with different types than its inputs.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reenable_sigint-Tuple{Function}","page":"References","title":"Base.reenable_sigint","text":"reenable_sigint(f::Function)\n\nRe-enable Ctrl-C handler during execution of a function. Temporarily reverses the effect of disable_sigint.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reim-Tuple{Any}","page":"References","title":"Base.reim","text":"reim(z)\n\nReturn both the real and imaginary parts of the complex number z.\n\nExamples\n\njulia> reim(1 + 3im)\n(1, 3)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reinterpret-Tuple{typeof(reshape), Type, AbstractArray}","page":"References","title":"Base.reinterpret","text":"reinterpret(reshape, T, A::AbstractArray{S}) -> B\n\nChange the type-interpretation of A while consuming or adding a \"channel dimension.\"\n\nIf sizeof(T) = n*sizeof(S) for n>1, A's first dimension must be of size n and B lacks A's first dimension. Conversely, if sizeof(S) = n*sizeof(T) for n>1, B gets a new first dimension of size n. The dimensionality is unchanged if sizeof(T) == sizeof(S).\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> reinterpret(reshape, Complex{Int}, A)    # the result is a vector\n2-element reinterpret(reshape, Complex{Int64}, ::Matrix{Int64}) with eltype Complex{Int64}:\n 1 + 3im\n 2 + 4im\n\njulia> a = [(1,2,3), (4,5,6)]\n2-element Vector{Tuple{Int64, Int64, Int64}}:\n (1, 2, 3)\n (4, 5, 6)\n\njulia> reinterpret(reshape, Int, a)             # the result is a matrix\n3×2 reinterpret(reshape, Int64, ::Vector{Tuple{Int64, Int64, Int64}}) with eltype Int64:\n 1  4\n 2  5\n 3  6\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reinterpret-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"References","title":"Base.reinterpret","text":"reinterpret(type, A)\n\nChange the type-interpretation of a block of memory. For arrays, this constructs a view of the array with the same binary data as the given array, but with the specified element type. For example, reinterpret(Float32, UInt32(7)) interprets the 4 bytes corresponding to UInt32(7) as a Float32.\n\nExamples\n\njulia> reinterpret(Float32, UInt32(7))\n1.0f-44\n\njulia> reinterpret(Float32, UInt32[1 2 3 4 5])\n1×5 reinterpret(Float32, ::Matrix{UInt32}):\n 1.0f-45  3.0f-45  4.0f-45  6.0f-45  7.0f-45\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.release-Tuple{Base.Semaphore}","page":"References","title":"Base.release","text":"release(s::Semaphore)\n\nReturn one permit to the pool, possibly allowing another task to acquire it and resume execution.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rem","page":"References","title":"Base.rem","text":"rem(x, y)\n%(x, y)\n\nRemainder from Euclidean division, returning a value of the same sign as x, and smaller in magnitude than y. This value is always exact.\n\nExamples\n\njulia> x = 15; y = 4;\n\njulia> x % y\n3\n\njulia> x == div(x, y) * y + rem(x, y)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.rem-Tuple{Any, Any, RoundingMode}","page":"References","title":"Base.rem","text":"rem(x, y, r::RoundingMode=RoundToZero)\n\nCompute the remainder of x after integer division by y, with the quotient rounded according to the rounding mode r. In other words, the quantity\n\nx - y*round(x/y,r)\n\nwithout any intermediate rounding.\n\nif r == RoundNearest, then the result is exact, and in the interval -y2 y2. See also RoundNearest.\nif r == RoundToZero (default), then the result is exact, and in the interval 0 y) if x is positive, or (-y 0 otherwise. See also RoundToZero.\nif r == RoundDown, then the result is in the interval 0 y) if y is positive, or (y 0 otherwise. The result may not be exact if x and y have different signs, and abs(x) < abs(y). See also RoundDown.\nif r == RoundUp, then the result is in the interval (-y,0] if y is positive, or [0,-y) otherwise. The result may not be exact if x and y have the same sign, and abs(x) < abs(y). See also RoundUp.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rem-Tuple{Integer, Type{var\"#s832\"} where var\"#s832\"<:Integer}","page":"References","title":"Base.rem","text":"rem(x::Integer, T::Type{<:Integer}) -> T\nmod(x::Integer, T::Type{<:Integer}) -> T\n%(x::Integer, T::Type{<:Integer}) -> T\n\nFind y::T such that x ≡ y (mod n), where n is the number of integers representable in T, and y is an integer in [typemin(T),typemax(T)]. If T can represent any integer (e.g. T == BigInt), then this operation corresponds to a conversion to T.\n\nExamples\n\njulia> 129 % Int8\n-127\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.repeat-Tuple{AbstractArray, Vararg{Any, N} where N}","page":"References","title":"Base.repeat","text":"repeat(A::AbstractArray, counts::Integer...)\n\nConstruct an array by repeating array A a given number of times in each dimension, specified by counts.\n\nExamples\n\njulia> repeat([1, 2, 3], 2)\n6-element Vector{Int64}:\n 1\n 2\n 3\n 1\n 2\n 3\n\njulia> repeat([1, 2, 3], 2, 3)\n6×3 Matrix{Int64}:\n 1  1  1\n 2  2  2\n 3  3  3\n 1  1  1\n 2  2  2\n 3  3  3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.repeat-Tuple{AbstractArray}","page":"References","title":"Base.repeat","text":"repeat(A::AbstractArray; inner=ntuple(x->1, ndims(A)), outer=ntuple(x->1, ndims(A)))\n\nConstruct an array by repeating the entries of A. The i-th element of inner specifies the number of times that the individual entries of the i-th dimension of A should be repeated. The i-th element of outer specifies the number of times that a slice along the i-th dimension of A should be repeated. If inner or outer are omitted, no repetition is performed.\n\nExamples\n\njulia> repeat(1:2, inner=2)\n4-element Vector{Int64}:\n 1\n 1\n 2\n 2\n\njulia> repeat(1:2, outer=2)\n4-element Vector{Int64}:\n 1\n 2\n 1\n 2\n\njulia> repeat([1 2; 3 4], inner=(2, 1), outer=(1, 3))\n4×6 Matrix{Int64}:\n 1  2  1  2  1  2\n 1  2  1  2  1  2\n 3  4  3  4  3  4\n 3  4  3  4  3  4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.repeat-Tuple{AbstractChar, Integer}","page":"References","title":"Base.repeat","text":"repeat(c::AbstractChar, r::Integer) -> String\n\nRepeat a character r times. This can equivalently be accomplished by calling c^r.\n\nExamples\n\njulia> repeat('A', 3)\n\"AAA\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.repeat-Tuple{AbstractString, Integer}","page":"References","title":"Base.repeat","text":"repeat(s::AbstractString, r::Integer)\n\nRepeat a string r times. This can be written as s^r.\n\nSee also: ^\n\nExamples\n\njulia> repeat(\"ha\", 3)\n\"hahaha\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.replace!-Tuple{Any, Vararg{Pair, N} where N}","page":"References","title":"Base.replace!","text":"replace!(A, old_new::Pair...; [count::Integer])\n\nFor each pair old=>new in old_new, replace all occurrences of old in collection A by new. Equality is determined using isequal. If count is specified, then replace at most count occurrences in total. See also replace.\n\nExamples\n\njulia> replace!([1, 2, 1, 3], 1=>0, 2=>4, count=2)\n4-element Vector{Int64}:\n 0\n 4\n 1\n 3\n\njulia> replace!(Set([1, 2, 3]), 1=>0)\nSet{Int64} with 3 elements:\n  0\n  2\n  3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.replace!-Tuple{Union{Function, Type}, Any}","page":"References","title":"Base.replace!","text":"replace!(new::Function, A; [count::Integer])\n\nReplace each element x in collection A by new(x). If count is specified, then replace at most count values in total (replacements being defined as new(x) !== x).\n\nExamples\n\njulia> replace!(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])\n4-element Vector{Int64}:\n 2\n 2\n 6\n 4\n\njulia> replace!(Dict(1=>2, 3=>4)) do kv\n           first(kv) < 3 ? first(kv)=>3 : kv\n       end\nDict{Int64, Int64} with 2 entries:\n  3 => 4\n  1 => 3\n\njulia> replace!(x->2x, Set([3, 6]))\nSet{Int64} with 2 elements:\n  6\n  12\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.replace-Tuple{AbstractString, Pair}","page":"References","title":"Base.replace","text":"replace(s::AbstractString, pat=>r; [count::Integer])\n\nSearch for the given pattern pat in s, and replace each occurrence with r. If count is provided, replace at most count occurrences. pat may be a single character, a vector or a set of characters, a string, or a regular expression. If r is a function, each occurrence is replaced with r(s) where s is the matched substring (when pat is a AbstractPattern or AbstractString) or character (when pat is an AbstractChar or a collection of AbstractChar). If pat is a regular expression and r is a SubstitutionString, then capture group references in r are replaced with the corresponding matched text. To remove instances of pat from string, set r to the empty String (\"\").\n\nExamples\n\njulia> replace(\"Python is a programming language.\", \"Python\" => \"Julia\")\n\"Julia is a programming language.\"\n\njulia> replace(\"The quick foxes run quickly.\", \"quick\" => \"slow\", count=1)\n\"The slow foxes run quickly.\"\n\njulia> replace(\"The quick foxes run quickly.\", \"quick\" => \"\", count=1)\n\"The  foxes run quickly.\"\n\njulia> replace(\"The quick foxes run quickly.\", r\"fox(es)?\" => s\"bus\\1\")\n\"The quick buses run quickly.\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.replace-Tuple{Any, Vararg{Pair, N} where N}","page":"References","title":"Base.replace","text":"replace(A, old_new::Pair...; [count::Integer])\n\nReturn a copy of collection A where, for each pair old=>new in old_new, all occurrences of old are replaced by new. Equality is determined using isequal. If count is specified, then replace at most count occurrences in total.\n\nThe element type of the result is chosen using promotion (see promote_type) based on the element type of A and on the types of the new values in pairs. If count is omitted and the element type of A is a Union, the element type of the result will not include singleton types which are replaced with values of a different type: for example, Union{T,Missing} will become T if missing is replaced.\n\nSee also replace!.\n\nExamples\n\njulia> replace([1, 2, 1, 3], 1=>0, 2=>4, count=2)\n4-element Vector{Int64}:\n 0\n 4\n 1\n 3\n\njulia> replace([1, missing], missing=>0)\n2-element Vector{Int64}:\n 1\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.replace-Tuple{Union{Function, Type}, Any}","page":"References","title":"Base.replace","text":"replace(new::Function, A; [count::Integer])\n\nReturn a copy of A where each value x in A is replaced by new(x). If count is specified, then replace at most count values in total (replacements being defined as new(x) !== x).\n\nExamples\n\njulia> replace(x -> isodd(x) ? 2x : x, [1, 2, 3, 4])\n4-element Vector{Int64}:\n 2\n 2\n 6\n 4\n\njulia> replace(Dict(1=>2, 3=>4)) do kv\n           first(kv) < 3 ? first(kv)=>3 : kv\n       end\nDict{Int64, Int64} with 2 entries:\n  3 => 4\n  1 => 3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.replace_ref_begin_end!-Tuple{Any}","page":"References","title":"Base.replace_ref_begin_end!","text":"replace_ref_begin_end!(ex)\n\nRecursively replace occurrences of the symbols :begin and :end in a \"ref\" expression (i.e. A[...]) ex with the appropriate function calls (firstindex or lastindex). Replacement uses the closest enclosing ref, so\n\nA[B[end]]\n\nshould transform to\n\nA[B[lastindex(B)]]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.replace_with_centered_mark-Tuple{AbstractString}","page":"References","title":"Base.replace_with_centered_mark","text":"Unexported convenience function used in body of replace_in_print_matrix methods. By default returns a string of the same width as original with a centered cdot, used in printing of structural zeros of structured matrices. Accept keyword args c for alternate single character marker.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.repr-Tuple{Any}","page":"References","title":"Base.repr","text":"repr(x; context=nothing)\n\nCreate a string from any value using the show function. You should not add methods to repr; define a show method instead.\n\nThe optional keyword argument context can be set to an IO or IOContext object whose attributes are used for the I/O stream passed to show.\n\nNote that repr(x) is usually similar to how the value of x would be entered in Julia.  See also repr(MIME(\"text/plain\"), x) to instead return a \"pretty-printed\" version of x designed more for human consumption, equivalent to the REPL display of x.\n\nExamples\n\njulia> repr(1)\n\"1\"\n\njulia> repr(zeros(3))\n\"[0.0, 0.0, 0.0]\"\n\njulia> repr(big(1/3))\n\"0.333333333333333314829616256247390992939472198486328125\"\n\njulia> repr(big(1/3), context=:compact => true)\n\"0.333333\"\n\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.require-Tuple{Module, Symbol}","page":"References","title":"Base.require","text":"require(into::Module, module::Symbol)\n\nThis function is part of the implementation of using / import, if a module is not already defined in Main. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).\n\nLoads a source file, in the context of the Main module, on every active node, searching standard locations for files. require is considered a top-level operation, so it sets the current include path but does not use it to search for files (see help for include). This function is typically used to load library code, and is implicitly called by using to load packages.\n\nWhen searching for files, require first looks for package code in the global array LOAD_PATH. require is case-sensitive on all platforms, including those with case-insensitive filesystems like macOS and Windows.\n\nFor more details regarding code loading, see the manual sections on modules and parallel computing.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reset-Tuple{T} where T<:IO","page":"References","title":"Base.reset","text":"reset(s)\n\nReset a stream s to a previously marked position, and remove the mark. Return the previously marked position. Throw an error if the stream is not marked.\n\nSee also mark, unmark, ismarked.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reshape","page":"References","title":"Base.reshape","text":"reshape(A, dims...) -> AbstractArray\nreshape(A, dims) -> AbstractArray\n\nReturn an array with the same data as A, but with different dimension sizes or number of dimensions. The two arrays share the same underlying data, so that the result is mutable if and only if A is mutable, and setting elements of one alters the values of the other.\n\nThe new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a :, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array A. The total number of elements must not change.\n\nExamples\n\njulia> A = Vector(1:16)\n16-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n\njulia> reshape(A, (4, 4))\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> reshape(A, 2, :)\n2×8 Matrix{Int64}:\n 1  3  5  7   9  11  13  15\n 2  4  6  8  10  12  14  16\n\njulia> reshape(1:6, 2, 3)\n2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:\n 1  3  5\n 2  4  6\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.resize!-Tuple{Vector{T} where T, Integer}","page":"References","title":"Base.resize!","text":"resize!(a::Vector, n::Integer) -> Vector\n\nResize a to contain n elements. If n is smaller than the current collection length, the first n elements will be retained. If n is larger, the new elements are not guaranteed to be initialized.\n\nExamples\n\njulia> resize!([6, 5, 4, 3, 2, 1], 3)\n3-element Vector{Int64}:\n 6\n 5\n 4\n\njulia> a = resize!([6, 5, 4, 3, 2, 1], 8);\n\njulia> length(a)\n8\n\njulia> a[1:6]\n6-element Vector{Int64}:\n 6\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rest","page":"References","title":"Base.rest","text":"Base.rest(collection[, itr_state])\n\nGeneric function for taking the tail of collection, starting from a specific iteration state itr_state. Return a Tuple, if collection itself is a Tuple, a subtype of AbstractVector, if collection is an AbstractArray, a subtype of AbstractString if collection is an AbstractString, and an arbitrary iterator, falling back to Iterators.rest(collection[, itr_state]), otherwise. Can be overloaded for user-defined collection types to customize the behavior of slurping in assignments, like a, b... = collection.\n\ncompat: Julia 1.6\nBase.rest requires at least Julia 1.6.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> first, state = iterate(a)\n(1, 2)\n\njulia> first, Base.rest(a, state)\n(1, [3, 2, 4])\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.rethrow-Tuple{}","page":"References","title":"Base.rethrow","text":"rethrow()\n\nRethrow the current exception from within a catch block. The rethrown exception will continue propagation as if it had not been caught.\n\nnote: Note\nThe alternative form rethrow(e) allows you to associate an alternative exception object e with the current backtrace. However this misrepresents the program state at the time of the error so you're encouraged to instead throw a new exception using throw(e). In Julia 1.1 and above, using throw(e) will preserve the root cause exception on the stack, as described in catch_stack.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.retry-Tuple{Any}","page":"References","title":"Base.retry","text":"retry(f;  delays=ExponentialBackOff(), check=nothing) -> Function\n\nReturn an anonymous function that calls function f.  If an exception arises, f is repeatedly called again, each time check returns true, after waiting the number of seconds specified in delays.  check should input delays's current state and the Exception.\n\ncompat: Julia 1.2\nBefore Julia 1.2 this signature was restricted to f::Function.\n\nExamples\n\nretry(f, delays=fill(5.0, 3))\nretry(f, delays=rand(5:10, 2))\nretry(f, delays=Base.ExponentialBackOff(n=3, first_delay=5, max_delay=1000))\nretry(http_get, check=(s,e)->e.status == \"503\")(url)\nretry(read, check=(s,e)->isa(e, IOError))(io, 128; all=false)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reverse","page":"References","title":"Base.reverse","text":"reverse(v [, start=1 [, stop=length(v) ]] )\n\nReturn a copy of v reversed from start to stop.  See also Iterators.reverse for reverse-order iteration without making a copy.\n\nExamples\n\njulia> A = Vector(1:5)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> reverse(A)\n5-element Vector{Int64}:\n 5\n 4\n 3\n 2\n 1\n\njulia> reverse(A, 1, 4)\n5-element Vector{Int64}:\n 4\n 3\n 2\n 1\n 5\n\njulia> reverse(A, 3, 5)\n5-element Vector{Int64}:\n 1\n 2\n 5\n 4\n 3\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.reverse!","page":"References","title":"Base.reverse!","text":"reverse!(v [, start=1 [, stop=length(v) ]]) -> v\n\nIn-place version of reverse.\n\nExamples\n\njulia> A = Vector(1:5)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> reverse!(A);\n\njulia> A\n5-element Vector{Int64}:\n 5\n 4\n 3\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.reverse!-Tuple{AbstractArray}","page":"References","title":"Base.reverse!","text":"reverse!(A; dims=:)\n\nLike reverse, but operates in-place in A.\n\ncompat: Julia 1.6\nMultidimensional reverse! requires Julia 1.6.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reverse-Tuple{AbstractArray}","page":"References","title":"Base.reverse","text":"reverse(A; dims=:)\n\nReverse A along dimension dims, which can be an integer (a single dimension), a tuple of integers (a tuple of dimensions) or : (reverse along all the dimensions, the default).  See also reverse! for in-place reversal.\n\nExamples\n\njulia> b = Int64[1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> reverse(b, dims=2)\n2×2 Matrix{Int64}:\n 2  1\n 4  3\n\njulia> reverse(b)\n2×2 Matrix{Int64}:\n 4  3\n 2  1\n\ncompat: Julia 1.6\nPrior to Julia 1.6, only single-integer dims are supported in reverse.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reverse-Tuple{Union{SubString{String}, String}}","page":"References","title":"Base.reverse","text":"reverse(s::AbstractString) -> AbstractString\n\nReverses a string. Technically, this function reverses the codepoints in a string and its main utility is for reversed-order string processing, especially for reversed regular-expression searches. See also reverseind to convert indices in s to indices in reverse(s) and vice-versa, and graphemes from module Unicode to operate on user-visible \"characters\" (graphemes) rather than codepoints. See also Iterators.reverse for reverse-order iteration without making a copy. Custom string types must implement the reverse function themselves and should typically return a string with the same type and encoding. If they return a string with a different encoding, they must also override reverseind for that string type to satisfy s[reverseind(s,i)] == reverse(s)[i].\n\nExamples\n\njulia> reverse(\"JuliaLang\")\n\"gnaLailuJ\"\n\nnote: Note\nThe examples below may be rendered differently on different systems. The comments indicate how they're supposed to be rendered\n\nCombining characters can lead to surprising results:\n\njulia> reverse(\"ax̂e\") # hat is above x in the input, above e in the output\n\"êxa\"\n\njulia> using Unicode\n\njulia> join(reverse(collect(graphemes(\"ax̂e\")))) # reverses graphemes; hat is above x in both in- and output\n\"ex̂a\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.reverseind-Tuple{AbstractString, Integer}","page":"References","title":"Base.reverseind","text":"reverseind(v, i)\n\nGiven an index i in reverse(v), return the corresponding index in v so that v[reverseind(v,i)] == reverse(v)[i]. (This can be nontrivial in cases where v contains non-ASCII characters.)\n\nExamples\n\njulia> r = reverse(\"Julia\")\n\"ailuJ\"\n\njulia> for i in 1:length(r)\n           print(r[reverseind(\"Julia\", i)])\n       end\nJulia\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rot180-Tuple{AbstractMatrix{T} where T, Integer}","page":"References","title":"Base.rot180","text":"rot180(A, k)\n\nRotate matrix A 180 degrees an integer k number of times. If k is even, this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rot180(a,1)\n2×2 Matrix{Int64}:\n 4  3\n 2  1\n\njulia> rot180(a,2)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rot180-Tuple{AbstractMatrix{T} where T}","page":"References","title":"Base.rot180","text":"rot180(A)\n\nRotate matrix A 180 degrees.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rot180(a)\n2×2 Matrix{Int64}:\n 4  3\n 2  1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rotl90-Tuple{AbstractMatrix{T} where T, Integer}","page":"References","title":"Base.rotl90","text":"rotl90(A, k)\n\nLeft-rotate matrix A 90 degrees counterclockwise an integer k number of times. If k is a multiple of four (including zero), this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rotl90(a,1)\n2×2 Matrix{Int64}:\n 2  4\n 1  3\n\njulia> rotl90(a,2)\n2×2 Matrix{Int64}:\n 4  3\n 2  1\n\njulia> rotl90(a,3)\n2×2 Matrix{Int64}:\n 3  1\n 4  2\n\njulia> rotl90(a,4)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rotl90-Tuple{AbstractMatrix{T} where T}","page":"References","title":"Base.rotl90","text":"rotl90(A)\n\nRotate matrix A left 90 degrees.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rotl90(a)\n2×2 Matrix{Int64}:\n 2  4\n 1  3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rotr90-Tuple{AbstractMatrix{T} where T, Integer}","page":"References","title":"Base.rotr90","text":"rotr90(A, k)\n\nRight-rotate matrix A 90 degrees clockwise an integer k number of times. If k is a multiple of four (including zero), this is equivalent to a copy.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rotr90(a,1)\n2×2 Matrix{Int64}:\n 3  1\n 4  2\n\njulia> rotr90(a,2)\n2×2 Matrix{Int64}:\n 4  3\n 2  1\n\njulia> rotr90(a,3)\n2×2 Matrix{Int64}:\n 2  4\n 1  3\n\njulia> rotr90(a,4)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rotr90-Tuple{AbstractMatrix{T} where T}","page":"References","title":"Base.rotr90","text":"rotr90(A)\n\nRotate matrix A right 90 degrees.\n\nExamples\n\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> rotr90(a)\n2×2 Matrix{Int64}:\n 3  1\n 4  2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.round","page":"References","title":"Base.round","text":"round(z::Complex[, RoundingModeReal, [RoundingModeImaginary]])\nround(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; digits=, base=10)\nround(z::Complex[, RoundingModeReal, [RoundingModeImaginary]]; sigdigits=, base=10)\n\nReturn the nearest integral value of the same type as the complex-valued z to z, breaking ties using the specified RoundingModes. The first RoundingMode is used for rounding the real components while the second is used for rounding the imaginary components.\n\nExample\n\njulia> round(3.14 + 4.5im)\n3.0 + 4.0im\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.round-Tuple{Type, Any}","page":"References","title":"Base.round","text":"round([T,] x, [r::RoundingMode])\nround(x, [r::RoundingMode]; digits::Integer=0, base = 10)\nround(x, [r::RoundingMode]; sigdigits::Integer, base = 10)\n\nRounds the number x.\n\nWithout keyword arguments, x is rounded to an integer value, returning a value of type T, or of the same type of x if no T is provided. An InexactError will be thrown if the value is not representable by T, similar to convert.\n\nIf the digits keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base base.\n\nIf the sigdigits keyword argument is provided, it rounds to the specified number of significant digits, in base base.\n\nThe RoundingMode r controls the direction of the rounding; the default is RoundNearest, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that round may give incorrect results if the global rounding mode is changed (see rounding).\n\nExamples\n\njulia> round(1.7)\n2.0\n\njulia> round(Int, 1.7)\n2\n\njulia> round(1.5)\n2.0\n\njulia> round(2.5)\n2.0\n\njulia> round(pi; digits=2)\n3.14\n\njulia> round(pi; digits=3, base=2)\n3.125\n\njulia> round(123.456; sigdigits=2)\n120.0\n\njulia> round(357.913; sigdigits=4, base=2)\n352.0\n\nnote: Note\nRounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the Float64 value represented by 1.15 is actually less than 1.15, yet will be rounded to 1.2.Examplesjulia> x = 1.15\n1.15\n\njulia> @sprintf \"%.20f\" x\n\"1.14999999999999991118\"\n\njulia> x < 115//100\ntrue\n\njulia> round(x, digits=1)\n1.2\n\nExtensions\n\nTo extend round to new numeric types, it is typically sufficient to define Base.round(x::NewType, r::RoundingMode).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.rpad","page":"References","title":"Base.rpad","text":"rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -> String\n\nStringify s and pad the resulting string on the right with p to make it n characters (code points) long. If s is already n characters long, an equal string is returned. Pad with spaces by default.\n\nExamples\n\njulia> rpad(\"March\", 20)\n\"March               \"\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.rsplit","page":"References","title":"Base.rsplit","text":"rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)\nrsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)\n\nSimilar to split, but starting from the end of the string.\n\nExamples\n\njulia> a = \"M.a.r.c.h\"\n\"M.a.r.c.h\"\n\njulia> rsplit(a, \".\")\n5-element Vector{SubString{String}}:\n \"M\"\n \"a\"\n \"r\"\n \"c\"\n \"h\"\n\njulia> rsplit(a, \".\"; limit=1)\n1-element Vector{SubString{String}}:\n \"M.a.r.c.h\"\n\njulia> rsplit(a, \".\"; limit=2)\n2-element Vector{SubString{String}}:\n \"M.a.r.c\"\n \"h\"\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.rstrip-Tuple{Any, AbstractString}","page":"References","title":"Base.rstrip","text":"rstrip([pred=isspace,] str::AbstractString) -> SubString\nrstrip(str::AbstractString, chars) -> SubString\n\nRemove trailing characters from str, either those specified by chars or those for which the function pred returns true.\n\nThe default behaviour is to remove trailing whitespace and delimiters: see isspace for precise details.\n\nThe optional chars argument specifies which characters to remove: it can be a single character, or a vector or set of characters.\n\nExamples\n\njulia> a = rpad(\"March\", 20)\n\"March               \"\n\njulia> rstrip(a)\n\"March\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.run-Tuple{Base.AbstractCmd, Vararg{Any, N} where N}","page":"References","title":"Base.run","text":"run(command, args...; wait::Bool = true)\n\nRun a command object, constructed with backticks (see the Running External Programs section in the manual). Throws an error if anything goes wrong, including the process exiting with a non-zero status (when wait is true).\n\nIf wait is false, the process runs asynchronously. You can later wait for it and check its exit status by calling success on the returned process object.\n\nWhen wait is false, the process' I/O streams are directed to devnull. When wait is true, I/O streams are shared with the parent process. Use pipeline to control I/O redirection.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.runtests","page":"References","title":"Base.runtests","text":"Base.runtests(tests=[\"all\"]; ncores=ceil(Int, Sys.CPU_THREADS / 2),\n              exit_on_error=false, revise=false, [seed])\n\nRun the Julia unit tests listed in tests, which can be either a string or an array of strings, using ncores processors. If exit_on_error is false, when one test fails, all remaining tests in other files will still be run; they are otherwise discarded, when exit_on_error == true. If revise is true, the Revise package is used to load any modifications to Base or to the standard libraries before running the tests. If a seed is provided via the keyword argument, it is used to seed the global RNG in the context where the tests are run; otherwise the seed is chosen randomly.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.schedule-Tuple{Task, Any}","page":"References","title":"Base.schedule","text":"schedule(t::Task, [val]; error=false)\n\nAdd a Task to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as wait.\n\nIf a second argument val is provided, it will be passed to the task (via the return value of yieldto) when it runs again. If error is true, the value is raised as an exception in the woken task.\n\nExamples\n\njulia> a5() = sum(i for i in 1:1000);\n\njulia> b = Task(a5);\n\njulia> istaskstarted(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskstarted(b)\ntrue\n\njulia> istaskdone(b)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.securezero!","page":"References","title":"Base.securezero!","text":"securezero!(o)\n\nsecurezero! fills the memory associated with an object o with zeros. Unlike fill!(o,0) and similar code, which might be optimized away by the compiler for objects about to be discarded, the securezero! function will always be called.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.seek-Tuple{IOStream, Integer}","page":"References","title":"Base.seek","text":"seek(s, pos)\n\nSeek a stream to the given position.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> read(io, Char)\n'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.seekend-Tuple{IOStream}","page":"References","title":"Base.seekend","text":"seekend(s)\n\nSeek a stream to its end.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.seekstart-Tuple{IO}","page":"References","title":"Base.seekstart","text":"seekstart(s)\n\nSeek a stream to its beginning.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> read(io, Char)\n'L': ASCII/Unicode U+004C (category Lu: Letter, uppercase)\n\njulia> seekstart(io);\n\njulia> read(io, Char)\n'J': ASCII/Unicode U+004A (category Lu: Letter, uppercase)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.selectdim-Tuple{AbstractArray, Integer, Any}","page":"References","title":"Base.selectdim","text":"selectdim(A, d::Integer, i)\n\nReturn a view of all the data of A where the index for dimension d equals i.\n\nEquivalent to view(A,:,:,...,i,:,:,...) where i is in position d.\n\nExamples\n\njulia> A = [1 2 3 4; 5 6 7 8]\n2×4 Matrix{Int64}:\n 1  2  3  4\n 5  6  7  8\n\njulia> selectdim(A, 2, 3)\n2-element view(::Matrix{Int64}, :, 3) with eltype Int64:\n 3\n 7\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.setdiff!-Tuple{AbstractSet, Vararg{Any, N} where N}","page":"References","title":"Base.setdiff!","text":"setdiff!(s, itrs...)\n\nRemove from set s (in-place) each element of each iterable from itrs. Maintain order with arrays.\n\nExamples\n\njulia> a = Set([1, 3, 4, 5]);\n\njulia> setdiff!(a, 1:2:6);\n\njulia> a\nSet{Int64} with 1 element:\n  4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.setdiff-Tuple{AbstractSet, Vararg{Any, N} where N}","page":"References","title":"Base.setdiff","text":"setdiff(s, itrs...)\n\nConstruct the set of elements in s but not in any of the iterables in itrs. Maintain order with arrays.\n\nExamples\n\njulia> setdiff([1,2,3], [3,4,5])\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.setenv-Tuple{Cmd, Any}","page":"References","title":"Base.setenv","text":"setenv(command::Cmd, env; dir=\"\")\n\nSet environment variables to use when running the given command. env is either a dictionary mapping strings to strings, an array of strings of the form \"var=val\", or zero or more \"var\"=>val pair arguments. In order to modify (rather than replace) the existing environment, create env through copy(ENV) and then setting env[\"var\"]=val as desired, or use addenv.\n\nThe dir keyword argument can be used to specify a working directory for the command.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.setindex!","page":"References","title":"Base.setindex!","text":"setindex!(collection, value, key...)\n\nStore the given value at the given key or index within a collection. The syntax a[i,j,...] = x is converted by the compiler to (setindex!(a, x, i, j, ...); x).\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.setindex!-Tuple{AbstractArray, Any, Vararg{Any, N} where N}","page":"References","title":"Base.setindex!","text":"setindex!(A, X, inds...)\nA[inds...] = X\n\nStore values from array X within some subset of A as specified by inds. The syntax A[inds...] = X is equivalent to (setindex!(A, X, inds...); X).\n\nExamples\n\njulia> A = zeros(2,2);\n\njulia> setindex!(A, [10, 20], [1, 2]);\n\njulia> A[[3, 4]] = [30, 40];\n\njulia> A\n2×2 Matrix{Float64}:\n 10.0  30.0\n 20.0  40.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.setindex-Tuple{NamedTuple, Any, Symbol}","page":"References","title":"Base.setindex","text":"setindex(nt::NamedTuple, val, key::Symbol)\n\nConstructs a new NamedTuple with the key key set to val. If key is already in the keys of nt, val replaces the old value.\n\njulia> nt = (a = 3,)\n(a = 3,)\n\njulia> Base.setindex(nt, 33, :b)\n(a = 3, b = 33)\n\njulia> Base.setindex(nt, 4, :a)\n(a = 4,)\n\njulia> Base.setindex(nt, \"a\", :a)\n(a = \"a\",)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.setindex-Tuple{Tuple, Any, Integer}","page":"References","title":"Base.setindex","text":"setindex(c::Tuple, v, i::Integer)\n\nCreates a new tuple similar to x with the value at index i set to v. Throws a BoundsError when out of bounds.\n\nExamples\n\njulia> Base.setindex((1, 2, 6), 2, 3) == (1, 2, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.shell_escape-Tuple{Vararg{AbstractString, N} where N}","page":"References","title":"Base.shell_escape","text":"shell_escape(args::Union{Cmd,AbstractString...}; special::AbstractString=\"\")\n\nThe unexported shell_escape function is the inverse of the unexported shell_split function: it takes a string or command object and escapes any special characters in such a way that calling shell_split on it would give back the array of words in the original command. The special keyword argument controls what characters in addition to whitespace, backslashes, quotes and dollar signs are considered to be special (default: none).\n\nExamples\n\njulia> Base.shell_escape(\"cat\", \"/foo/bar baz\", \"&&\", \"echo\", \"done\")\n\"cat '/foo/bar baz' && echo done\"\n\njulia> Base.shell_escape(\"echo\", \"this\", \"&&\", \"that\")\n\"echo this && that\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.shell_escape_posixly-Tuple{Vararg{AbstractString, N} where N}","page":"References","title":"Base.shell_escape_posixly","text":"shell_escape_posixly(args::Union{Cmd,AbstractString...})\n\nThe unexported shell_escape_posixly function takes a string or command object and escapes any special characters in such a way that it is safe to pass it as an argument to a posix shell.\n\nExamples\n\njulia> Base.shell_escape_posixly(\"cat\", \"/foo/bar baz\", \"&&\", \"echo\", \"done\")\n\"cat '/foo/bar baz' '&&' echo done\"\n\njulia> Base.shell_escape_posixly(\"echo\", \"this\", \"&&\", \"that\")\n\"echo this '&&' that\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.shell_escape_wincmd-Tuple{IO, AbstractString}","page":"References","title":"Base.shell_escape_wincmd","text":"shell_escape_wincmd(s::AbstractString)\nshell_escape_wincmd(io::IO, s::AbstractString)\n\nThe unexported shell_escape_wincmd function escapes Windows cmd.exe shell meta characters. It escapes ()!^<>&| by placing a ^ in front. An @ is only escaped at the start of the string. Pairs of \" characters and the strings they enclose are passed through unescaped. Any remaining \" is escaped with ^ to ensure that the number of unescaped \" characters in the result remains even.\n\nSince cmd.exe substitutes variable references (like %USER%) before processing the escape characters ^ and \", this function makes no attempt to escape the percent sign (%), the presence of % in the input may cause severe breakage, depending on where the result is used.\n\nInput strings with ASCII control characters that cannot be escaped (NUL, CR, LF) will cause an ArgumentError exception.\n\nThe result is safe to pass as an argument to a command call being processed by CMD.exe /S /C \" ... \" (with surrounding double-quote pair) and will be received verbatim by the target application if the input does not contain % (else this function will fail with an ArgumentError). The presence of % in the input string may result in command injection vulnerabilities and may invalidate any claim of suitability of the output of this function for use as an argument to cmd (due to the ordering described above), so use caution when assembling a string from various sources.\n\nThis function may be useful in concert with the windows_verbatim flag to Cmd when constructing process pipelines.\n\nwincmd(c::String) =\n   run(Cmd(Cmd([\"cmd.exe\", \"/s /c \" $c \"\"]);\n           windows_verbatim=true))\nwincmd_echo(s::String) =\n   wincmd(\"echo \" * Base.shell_escape_wincmd(s))\nwincmd_echo(\"hello $(ENV[\"USERNAME\"]) & the \"whole\" world! (=^I^=)\")\n\nBut take note that if the input string s contains a %, the argument list and echo'ed text may get corrupted, resulting in arbitrary command execution. The argument can alternatively be passed as an environment variable, which avoids the problem with % and the need for the windows_verbatim flag:\n\ncmdargs = Base.shell_escape_wincmd(\"Passing args with %cmdargs% works 100%!\")\nrun(setenv(`cmd /C echo %cmdargs%`, \"cmdargs\" => cmdargs))\n\n!warning     The argument parsing done by CMD when calling batch files (either inside     .bat files or as arguments to them) is not fully compatible with the     output of this function. In particular, the processing of % is different.\n\n!important     Due to a peculiar behavior of the CMD parser/interpreter, each command     after a literal | character (indicating a command pipeline) must have     shell_escape_wincmd applied twice since it will be parsed twice by CMD.     This implies ENV variables would also be expanded twice!     For example:\n\n    to_print = \"All for 1 & 1 for all!\"\n    to_print_esc = Base.shell_escape_wincmd(Base.shell_escape_wincmd(to_print))\n    run(Cmd(Cmd([\"cmd\", \"/S /C \" break | echo $(to_print_esc) \"\"]), windows_verbatim=true))\n    ```\n\nWith an I/O stream parameter `io`, the result will be written there,\nrather than returned as a string.\n\nSee also: [`escape_microsoft_c_args`](@ref), [`shell_escape_posixly`](@ref)\n\n# Example\n\njldoctest julia> Base.shellescapewincmd(\"a^\\\"^o\\\"^u\\\"\") \"a^^\\\"^o\\\"^^u^\\\"\" ```\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.show-Tuple{IO, Any}","page":"References","title":"Base.show","text":"show([io::IO = stdout], x)\n\nWrite a text representation of a value x to the output stream io. New types T should overload show(io::IO, x::T). The representation used by show generally includes Julia-specific formatting and type information, and should be parseable Julia code when possible.\n\nrepr returns the output of show as a string.\n\nTo customize human-readable text output for objects of type T, define show(io::IO, ::MIME\"text/plain\", ::T) instead. Checking the :compact IOContext property of io in such methods is recommended, since some containers show their elements by calling this method with :compact => true.\n\nSee also print, which writes un-decorated representations.\n\nExamples\n\njulia> show(\"Hello World!\")\n\"Hello World!\"\njulia> print(\"Hello World!\")\nHello World!\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.show_invalid","page":"References","title":"Base.show_invalid","text":"show_invalid(io::IO, c::AbstractChar)\n\nCalled by show(io, c) when isoverlong(c) or ismalformed(c) return true.   Subclasses of AbstractChar should define Base.show_invalid methods if they support storing invalid character data.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.showarg-Tuple{IO, Type, Any}","page":"References","title":"Base.showarg","text":"showarg(io::IO, x, toplevel)\n\nShow x as if it were an argument to a function. This function is used by summary to display type information in terms of sequences of function calls on objects. toplevel is true if this is the direct call from summary and false for nested (recursive) calls.\n\nThe fallback definition is to print x as \"::$(typeof(x))\", representing argument x in terms of its type. (The double-colon is omitted if toplevel=true.) However, you can specialize this function for specific types to customize printing.\n\nExample\n\nA SubArray created as view(a, :, 3, 2:5), where a is a 3-dimensional Float64 array, has type\n\nSubArray{Float64, 2, Array{Float64, 3}, Tuple{Colon, Int64, UnitRange{Int64}}, false}\n\nThe default show printing would display this full type. However, the summary for SubArrays actually prints as\n\n2×4 view(::Array{Float64, 3}, :, 3, 2:5) with eltype Float64\n\nbecause of a definition similar to\n\nfunction Base.showarg(io::IO, v::SubArray, toplevel)\n    print(io, \"view(\")\n    showarg(io, parent(v), false)\n    print(io, \", \", join(v.indices, \", \"))\n    print(io, ')')\n    toplevel && print(io, \" with eltype \", eltype(v))\nend\n\nNote that we're calling showarg recursively for the parent array type, indicating that any recursed calls are not at the top level. Printing the parent as ::Array{Float64,3} is the fallback (non-toplevel) behavior, because no specialized method for Array has been defined.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.showerror-Tuple{IO, Any}","page":"References","title":"Base.showerror","text":"showerror(io, e)\n\nShow a descriptive representation of an exception object e. This method is used to display the exception after a call to throw.\n\nExamples\n\njulia> struct MyException <: Exception\n           msg::AbstractString\n       end\n\njulia> function Base.showerror(io::IO, err::MyException)\n           print(io, \"MyException: \")\n           print(io, err.msg)\n       end\n\njulia> err = MyException(\"test exception\")\nMyException(\"test exception\")\n\njulia> sprint(showerror, err)\n\"MyException: test exception\"\n\njulia> throw(MyException(\"test exception\"))\nERROR: MyException: test exception\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.sign-Tuple{Number}","page":"References","title":"Base.sign","text":"sign(x)\n\nReturn zero if x==0 and xx otherwise (i.e., ±1 for real x).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.signbit-Tuple{Real}","page":"References","title":"Base.signbit","text":"signbit(x)\n\nReturns true if the value of the sign of x is negative, otherwise false.\n\nExamples\n\njulia> signbit(-4)\ntrue\n\njulia> signbit(5)\nfalse\n\njulia> signbit(5.5)\nfalse\n\njulia> signbit(-4.1)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.signed-Tuple{Any}","page":"References","title":"Base.signed","text":"signed(x)\n\nConvert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.signed-Tuple{Type{Bool}}","page":"References","title":"Base.signed","text":"signed(T::Integer)\n\nConvert an integer bitstype to the signed type of the same size.\n\nExamples\n\njulia> signed(UInt16)\nInt16\njulia> signed(UInt64)\nInt64\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.similar-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T","page":"References","title":"Base.similar","text":"similar(array, [element_type=eltype(array)], [dims=size(array)])\n\nCreate an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array's eltype and size. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.\n\nCustom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an Array{element_type}(undef, dims...).\n\nFor example, similar(1:10, 1, 4) returns an uninitialized Array{Int,2} since ranges are neither mutable nor support 2 dimensions:\n\njulia> similar(1:10, 1, 4)\n1×4 Array{Int64,2}:\n 4419743872  4374413872  4419743888  0\n\nConversely, similar(trues(10,10), 2) returns an uninitialized BitVector with two elements since BitArrays are both mutable and can support 1-dimensional arrays:\n\njulia> similar(trues(10,10), 2)\n2-element BitVector:\n 0\n 0\n\nSince BitArrays can only store elements of type Bool, however, if you request a different element type it will create a regular Array instead:\n\njulia> similar(falses(10), Float64, 2, 4)\n2×4 Array{Float64,2}:\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.similar-Union{Tuple{T}, Tuple{Type{T}, Vararg{Union{Integer, AbstractUnitRange}, N} where N}} where T<:AbstractArray","page":"References","title":"Base.similar","text":"similar(storagetype, axes)\n\nCreate an uninitialized mutable array analogous to that specified by storagetype, but with axes specified by the last argument.\n\nExamples:\n\nsimilar(Array{Int}, axes(A))\n\ncreates an array that \"acts like\" an Array{Int} (and might indeed be backed by one), but which is indexed identically to A. If A has conventional indexing, this will be identical to Array{Int}(undef, size(A)), but if A has unconventional indexing then the indices of the result will match A.\n\nsimilar(BitArray, (axes(A, 2),))\n\nwould create a 1-dimensional logical array whose indices match those of the columns of A.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.size-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any}} where {T, N}","page":"References","title":"Base.size","text":"size(A::AbstractArray, [dim])\n\nReturn a tuple containing the dimensions of A. Optionally you can specify a dimension to just get the length of that dimension.\n\nNote that size may not be defined for arrays with non-standard indices, in which case axes may be useful. See the manual chapter on arrays with custom indices.\n\nExamples\n\njulia> A = fill(1, (2,3,4));\n\njulia> size(A)\n(2, 3, 4)\n\njulia> size(A, 2)\n3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.sizehint!","page":"References","title":"Base.sizehint!","text":"sizehint!(s, n)\n\nSuggest that collection s reserve capacity for at least n elements. This can improve performance.\n\nNotes on the performance model\n\nFor types that support sizehint!,\n\npush! and append! methods generally may (but are not required to) preallocate extra\n\nstorage. For types implemented in Base, they typically do, using a heuristic optimized for a general use case.\n\nsizehint! may control this preallocation. Again, it typically does this for types in\n\nBase.\n\nempty! is nearly costless (and O(1)) for types that support this kind of preallocation.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.sizeof-Tuple{AbstractString}","page":"References","title":"Base.sizeof","text":"sizeof(str::AbstractString)\n\nSize, in bytes, of the string str. Equal to the number of code units in str multiplied by the size, in bytes, of one code unit in str.\n\nExamples\n\njulia> sizeof(\"\")\n0\n\njulia> sizeof(\"∀\")\n3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.sizeof-Tuple{Any}","page":"References","title":"Base.sizeof","text":"sizeof(T::DataType)\nsizeof(obj)\n\nSize, in bytes, of the canonical binary representation of the given DataType T, if any. Size, in bytes, of object obj if it is not DataType.\n\nExamples\n\njulia> sizeof(Float32)\n4\n\njulia> sizeof(ComplexF64)\n16\n\njulia> sizeof(1.0)\n8\n\njulia> sizeof([1.0:10.0;])\n80\n\nIf DataType T does not have a specific size, an error is thrown.\n\njulia> sizeof(AbstractArray)\nERROR: Abstract type AbstractArray does not have a definite size.\nStacktrace:\n[...]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.skip-Tuple{IOStream, Integer}","page":"References","title":"Base.skip","text":"skip(s, offset)\n\nSeek a stream relative to the current position.\n\nExamples\n\njulia> io = IOBuffer(\"JuliaLang is a GitHub organization.\");\n\njulia> seek(io, 5);\n\njulia> skip(io, 10);\n\njulia> read(io, Char)\n'G': ASCII/Unicode U+0047 (category Lu: Letter, uppercase)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.skipchars-Tuple{Any, IO}","page":"References","title":"Base.skipchars","text":"skipchars(predicate, io::IO; linecomment=nothing)\n\nAdvance the stream io such that the next-read character will be the first remaining for which predicate returns false. If the keyword argument linecomment is specified, all characters from that character until the start of the next line are ignored.\n\nExamples\n\njulia> buf = IOBuffer(\"    text\")\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=1, mark=-1)\n\njulia> skipchars(isspace, buf)\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=8, maxsize=Inf, ptr=5, mark=-1)\n\njulia> String(readavailable(buf))\n\"text\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.skipmissing-Tuple{Any}","page":"References","title":"Base.skipmissing","text":"skipmissing(itr)\n\nReturn an iterator over the elements in itr skipping missing values. The returned object can be indexed using indices of itr if the latter is indexable. Indices corresponding to missing values are not valid: they are skipped by keys and eachindex, and a MissingException is thrown when trying to use them.\n\nUse collect to obtain an Array containing the non-missing values in itr. Note that even if itr is a multidimensional array, the result will always be a Vector since it is not possible to remove missings while preserving dimensions of the input.\n\nExamples\n\njulia> x = skipmissing([1, missing, 2])\nskipmissing(Union{Missing, Int64}[1, missing, 2])\n\njulia> sum(x)\n3\n\njulia> x[1]\n1\n\njulia> x[2]\nERROR: MissingException: the value at index (2,) is missing\n[...]\n\njulia> argmax(x)\n3\n\njulia> collect(keys(x))\n2-element Vector{Int64}:\n 1\n 3\n\njulia> collect(skipmissing([1, missing, 2]))\n2-element Vector{Int64}:\n 1\n 2\n\njulia> collect(skipmissing([1 missing; 2 missing]))\n2-element Vector{Int64}:\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.sleep-Tuple{Real}","page":"References","title":"Base.sleep","text":"sleep(seconds)\n\nBlock the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of 0.001.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.something","page":"References","title":"Base.something","text":"something(x, y...)\n\nReturn the first value in the arguments which is not equal to nothing, if any. Otherwise throw an error. Arguments of type Some are unwrapped.\n\nSee also coalesce.\n\nExamples\n\njulia> something(nothing, 1)\n1\n\njulia> something(Some(1), nothing)\n1\n\njulia> something(missing, nothing)\nmissing\n\njulia> something(nothing, nothing)\nERROR: ArgumentError: No value arguments present\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.sortslices-Tuple{AbstractArray}","page":"References","title":"Base.sortslices","text":"sortslices(A; dims, alg::Algorithm=DEFAULT_UNSTABLE, lt=isless, by=identity, rev::Bool=false, order::Ordering=Forward)\n\nSort slices of an array A. The required keyword argument dims must be either an integer or a tuple of integers. It specifies the dimension(s) over which the slices are sorted.\n\nE.g., if A is a matrix, dims=1 will sort rows, dims=2 will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.\n\nFor the remaining keyword arguments, see the documentation of sort!.\n\nExamples\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1) # Sort rows\n3×3 Matrix{Int64}:\n -1   6  4\n  7   3  5\n  9  -2  8\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, lt=(x,y)->isless(x[2],y[2]))\n3×3 Matrix{Int64}:\n  9  -2  8\n  7   3  5\n -1   6  4\n\njulia> sortslices([7 3 5; -1 6 4; 9 -2 8], dims=1, rev=true)\n3×3 Matrix{Int64}:\n  9  -2  8\n  7   3  5\n -1   6  4\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2) # Sort columns\n3×3 Matrix{Int64}:\n  3   5  7\n -1  -4  6\n -2   8  9\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, alg=InsertionSort, lt=(x,y)->isless(x[2],y[2]))\n3×3 Matrix{Int64}:\n  5   3  7\n -4  -1  6\n  8  -2  9\n\njulia> sortslices([7 3 5; 6 -1 -4; 9 -2 8], dims=2, rev=true)\n3×3 Matrix{Int64}:\n 7   5   3\n 6  -4  -1\n 9   8  -2\n\nHigher dimensions\n\nsortslices extends naturally to higher dimensions. E.g., if A is a a 2x2x2 array, sortslices(A, dims=3) will sort slices within the 3rd dimension, passing the 2x2 slices A[:, :, 1] and A[:, :, 2] to the comparison function. Note that while there is no default order on higher-dimensional slices, you may use the by or lt keyword argument to specify such an order.\n\nIf dims is a tuple, the order of the dimensions in dims is relevant and specifies the linear order of the slices. E.g., if A is three dimensional and dims is (1, 2), the orderings of the first two dimensions are re-arranged such that the slices (of the remaining third dimension) are sorted. If dims is (2, 1) instead, the same slices will be taken, but the result order will be row-major instead.\n\nHigher dimensional examples\n\njulia> A = permutedims(reshape([4 3; 2 1; 'A' 'B'; 'C' 'D'], (2, 2, 2)), (1, 3, 2))\n2×2×2 Array{Any, 3}:\n[:, :, 1] =\n 4  3\n 2  1\n\n[:, :, 2] =\n 'A'  'B'\n 'C'  'D'\n\njulia> sortslices(A, dims=(1,2))\n2×2×2 Array{Any, 3}:\n[:, :, 1] =\n 1  3\n 2  4\n\n[:, :, 2] =\n 'D'  'B'\n 'C'  'A'\n\njulia> sortslices(A, dims=(2,1))\n2×2×2 Array{Any, 3}:\n[:, :, 1] =\n 1  2\n 3  4\n\n[:, :, 2] =\n 'D'  'C'\n 'B'  'A'\n\njulia> sortslices(reshape([5; 4; 3; 2; 1], (1,1,5)), dims=3, by=x->x[1,1])\n1×1×5 Array{Int64, 3}:\n[:, :, 1] =\n 1\n\n[:, :, 2] =\n 2\n\n[:, :, 3] =\n 3\n\n[:, :, 4] =\n 4\n\n[:, :, 5] =\n 5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.splat-Tuple{Any}","page":"References","title":"Base.splat","text":"splat(f)\n\nDefined as\n\n    splat(f) = args->f(args...)\n\ni.e. given a function returns a new function that takes one argument and splats its argument into the original function. This is useful as an adaptor to pass a multi-argument function in a context that expects a single argument, but passes a tuple as that single argument.\n\nExample usage:\n\njulia> map(Base.splat(+), zip(1:3,4:6))\n3-element Vector{Int64}:\n 5\n 7\n 9\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.splice!","page":"References","title":"Base.splice!","text":"splice!(a::Vector, index::Integer, [replacement]) -> item\n\nRemove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.\n\nExamples\n\njulia> A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)\n2\n\njulia> A\n5-element Vector{Int64}:\n 6\n 5\n 4\n 3\n 1\n\njulia> splice!(A, 5, -1)\n1\n\njulia> A\n5-element Vector{Int64}:\n  6\n  5\n  4\n  3\n -1\n\njulia> splice!(A, 1, [-1, -2, -3])\n6\n\njulia> A\n7-element Vector{Int64}:\n -1\n -2\n -3\n  5\n  4\n  3\n -1\n\nTo insert replacement before an index n without removing any items, use splice!(collection, n:n-1, replacement).\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.splice!-2","page":"References","title":"Base.splice!","text":"splice!(a::Vector, indices, [replacement]) -> items\n\nRemove items at specified indices, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gaps. If specified, replacement values from an ordered collection will be spliced in place of the removed items; in this case, indices must be a UnitRange.\n\nTo insert replacement before an index n without removing any items, use splice!(collection, n:n-1, replacement).\n\ncompat: Julia 1.5\nPrior to Julia 1.5, indices must always be a UnitRange.\n\nExamples\n\njulia> A = [-1, -2, -3, 5, 4, 3, -1]; splice!(A, 4:3, 2)\nInt64[]\n\njulia> A\n8-element Vector{Int64}:\n -1\n -2\n -3\n  2\n  5\n  4\n  3\n -1\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.split","page":"References","title":"Base.split","text":"split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)\nsplit(str::AbstractString; limit::Integer=0, keepempty::Bool=false)\n\nSplit str into an array of substrings on occurrences of the delimiter(s) dlm.  dlm can be any of the formats allowed by findnext's first argument (i.e. as a string, regular expression or a function), or as a single character or collection of characters.\n\nIf dlm is omitted, it defaults to isspace.\n\nThe optional keyword arguments are:\n\nlimit: the maximum size of the result. limit=0 implies no maximum (default)\nkeepempty: whether empty fields should be kept in the result. Default is false without a dlm argument, true with a dlm argument.\n\nSee also rsplit.\n\nExamples\n\njulia> a = \"Ma.rch\"\n\"Ma.rch\"\n\njulia> split(a, \".\")\n2-element Vector{SubString{String}}:\n \"Ma\"\n \"rch\"\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.splitprec-Union{Tuple{F}, Tuple{Type{F}, Integer}} where F<:AbstractFloat","page":"References","title":"Base.splitprec","text":"hi, lo = splitprec(F::Type{<:AbstractFloat}, i::Integer)\n\nRepresent an integer i as a pair of floating-point numbers hi and lo (of type F) such that:\n\nwiden(hi) + widen(lo) ≈ i. It is exact if 1.5 * (number of precision bits in F) is greater than the number of bits in i.\nall bits in hi are more significant than any of the bits in lo\nhi can be exactly multiplied by the hi component of another call to splitprec.\n\nIn particular, while convert(Float64, i) can be lossy since Float64 has only 53 bits of precision, splitprec(Float64, i) is exact for any Int64/UInt64.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.sprint-Tuple{Function, Vararg{Any, N} where N}","page":"References","title":"Base.sprint","text":"sprint(f::Function, args...; context=nothing, sizehint=0)\n\nCall the given function with an I/O stream and the supplied extra arguments. Everything written to this I/O stream is returned as a string. context can be either an IOContext whose properties will be used, or a Pair specifying a property and its value. sizehint suggests the capacity of the buffer (in bytes).\n\nThe optional keyword argument context can be set to :key=>value pair or an IO or IOContext object whose attributes are used for the I/O stream passed to f.  The optional sizehint is a suggested size (in bytes) to allocate for the buffer used to write the string.\n\nExamples\n\njulia> sprint(show, 66.66666; context=:compact => true)\n\"66.6667\"\n\njulia> sprint(showerror, BoundsError([1], 100))\n\"BoundsError: attempt to access 1-element Vector{Int64} at index [100]\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.startswith-Tuple{AbstractString, AbstractString}","page":"References","title":"Base.startswith","text":"startswith(s::AbstractString, prefix::AbstractString)\n\nReturn true if s starts with prefix. If prefix is a vector or set of characters, test whether the first character of s belongs to that set.\n\nSee also endswith.\n\nExamples\n\njulia> startswith(\"JuliaLang\", \"Julia\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.startswith-Tuple{AbstractString, Regex}","page":"References","title":"Base.startswith","text":"startswith(s::AbstractString, prefix::Regex)\n\nReturn true if s starts with the regex pattern, prefix.\n\nnote: Note\nstartswith does not compile the anchoring into the regular expression, but instead passes the anchoring as match_option to PCRE. If compile time is amortized, occursin(r\"^...\", s) is faster than startswith(s, r\"...\").\n\nSee also occursin and endswith.\n\ncompat: Julia 1.2\nThis method requires at least Julia 1.2.\n\nExamples\n\njulia> startswith(\"JuliaLang\", r\"Julia|Romeo\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.startswith-Tuple{Any}","page":"References","title":"Base.startswith","text":"startswith(prefix)\n\nCreate a function that checks whether its argument starts with prefix, i.e. a function equivalent to y -> startswith(y, prefix).\n\nThe returned function is of type Base.Fix2{typeof(startswith)}, which can be used to implement specialized methods.\n\ncompat: Julia 1.5\nThe single argument startswith(prefix) requires at least Julia 1.5.\n\nExamples\n\njulia> startswith_julia = startswith(\"Julia\");\n\njulia> startswith_julia(\"Julia\")\ntrue\n\njulia> startswith_julia(\"NotJulia\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.step-Tuple{StepRange}","page":"References","title":"Base.step","text":"step(r)\n\nGet the step size of an AbstractRange object.\n\nExamples\n\njulia> step(1:10)\n1\n\njulia> step(1:2:10)\n2\n\njulia> step(2.5:0.3:10.9)\n0.3\n\njulia> step(range(2.5, stop=10.9, length=85))\n0.1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.stride-Tuple{AbstractArray, Integer}","page":"References","title":"Base.stride","text":"stride(A, k::Integer)\n\nReturn the distance in memory (in number of elements) between adjacent elements in dimension k.\n\nExamples\n\njulia> A = fill(1, (3,4,5));\n\njulia> stride(A,2)\n3\n\njulia> stride(A,3)\n12\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.strides","page":"References","title":"Base.strides","text":"strides(A)\n\nReturn a tuple of the memory strides in each dimension.\n\nExamples\n\njulia> A = fill(1, (3,4,5));\n\njulia> strides(A)\n(1, 3, 12)\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.string-Tuple","page":"References","title":"Base.string","text":"string(xs...)\n\nCreate a string from any values using the print function.\n\nstring should usually not be defined directly. Instead, define a method print(io::IO, x::MyType). If string(x) for a certain type needs to be highly efficient, then it may make sense to add a method to string and define print(io::IO, x::MyType) = print(io, string(x)) to ensure the functions are consistent.\n\nExamples\n\njulia> string(\"a\", 1, true)\n\"a1true\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.string-Tuple{Integer}","page":"References","title":"Base.string","text":"string(n::Integer; base::Integer = 10, pad::Integer = 1)\n\nConvert an integer n to a string in the given base, optionally specifying a number of digits to pad to.\n\njulia> string(5, base = 13, pad = 4)\n\"0005\"\n\njulia> string(13, base = 5, pad = 4)\n\"0023\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.strip-Tuple{AbstractString}","page":"References","title":"Base.strip","text":"strip([pred=isspace,] str::AbstractString) -> SubString\nstrip(str::AbstractString, chars) -> SubString\n\nRemove leading and trailing characters from str, either those specified by chars or those for which the function pred returns true.\n\nThe default behaviour is to remove leading whitespace and delimiters: see isspace for precise details.\n\nThe optional chars argument specifies which characters to remove: it can be a single character, vector or set of characters.\n\ncompat: Julia 1.2\nThe method which accepts a predicate function requires Julia 1.2 or later.\n\nExamples\n\njulia> strip(\"{3, 5}\\n\", ['{', '}', '\\n'])\n\"3, 5\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.structdiff-Union{Tuple{bn}, Tuple{an}, Tuple{NamedTuple{an, T} where T<:Tuple, Union{Type{NamedTuple{bn, T} where T<:Tuple}, NamedTuple{bn, T} where T<:Tuple}}} where {an, bn}","page":"References","title":"Base.structdiff","text":"structdiff(a::NamedTuple{an}, b::Union{NamedTuple{bn},Type{NamedTuple{bn}}}) where {an,bn}\n\nConstruct a copy of named tuple a, except with fields that exist in b removed. b can be a named tuple, or a type of the form NamedTuple{field_names}.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.success-Tuple{Base.AbstractCmd}","page":"References","title":"Base.success","text":"success(command)\n\nRun a command object, constructed with backticks (see the Running External Programs section in the manual), and tell whether it was successful (exited with a code of 0). An exception is raised if the process cannot be started.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.sum!-Tuple{Any, Any}","page":"References","title":"Base.sum!","text":"sum!(r, A)\n\nSum elements of A over the singleton dimensions of r, and write results to r.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sum!([1; 1], A)\n2-element Vector{Int64}:\n 3\n 7\n\njulia> sum!([1 1], A)\n1×2 Matrix{Int64}:\n 4  6\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.sum-Tuple{AbstractArray}","page":"References","title":"Base.sum","text":"sum(A::AbstractArray; dims)\n\nSum elements of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sum(A, dims=1)\n1×2 Matrix{Int64}:\n 4  6\n\njulia> sum(A, dims=2)\n2×1 Matrix{Int64}:\n 3\n 7\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.sum-Tuple{Any, AbstractArray}","page":"References","title":"Base.sum","text":"sum(f, A::AbstractArray; dims)\n\nSum the results of calling function f on each element of an array over the given dimensions.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> sum(abs2, A, dims=1)\n1×2 Matrix{Int64}:\n 10  20\n\njulia> sum(abs2, A, dims=2)\n2×1 Matrix{Int64}:\n  5\n 25\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.sum-Tuple{Any, Any}","page":"References","title":"Base.sum","text":"sum(f, itr; [init])\n\nSum the results of calling function f on each element of itr.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be the additive identity (i.e. zero) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> sum(abs2, [2; 3; 4])\n29\n\nNote the important difference between sum(A) and reduce(+, A) for arrays with small integer eltype:\n\njulia> sum(Int8[100, 28])\n128\n\njulia> reduce(+, Int8[100, 28])\n-128\n\nIn the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.sum-Tuple{Any}","page":"References","title":"Base.sum","text":"sum(itr; [init])\n\nReturns the sum of all elements in a collection.\n\nThe return type is Int for signed integers of less than system word size, and UInt for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.\n\nThe value returned for empty itr can be specified by init. It must be the additive identity (i.e. zero) as it is unspecified whether init is used for non-empty collections.\n\ncompat: Julia 1.6\nKeyword argument init requires Julia 1.6 or later.\n\nExamples\n\njulia> sum(1:20)\n210\n\njulia> sum(1:20; init = 0.0)\n210.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.summary-Tuple{IO, Any}","page":"References","title":"Base.summary","text":"summary(io::IO, x)\nstr = summary(x)\n\nPrint to a stream io, or return a string str, giving a brief description of a value. By default returns string(typeof(x)), e.g. Int64.\n\nFor arrays, returns a string of size and type info, e.g. 10-element Array{Int64,1}.\n\nExamples\n\njulia> summary(1)\n\"Int64\"\n\njulia> summary(zeros(2))\n\"2-element Vector{Float64}\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.summarysize-Tuple{Any}","page":"References","title":"Base.summarysize","text":"Base.summarysize(obj; exclude=Union{...}, chargeall=Union{...}) -> Int\n\nCompute the amount of memory, in bytes, used by all unique objects reachable from the argument.\n\nKeyword Arguments\n\nexclude: specifies the types of objects to exclude from the traversal.\nchargeall: specifies the types of objects to always charge the size of all of their fields, even if those fields would normally be excluded.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.supertype-Tuple{DataType}","page":"References","title":"Base.supertype","text":"supertype(T::DataType)\n\nReturn the supertype of DataType T.\n\nExamples\n\njulia> supertype(Int32)\nSigned\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.symdiff!-Tuple{AbstractSet, Vararg{Any, N} where N}","page":"References","title":"Base.symdiff!","text":"symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nConstruct the symmetric difference of the passed in sets, and overwrite s with the result. When s is an array, the order is maintained. Note that in this case the multiplicity of elements matters.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.symdiff-Tuple{Any, Vararg{Any, N} where N}","page":"References","title":"Base.symdiff","text":"symdiff(s, itrs...)\n\nConstruct the symmetric difference of elements in the passed in sets. When s is not an AbstractSet, the order is maintained. Note that in this case the multiplicity of elements matters.\n\nExamples\n\njulia> symdiff([1,2,3], [3,4,5], [4,5,6])\n3-element Vector{Int64}:\n 1\n 2\n 6\n\njulia> symdiff([1,2,1], [2, 1, 2])\n2-element Vector{Int64}:\n 1\n 2\n\njulia> symdiff(unique([1,2,1]), unique([2, 1, 2]))\nInt64[]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.systemerror-Tuple{Any, Bool}","page":"References","title":"Base.systemerror","text":"systemerror(sysfunc[, errno::Cint=Libc.errno()])\nsystemerror(sysfunc, iftrue::Bool)\n\nRaises a SystemError for errno with the descriptive string sysfunc if iftrue is true\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.tail-Tuple{Tuple}","page":"References","title":"Base.tail","text":"tail(x::Tuple)::Tuple\n\nReturn a Tuple consisting of all but the first component of x.\n\nExamples\n\njulia> Base.tail((1,2,3))\n(2, 3)\n\njulia> Base.tail(())\nERROR: ArgumentError: Cannot call tail on an empty tuple.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.take!-Tuple{Base.GenericIOBuffer}","page":"References","title":"Base.take!","text":"take!(b::IOBuffer)\n\nObtain the contents of an IOBuffer as an array, without copying. Afterwards, the IOBuffer is reset to its initial state.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.take!-Tuple{Channel}","page":"References","title":"Base.take!","text":"take!(c::Channel)\n\nRemove and return a value from a Channel. Blocks until data is available.\n\nFor unbuffered channels, blocks until a put! is performed by a different task.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.task_local_storage-Tuple{Any, Any}","page":"References","title":"Base.task_local_storage","text":"task_local_storage(key, value)\n\nAssign a value to a key in the current task's task-local storage.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.task_local_storage-Tuple{Any}","page":"References","title":"Base.task_local_storage","text":"task_local_storage(key)\n\nLook up the value of a key in the current task's task-local storage.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.task_local_storage-Tuple{Function, Any, Any}","page":"References","title":"Base.task_local_storage","text":"task_local_storage(body, key, value)\n\nCall the function body with a modified task-local storage, in which value is assigned to key; the previous value of key, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.thisind-Tuple{AbstractString, Integer}","page":"References","title":"Base.thisind","text":"thisind(s::AbstractString, i::Integer) -> Int\n\nIf i is in bounds in s return the index of the start of the character whose encoding code unit i is part of. In other words, if i is the start of a character, return i; if i is not the start of a character, rewind until the start of a character and return that index. If i is equal to 0 or ncodeunits(s)+1 return i. In all other cases throw BoundsError.\n\nExamples\n\njulia> thisind(\"α\", 0)\n0\n\njulia> thisind(\"α\", 1)\n1\n\njulia> thisind(\"α\", 2)\n1\n\njulia> thisind(\"α\", 3)\n3\n\njulia> thisind(\"α\", 4)\nERROR: BoundsError: attempt to access 2-codeunit String at index [4]\n[...]\n\njulia> thisind(\"α\", -1)\nERROR: BoundsError: attempt to access 2-codeunit String at index [-1]\n[...]\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.time_ns-Tuple{}","page":"References","title":"Base.time_ns","text":"time_ns()\n\nGet the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.timedwait-Tuple{Function, Real}","page":"References","title":"Base.timedwait","text":"timedwait(callback::Function, timeout::Real; pollint::Real=0.1)\n\nWaits until callback returns true or timeout seconds have passed, whichever is earlier. callback is polled every pollint seconds. The minimum value for timeout and pollint is 0.001, that is, 1 millisecond.\n\nReturns :ok or :timed_out\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.to_index-Tuple{Any, Any}","page":"References","title":"Base.to_index","text":"to_index(A, i)\n\nConvert index i to an Int or array of indices to be used as an index into array A.\n\nCustom array types may specialize to_index(::CustomArray, i) to provide special indexing behaviors. Note that some index types (like Colon) require more context in order to transform them into an array of indices; those get converted in the more complicated to_indices function. By default, this simply calls the generic to_index(i). This must return either an Int or an AbstractArray of scalar indices that are supported by A.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.to_index-Tuple{Integer}","page":"References","title":"Base.to_index","text":"to_index(i)\n\nConvert index i to an Int or array of Ints to be used as an index for all arrays.\n\nCustom index types may specialize to_index(::CustomIndex) to provide special indexing behaviors. This must return either an Int or an AbstractArray of Ints.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.to_indices-Tuple{Any, Tuple}","page":"References","title":"Base.to_indices","text":"to_indices(A, I::Tuple)\n\nConvert the tuple I to a tuple of indices for use in indexing into array A.\n\nThe returned tuple must only contain either Ints or AbstractArrays of scalar indices that are supported by array A. It will error upon encountering a novel index type that it does not know how to process.\n\nFor simple index types, it defers to the unexported Base.to_index(A, i) to process each index i. While this internal function is not intended to be called directly, Base.to_index may be extended by custom array or index types to provide custom indexing behaviors.\n\nMore complicated index types may require more context about the dimension into which they index. To support those cases, to_indices(A, I) calls to_indices(A, axes(A), I), which then recursively walks through both the given tuple of indices and the dimensional indices of A in tandem. As such, not all index types are guaranteed to propagate to Base.to_index.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.trailing_ones-Tuple{Integer}","page":"References","title":"Base.trailing_ones","text":"trailing_ones(x::Integer) -> Integer\n\nNumber of ones trailing the binary representation of x.\n\nExamples\n\njulia> trailing_ones(3)\n2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.trailing_zeros-Tuple{Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8}}","page":"References","title":"Base.trailing_zeros","text":"trailing_zeros(x::Integer) -> Integer\n\nNumber of zeros trailing the binary representation of x.\n\nExamples\n\njulia> trailing_zeros(2)\n1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.transcode","page":"References","title":"Base.transcode","text":"transcode(T, src)\n\nConvert string data between Unicode encodings. src is either a String or a Vector{UIntXX} of UTF-XX code units, where XX is 8, 16, or 32. T indicates the encoding of the return value: String to return a (UTF-8 encoded) String or UIntXX to return a Vector{UIntXX} of UTF-XX data. (The alias Cwchar_t can also be used as the integer type, for converting wchar_t* strings used by external C libraries.)\n\nThe transcode function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.\n\nOnly conversion to/from UTF-8 is currently supported.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.trues-Tuple{Vararg{Union{Integer, AbstractUnitRange}, N} where N}","page":"References","title":"Base.trues","text":"trues(dims)\n\nCreate a BitArray with all values set to true.\n\nExamples\n\njulia> trues(2,3)\n2×3 BitMatrix:\n 1  1  1\n 1  1  1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.trunc","page":"References","title":"Base.trunc","text":"trunc([T,] x)\ntrunc(x; digits::Integer= [, base = 10])\ntrunc(x; sigdigits::Integer= [, base = 10])\n\ntrunc(x) returns the nearest integral value of the same type as x whose absolute value is less than or equal to x.\n\ntrunc(T, x) converts the result to type T, throwing an InexactError if the value is not representable.\n\ndigits, sigdigits and base work as for round.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.truncate-Tuple{IOStream, Integer}","page":"References","title":"Base.truncate","text":"truncate(file, n)\n\nResize the file or buffer given by the first argument to exactly n bytes, filling previously unallocated space with '\\0' if the file or buffer is grown.\n\nExamples\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\")\n35\n\njulia> truncate(io, 15)\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=15, maxsize=Inf, ptr=16, mark=-1)\n\njulia> String(take!(io))\n\"JuliaLang is a \"\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\");\n\njulia> truncate(io, 40);\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization.\\0\\0\\0\\0\\0\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.trylock-Tuple{ReentrantLock}","page":"References","title":"Base.trylock","text":"trylock(lock) -> Success (Boolean)\n\nAcquire the lock if it is available, and return true if successful. If the lock is already locked by a different task/thread, return false.\n\nEach successful trylock must be matched by an unlock.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.tryparse-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T<:Integer","page":"References","title":"Base.tryparse","text":"tryparse(type, str; base)\n\nLike parse, but returns either a value of the requested type, or nothing if the string does not contain a valid number.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.typeintersect-Tuple{Any, Any}","page":"References","title":"Base.typeintersect","text":"typeintersect(T, S)\n\nCompute a type that contains the intersection of T and S. Usually this will be the smallest such type or one close to it.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.typejoin-Tuple{}","page":"References","title":"Base.typejoin","text":"typejoin(T, S)\n\nReturn the closest common ancestor of T and S, i.e. the narrowest type from which they both inherit.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.typemax","page":"References","title":"Base.typemax","text":"typemax(T)\n\nThe highest value representable by the given (real) numeric DataType.\n\nExamples\n\njulia> typemax(Int8)\n127\n\njulia> typemax(UInt32)\n0xffffffff\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.typemin","page":"References","title":"Base.typemin","text":"typemin(T)\n\nThe lowest value representable by the given (real) numeric DataType T.\n\nExamples\n\njulia> typemin(Float16)\n-Inf16\n\njulia> typemin(Float32)\n-Inf32\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.uabs-Tuple{Integer}","page":"References","title":"Base.uabs","text":"uabs(x::Integer)\n\nReturn the absolute value of x, possibly returning a different type should the operation be susceptible to overflow. This typically arises when x is a two's complement signed integer, so that abs(typemin(x)) == typemin(x) < 0, in which case the result of uabs(x) will be an unsigned integer of the same size.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unalias-Tuple{Any, AbstractArray}","page":"References","title":"Base.unalias","text":"Base.unalias(dest, A)\n\nReturn either A or a copy of A in a rough effort to prevent modifications to dest from affecting the returned object. No guarantees are provided.\n\nCustom arrays that wrap or use fields containing arrays that might alias against other external objects should provide a Base.dataids implementation.\n\nThis function must return an object of exactly the same type as A for performance and type stability. Mutable custom arrays for which copy(A) is not typeof(A) should provide a Base.unaliascopy implementation.\n\nSee also Base.mightalias.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unaliascopy-Tuple{Array}","page":"References","title":"Base.unaliascopy","text":"Base.unaliascopy(A)\n\nMake a preventative copy of A in an operation where A Base.mightalias against another array in order to preserve consistent semantics as that other array is mutated.\n\nThis must return an object of the same type as A to preserve optimal performance in the much more common case where aliasing does not occur. By default, unaliascopy(A::AbstractArray) will attempt to use copy(A), but in cases where copy(A) is not a typeof(A), then the array should provide a custom implementation of Base.unaliascopy(A).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unescape_string","page":"References","title":"Base.unescape_string","text":"unescape_string(str::AbstractString, keep = ())::AbstractString\nunescape_string(io, s::AbstractString, keep = ())::Nothing\n\nGeneral unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to io. The argument keep specifies a collection of characters which (along with backlashes) are to be kept as they are.\n\nThe following escape sequences are recognised:\n\nEscaped backslash (\\\\)\nEscaped double-quote (\\\")\nStandard C escape sequences (\\a, \\b, \\t, \\n, \\v, \\f, \\r, \\e)\nUnicode BMP code points (\\u with 1-4 trailing hex digits)\nAll Unicode code points (\\U with 1-8 trailing hex digits; max value = 0010ffff)\nHex bytes (\\x with 1-2 trailing hex digits)\nOctal bytes (\\ with 1-3 trailing octal digits)\n\nExamples\n\njulia> unescape_string(\"aaa\\\\nbbb\") # C escape sequence\n\"aaa\\nbbb\"\n\njulia> unescape_string(\"\\\\u03c0\") # unicode\n\"π\"\n\njulia> unescape_string(\"\\\\101\") # octal\n\"A\"\n\njulia> unescape_string(\"aaa \\\\g \\\\n\", ['g']) # using `keep` argument\n\"aaa \\\\g \\n\"\n\nSee also\n\nescape_string.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.unindent-Tuple{AbstractString, Int64}","page":"References","title":"Base.unindent","text":"unindent(str::AbstractString, indent::Int; tabwidth=8)\n\nRemove leading indentation from string.\n\nExamples\n\njulia> Base.unindent(\"   a\\n   b\", 2)\n\" a\\n b\"\n\njulia> Base.unindent(\"\\ta\\n\\tb\", 2, tabwidth=8)\n\"      a\\n      b\"\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.union","page":"References","title":"Base.union","text":"union(s, itrs...)\n∪(s, itrs...)\n\nConstruct the union of sets. Maintain order with arrays.\n\nExamples\n\njulia> union([1, 2], [3, 4])\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> union([1, 2], [2, 4])\n3-element Vector{Int64}:\n 1\n 2\n 4\n\njulia> union([4, 2], 1:2)\n3-element Vector{Int64}:\n 4\n 2\n 1\n\njulia> union(Set([1, 2]), 2:3)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.union!-Tuple{AbstractSet, Vararg{Any, N} where N}","page":"References","title":"Base.union!","text":"union!(s::Union{AbstractSet,AbstractVector}, itrs...)\n\nConstruct the union of passed in sets and overwrite s with the result. Maintain order with arrays.\n\nExamples\n\njulia> a = Set([1, 3, 4, 5]);\n\njulia> union!(a, 1:2:8);\n\njulia> a\nSet{Int64} with 5 elements:\n  5\n  4\n  7\n  3\n  1\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unique!-Tuple{Any, AbstractVector{T} where T}","page":"References","title":"Base.unique!","text":"unique!(f, A::AbstractVector)\n\nSelects one value from A for each unique value produced by f applied to elements of A, then return the modified A.\n\ncompat: Julia 1.1\nThis method is available as of Julia 1.1.\n\nExamples\n\njulia> unique!(x -> x^2, [1, -1, 3, -3, 4])\n3-element Vector{Int64}:\n 1\n 3\n 4\n\njulia> unique!(n -> n%3, [5, 1, 8, 9, 3, 4, 10, 7, 2, 6])\n3-element Vector{Int64}:\n 5\n 1\n 9\n\njulia> unique!(iseven, [2, 3, 5, 7, 9])\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unique!-Tuple{Any}","page":"References","title":"Base.unique!","text":"unique!(A::AbstractVector)\n\nRemove duplicate items as determined by isequal, then return the modified A. unique! will return the elements of A in the order that they occur. If you do not care about the order of the returned data, then calling (sort!(A); unique!(A)) will be much more efficient as long as the elements of A can be sorted.\n\nExamples\n\njulia> unique!([1, 1, 1])\n1-element Vector{Int64}:\n 1\n\njulia> A = [7, 3, 2, 3, 7, 5];\n\njulia> unique!(A)\n4-element Vector{Int64}:\n 7\n 3\n 2\n 5\n\njulia> B = [7, 6, 42, 6, 7, 42];\n\njulia> sort!(B);  # unique! is able to process sorted data much more efficiently.\n\njulia> unique!(B)\n3-element Vector{Int64}:\n  6\n  7\n 42\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unique-Tuple{AbstractArray}","page":"References","title":"Base.unique","text":"unique(A::AbstractArray; dims::Int)\n\nReturn unique regions of A along dimension dims.\n\nExamples\n\njulia> A = map(isodd, reshape(Vector(1:8), (2,2,2)))\n2×2×2 Array{Bool, 3}:\n[:, :, 1] =\n 1  1\n 0  0\n\n[:, :, 2] =\n 1  1\n 0  0\n\njulia> unique(A)\n2-element Vector{Bool}:\n 1\n 0\n\njulia> unique(A, dims=2)\n2×1×2 Array{Bool, 3}:\n[:, :, 1] =\n 1\n 0\n\n[:, :, 2] =\n 1\n 0\n\njulia> unique(A, dims=3)\n2×2×1 Array{Bool, 3}:\n[:, :, 1] =\n 1  1\n 0  0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unique-Tuple{Any, Any}","page":"References","title":"Base.unique","text":"unique(f, itr)\n\nReturns an array containing one value from itr for each unique value produced by f applied to elements of itr.\n\nExamples\n\njulia> unique(x -> x^2, [1, -1, 3, -3, 4])\n3-element Vector{Int64}:\n 1\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unique-Tuple{Any}","page":"References","title":"Base.unique","text":"unique(itr)\n\nReturn an array containing only the unique elements of collection itr, as determined by isequal, in the order that the first of each set of equivalent elements originally appears. The element type of the input is preserved.\n\nExamples\n\njulia> unique([1, 2, 6, 2])\n3-element Vector{Int64}:\n 1\n 2\n 6\n\njulia> unique(Real[1, 1.0, 2])\n2-element Vector{Real}:\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unlock-Tuple{ReentrantLock}","page":"References","title":"Base.unlock","text":"unlock(lock)\n\nReleases ownership of the lock.\n\nIf this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unmark-Tuple{IO}","page":"References","title":"Base.unmark","text":"unmark(s)\n\nRemove a mark from stream s. Return true if the stream was marked, false otherwise.\n\nSee also mark, reset, ismarked.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unsafe_convert","page":"References","title":"Base.unsafe_convert","text":"unsafe_convert(T, x)\n\nConvert x to a C argument of type T where the input x must be the return value of cconvert(T, ...).\n\nIn cases where convert would need to take a Julia object and turn it into a Ptr, this function should be used to define and perform that conversion.\n\nBe careful to ensure that a Julia reference to x exists as long as the result of this function will be used. Accordingly, the argument x to this function should never be an expression, only a variable name or field reference. For example, x=a.b.c is acceptable, but x=[a,b,c] is not.\n\nThe unsafe prefix on this function indicates that using the result of this function after the x argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.\n\nSee also cconvert\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Array{T, N} where N, Any, Array{T, N} where N, Any, Any}} where T","page":"References","title":"Base.unsafe_copyto!","text":"unsafe_copyto!(dest::Array, do, src::Array, so, N)\n\nCopy N elements from a source array to a destination, starting at offset so in the source and do in the destination (1-indexed).\n\nThe unsafe prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unsafe_copyto!-Union{Tuple{T}, Tuple{Ptr{T}, Ptr{T}, Any}} where T","page":"References","title":"Base.unsafe_copyto!","text":"unsafe_copyto!(dest::Ptr{T}, src::Ptr{T}, N)\n\nCopy N elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointers dest and src to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unsafe_load","page":"References","title":"Base.unsafe_load","text":"unsafe_load(p::Ptr{T}, i::Integer=1)\n\nLoad a value of type T from the address of the ith element (1-indexed) starting at p. This is equivalent to the C expression p[i-1].\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointer p to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.unsafe_pointer_to_objref-Tuple{Ptr}","page":"References","title":"Base.unsafe_pointer_to_objref","text":"unsafe_pointer_to_objref(p::Ptr)\n\nConvert a Ptr to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered \"unsafe\" and should be used with care.\n\nSee also: pointer_from_objref.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unsafe_read-Tuple{IO, Ptr{UInt8}, UInt64}","page":"References","title":"Base.unsafe_read","text":"unsafe_read(io::IO, ref, nbytes::UInt)\n\nCopy nbytes from the IO stream object into ref (converted to a pointer).\n\nIt is recommended that subtypes T<:IO override the following method signature to provide more efficient implementations: unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unsafe_store!","page":"References","title":"Base.unsafe_store!","text":"unsafe_store!(p::Ptr{T}, x, i::Integer=1)\n\nStore a value of type T to the address of the ith element (1-indexed) starting at p. This is equivalent to the C expression p[i-1] = x.\n\nThe unsafe prefix on this function indicates that no validation is performed on the pointer p to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.unsafe_string-Tuple{Union{Ptr{Int8}, Ptr{UInt8}}, Integer}","page":"References","title":"Base.unsafe_string","text":"unsafe_string(p::Ptr{UInt8}, [length::Integer])\n\nCopy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If length is specified (the length of the data in bytes), the string does not have to be NUL-terminated.\n\nThis function is labeled \"unsafe\" because it will crash if p is not a valid memory address to data of the requested length.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unsafe_trunc","page":"References","title":"Base.unsafe_trunc","text":"unsafe_trunc(T, x)\n\nReturn the nearest integral value of type T whose absolute value is less than or equal to x. If the value is not representable by T, an arbitrary value will be returned.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.unsafe_wrap-Union{Tuple{N}, Tuple{T}, Tuple{Union{Type{Array}, Type{Array{T, N} where N}, Type{Array{T, N}}}, Ptr{T}, Tuple{Vararg{Int64, N}}}} where {T, N}","page":"References","title":"Base.unsafe_wrap","text":"unsafe_wrap(Array, pointer::Ptr{T}, dims; own = false)\n\nWrap a Julia Array object around the data at the address given by pointer, without making a copy.  The pointer element type T determines the array element type. dims is either an integer (for a 1d array) or a tuple of the array dimensions. own optionally specifies whether Julia should take ownership of the memory, calling free on the pointer when the array is no longer referenced.\n\nThis function is labeled \"unsafe\" because it will crash if pointer is not a valid memory address to data of the requested length.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unsafe_write-Tuple{IO, Ptr{UInt8}, UInt64}","page":"References","title":"Base.unsafe_write","text":"unsafe_write(io::IO, ref, nbytes::UInt)\n\nCopy nbytes from ref (converted to a pointer) into the IO object.\n\nIt is recommended that subtypes T<:IO override the following method signature to provide more efficient implementations: unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.unsigned","page":"References","title":"Base.unsigned","text":"unsigned(T::Integer)\n\nConvert an integer bitstype to the unsigned type of the same size.\n\nExamples\n\njulia> unsigned(Int16)\nUInt16\njulia> unsigned(UInt64)\nUInt64\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.unsigned-Tuple{Any}","page":"References","title":"Base.unsigned","text":"unsigned(x)\n\nConvert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.\n\nExamples\n\njulia> unsigned(-2)\n0xfffffffffffffffe\njulia> unsigned(2)\n0x0000000000000002\njulia> signed(unsigned(-2))\n-2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.valtype-Tuple{Type{var\"#s832\"} where var\"#s832\"<:AbstractArray}","page":"References","title":"Base.valtype","text":"valtype(T::Type{<:AbstractArray})\nvaltype(A::AbstractArray)\n\nReturn the value type of an array. This is identical to eltype and is provided mainly for compatibility with the dictionary interface.\n\nExamples\n\njulia> valtype([\"one\", \"two\", \"three\"])\nString\n\ncompat: Julia 1.2\nFor arrays, this function requires at least Julia 1.2.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.valtype-Union{Tuple{Type{var\"#s832\"} where var\"#s832\"<:AbstractDict{K, V}}, Tuple{V}, Tuple{K}} where {K, V}","page":"References","title":"Base.valtype","text":"valtype(type)\n\nGet the value type of an dictionary type. Behaves similarly to eltype.\n\nExamples\n\njulia> valtype(Dict(Int32(1) => \"foo\"))\nString\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.values-Tuple{AbstractDict}","page":"References","title":"Base.values","text":"values(a::AbstractDict)\n\nReturn an iterator over all values in a collection. collect(values(a)) returns an array of values. When the values are stored internally in a hash table, as is the case for Dict, the order in which they are returned may vary. But keys(a) and values(a) both iterate a and return the elements in the same order.\n\nExamples\n\njulia> D = Dict('a'=>2, 'b'=>3)\nDict{Char, Int64} with 2 entries:\n  'a' => 2\n  'b' => 3\n\njulia> collect(values(D))\n2-element Vector{Int64}:\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.values-Tuple{Any}","page":"References","title":"Base.values","text":"values(iterator)\n\nFor an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its \"values\".\n\nExamples\n\njulia> d = Dict(\"a\"=>1, \"b\"=>2);\n\njulia> values(d)\nValueIterator for a Dict{String, Int64} with 2 entries. Values:\n  2\n  1\n\njulia> values([2])\n1-element Vector{Int64}:\n 2\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.vcat-Tuple","page":"References","title":"Base.vcat","text":"vcat(A...)\n\nConcatenate along dimension 1.\n\nExamples\n\njulia> a = [1 2 3 4 5]\n1×5 Matrix{Int64}:\n 1  2  3  4  5\n\njulia> b = [6 7 8 9 10; 11 12 13 14 15]\n2×5 Matrix{Int64}:\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> vcat(a,b)\n3×5 Matrix{Int64}:\n  1   2   3   4   5\n  6   7   8   9  10\n 11  12  13  14  15\n\njulia> c = ([1 2 3], [4 5 6])\n([1 2 3], [4 5 6])\n\njulia> vcat(c...)\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.vec-Tuple{AbstractArray}","page":"References","title":"Base.vec","text":"vec(a::AbstractArray) -> AbstractVector\n\nReshape the array a as a one-dimensional column vector. Return a if it is already an AbstractVector. The resulting array shares the same underlying data as a, so it will only be mutable if a is mutable, in which case modifying one will also modify the other.\n\nExamples\n\njulia> a = [1 2 3; 4 5 6]\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\njulia> vec(a)\n6-element Vector{Int64}:\n 1\n 4\n 2\n 5\n 3\n 6\n\njulia> vec(1:3)\n1:3\n\nSee also reshape.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.vect-Tuple","page":"References","title":"Base.vect","text":"vect(X...)\n\nCreate a Vector with element type computed from the promote_typeof of the argument, containing the argument list.\n\nExamples\n\njulia> a = Base.vect(UInt8(1), 2.5, 1//2)\n3-element Vector{Float64}:\n 1.0\n 2.5\n 0.5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.view-Union{Tuple{N}, Tuple{AbstractArray, Vararg{Any, N}}} where N","page":"References","title":"Base.view","text":"view(A, inds...)\n\nLike getindex, but returns a lightweight array that lazily references (or is effectively a view into) the parent array A at the given index or indices inds instead of eagerly extracting elements or constructing a copied subset. Calling getindex or setindex! on the returned value (often a SubArray) computes the indices to access or modify the parent array on the fly.  The behavior is undefined if the shape of the parent array is changed after view is called because there is no bound check for the parent array; e.g., it may cause a segmentation fault.\n\nSome immutable parent arrays (like ranges) may choose to simply recompute a new array in some circumstances instead of returning a SubArray if doing so is efficient and provides compatible semantics.\n\ncompat: Julia 1.6\nIn Julia 1.6 or later, view can be called on an AbstractString, returning a SubString.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> b = view(A, :, 1)\n2-element view(::Matrix{Int64}, :, 1) with eltype Int64:\n 1\n 3\n\njulia> fill!(b, 0)\n2-element view(::Matrix{Int64}, :, 1) with eltype Int64:\n 0\n 0\n\njulia> A # Note A has changed even though we modified b\n2×2 Matrix{Int64}:\n 0  2\n 0  4\n\njulia> view(2:5, 2:3) # returns a range as type is immutable\n3:4\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.wait-Tuple{Base.GenericCondition}","page":"References","title":"Base.wait","text":"wait([x])\n\nBlock the current task until some event occurs, depending on the type of the argument:\n\nChannel: Wait for a value to be appended to the channel.\nCondition: Wait for notify on a condition.\nProcess: Wait for a process or process chain to exit. The exitcode field of a process can be used to determine success or failure.\nTask: Wait for a Task to finish. If the task fails with an exception, a TaskFailedException (which wraps the failed task) is thrown.\nRawFD: Wait for changes on a file descriptor (see the FileWatching package).\n\nIf no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to schedule or yieldto.\n\nOften wait is called within a while loop to ensure a waited-for condition is met before proceeding.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.which-Tuple{Any, Any}","page":"References","title":"Base.which","text":"which(f, types)\n\nReturns the method of f (a Method object) that would be called for arguments of the given types.\n\nIf types is an abstract type, then the method that would be called by invoke is returned.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.which-Tuple{Module, Symbol}","page":"References","title":"Base.which","text":"which(module, symbol)\n\nReturn the module in which the binding for the variable referenced by symbol in module was created.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.which-Tuple{Type}","page":"References","title":"Base.which","text":"which(types::Type{<:Tuple})\n\nReturns the method that would be called by the given type signature (as a tuple type).\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.widemul-Tuple{Number, Number}","page":"References","title":"Base.widemul","text":"widemul(x, y)\n\nMultiply x and y, giving the result as a larger type.\n\nExamples\n\njulia> widemul(Float32(3.), 4.)\n12.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.widen-Tuple{T} where T","page":"References","title":"Base.widen","text":"widen(x)\n\nIf x is a type, return a \"larger\" type, defined so that arithmetic operations + and - are guaranteed not to overflow nor lose precision for any combination of values that type x can hold.\n\nFor fixed-size integer types less than 128 bits, widen will return a type with twice the number of bits.\n\nIf x is a value, it is converted to widen(typeof(x)).\n\nExamples\n\njulia> widen(Int32)\nInt64\n\njulia> widen(1.5f0)\n1.5\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.windowserror-Tuple{Any, Bool}","page":"References","title":"Base.windowserror","text":"windowserror(sysfunc[, code::UInt32=Libc.GetLastError()])\nwindowserror(sysfunc, iftrue::Bool)\n\nLike systemerror, but for Windows API functions that use GetLastError to return an error code instead of setting errno.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.withenv-Union{Tuple{T}, Tuple{Function, Vararg{Pair{T, B} where B, N} where N}} where T<:AbstractString","page":"References","title":"Base.withenv","text":"withenv(f::Function, kv::Pair...)\n\nExecute f in an environment that is temporarily modified (not replaced as in setenv) by zero or more \"var\"=>val arguments kv. withenv is generally used via the withenv(kv...) do ... end syntax. A value of nothing can be used to temporarily unset an environment variable (if it is set). When withenv returns, the original environment has been restored.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.write","page":"References","title":"Base.write","text":"write(io::IO, x)\nwrite(filename::AbstractString, x)\n\nWrite the canonical binary representation of a value to the given I/O stream or file. Return the number of bytes written into the stream. See also print to write a text representation (with an encoding that may depend upon io).\n\nThe endianness of the written value depends on the endianness of the host system. Convert to/from a fixed endianness when writing/reading (e.g. using  htol and ltoh) to get results that are consistent across platforms.\n\nYou can write multiple values with the same write call. i.e. the following are equivalent:\n\nwrite(io, x, y...)\nwrite(io, x) + write(io, y...)\n\nExamples\n\nConsistent serialization:\n\njulia> fname = tempname(); # random temporary filename\n\njulia> open(fname,\"w\") do f\n           # Make sure we write 64bit integer in little-endian byte order\n           write(f,htol(Int64(42)))\n       end\n8\n\njulia> open(fname,\"r\") do f\n           # Convert back to host byte order and host integer type\n           Int(ltoh(read(f,Int64)))\n       end\n42\n\nMerging write calls:\n\njulia> io = IOBuffer();\n\njulia> write(io, \"JuliaLang is a GitHub organization.\", \" It has many members.\")\n56\n\njulia> String(take!(io))\n\"JuliaLang is a GitHub organization. It has many members.\"\n\njulia> write(io, \"Sometimes those members\") + write(io, \" write documentation.\")\n44\n\njulia> String(take!(io))\n\"Sometimes those members write documentation.\"\n\nUser-defined plain-data types without write methods can be written when wrapped in a Ref:\n\njulia> struct MyStruct; x::Float64; end\n\njulia> io = IOBuffer()\nIOBuffer(data=UInt8[...], readable=true, writable=true, seekable=true, append=false, size=0, maxsize=Inf, ptr=1, mark=-1)\n\njulia> write(io, Ref(MyStruct(42.0)))\n8\n\njulia> seekstart(io); read!(io, Ref(MyStruct(NaN)))\nBase.RefValue{MyStruct}(MyStruct(42.0))\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.xor-Tuple{Bool, Bool}","page":"References","title":"Base.xor","text":"xor(x, y)\n⊻(x, y)\n\nBitwise exclusive or of x and y. Implements three-valued logic, returning missing if one of the arguments is missing.\n\nThe infix operation a ⊻ b is a synonym for xor(a,b), and ⊻ can be typed by tab-completing \\xor or \\veebar in the Julia REPL.\n\nExamples\n\njulia> xor(true, false)\ntrue\n\njulia> xor(true, true)\nfalse\n\njulia> xor(true, missing)\nmissing\n\njulia> false ⊻ false\nfalse\n\njulia> [true; true; false] .⊻ [true; false; false]\n3-element BitVector:\n 0\n 1\n 0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.yield-Tuple{Task, Any}","page":"References","title":"Base.yield","text":"yield(t::Task, arg = nothing)\n\nA fast, unfair-scheduling version of schedule(t, arg); yield() which immediately yields to t before calling the scheduler.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.yield-Tuple{}","page":"References","title":"Base.yield","text":"yield()\n\nSwitch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.yieldto-Tuple{Task, Any}","page":"References","title":"Base.yieldto","text":"yieldto(t::Task, arg = nothing)\n\nSwitch to the given task. The first time a task is switched to, the task's function is called with no arguments. On subsequent switches, arg is returned from the task's last call to yieldto. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.zero-Tuple{Number}","page":"References","title":"Base.zero","text":"zero(x)\nzero(::Type)\n\nGet the additive identity element for the type of x (x can also specify the type itself).\n\nExamples\n\njulia> zero(1)\n0\n\njulia> zero(big\"2.0\")\n0.0\n\njulia> zero(rand(2,2))\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"references/#Base.zeros","page":"References","title":"Base.zeros","text":"zeros([T=Float64,] dims::Tuple)\nzeros([T=Float64,] dims...)\n\nCreate an Array, with element type T, of all zeros with size specified by dims. See also fill, ones.\n\nExamples\n\njulia> zeros(1)\n1-element Vector{Float64}:\n 0.0\n\njulia> zeros(Int8, 2, 3)\n2×3 Matrix{Int8}:\n 0  0  0\n 0  0  0\n\n\n\n\n\n","category":"function"},{"location":"references/#Core.:<:","page":"References","title":"Core.:<:","text":"<:(T1, T2)\n\nSubtype operator: returns true if and only if all values of type T1 are also of type T2.\n\nExamples\n\njulia> Float64 <: AbstractFloat\ntrue\n\njulia> Vector{Int} <: AbstractArray\ntrue\n\njulia> Matrix{Float64} <: Matrix{AbstractFloat}\nfalse\n\n\n\n\n\n","category":"function"},{"location":"references/#Core.:===","page":"References","title":"Core.:===","text":"===(x,y) -> Bool\n≡(x,y) -> Bool\n\nDetermine whether x and y are identical, in the sense that no program could distinguish them. First the types of x and y are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called \"egal\". It always returns a Bool value.\n\nExamples\n\njulia> a = [1, 2]; b = [1, 2];\n\njulia> a == b\ntrue\n\njulia> a === b\nfalse\n\njulia> a === a\ntrue\n\n\n\n\n\n","category":"function"},{"location":"references/#Core.Intrinsics.cglobal","page":"References","title":"Core.Intrinsics.cglobal","text":"cglobal((symbol, library) [, type=Cvoid])\n\nObtain a pointer to a global variable in a C-exported shared library, specified exactly as in ccall. Returns a Ptr{Type}, defaulting to Ptr{Cvoid} if no Type argument is supplied. The values can be read or written by unsafe_load or unsafe_store!, respectively.\n\n\n\n\n\n","category":"function"},{"location":"references/#Core.eval","page":"References","title":"Core.eval","text":"Core.eval(m::Module, expr)\n\nEvaluate an expression in the given module and return the result.\n\n\n\n\n\n","category":"function"},{"location":"references/#Core.fieldtype","page":"References","title":"Core.fieldtype","text":"fieldtype(T, name::Symbol | index::Int)\n\nDetermine the declared type of a field (specified by name or index) in a composite DataType T.\n\nExamples\n\njulia> struct Foo\n           x::Int64\n           y::String\n       end\n\njulia> fieldtype(Foo, :x)\nInt64\n\njulia> fieldtype(Foo, 2)\nString\n\n\n\n\n\n","category":"function"},{"location":"references/#Core.ifelse","page":"References","title":"Core.ifelse","text":"ifelse(condition::Bool, x, y)\n\nReturn x if condition is true, otherwise return y. This differs from ? or if in that it is an ordinary function, so all the arguments are evaluated first. In some cases, using ifelse instead of an if statement can eliminate the branch in generated code and provide higher performance in tight loops.\n\nExamples\n\njulia> ifelse(1 > 2, 1, 2)\n2\n\n\n\n\n\n","category":"function"},{"location":"references/#Core.throw","page":"References","title":"Core.throw","text":"throw(e)\n\nThrow an object as an exception.\n\n\n\n\n\n","category":"function"},{"location":"references/#Base.@NamedTuple-Tuple{Any}","page":"References","title":"Base.@NamedTuple","text":"@NamedTuple{key1::Type1, key2::Type2, ...}\n@NamedTuple begin key1::Type1; key2::Type2; ...; end\n\nThis macro gives a more convenient syntax for declaring NamedTuple types. It returns a NamedTuple type with the given keys and types, equivalent to NamedTuple{(:key1, :key2, ...), Tuple{Type1,Type2,...}}. If the ::Type declaration is omitted, it is taken to be Any.   The begin ... end form allows the declarations to be split across multiple lines (similar to a struct declaration), but is otherwise equivalent.\n\nFor example, the tuple (a=3.1, b=\"hello\") has a type NamedTuple{(:a, :b),Tuple{Float64,String}}, which can also be declared via @NamedTuple as:\n\njulia> @NamedTuple{a::Float64, b::String}\nNamedTuple{(:a, :b), Tuple{Float64, String}}\n\njulia> @NamedTuple begin\n           a::Float64\n           b::String\n       end\nNamedTuple{(:a, :b), Tuple{Float64, String}}\n\ncompat: Julia 1.5\nThis macro is available as of Julia 1.5.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@__DIR__-Tuple{}","page":"References","title":"Base.@__DIR__","text":"@__DIR__ -> AbstractString\n\nExpand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by julia -e <expr>.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@__FILE__-Tuple{}","page":"References","title":"Base.@__FILE__","text":"@__FILE__ -> AbstractString\n\nExpand to a string with the path to the file containing the macrocall, or an empty string if evaluated by julia -e <expr>. Return nothing if the macro was missing parser source information. Alternatively see PROGRAM_FILE.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@__LINE__-Tuple{}","page":"References","title":"Base.@__LINE__","text":"@__LINE__ -> Int\n\nExpand to the line number of the location of the macrocall. Return 0 if the line number could not be determined.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@__MODULE__-Tuple{}","page":"References","title":"Base.@__MODULE__","text":"@__MODULE__ -> Module\n\nGet the Module of the toplevel eval, which is the Module code is currently being read from.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@allocated-Tuple{Any}","page":"References","title":"Base.@allocated","text":"@allocated\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the total number of bytes allocated during evaluation of the expression.\n\nSee also @time, @timev, @timed, and @elapsed.\n\njulia> @allocated rand(10^6)\n8000080\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@assert-Tuple{Any, Vararg{Any, N} where N}","page":"References","title":"Base.@assert","text":"@assert cond [text]\n\nThrow an AssertionError if cond is false. Preferred syntax for writing assertions. Message text is optionally displayed upon assertion failure.\n\nwarning: Warning\nAn assert might be disabled at various optimization levels. Assert should therefore only be used as a debugging tool and not used for authentication verification (e.g., verifying passwords), nor should side effects needed for the function to work correctly be used inside of asserts.\n\nExamples\n\njulia> @assert iseven(3) \"3 is an odd number!\"\nERROR: AssertionError: 3 is an odd number!\n\njulia> @assert isodd(3) \"What even are numbers?\"\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@async-Tuple{Any}","page":"References","title":"Base.@async","text":"@async\n\nWrap an expression in a Task and add it to the local machine's scheduler queue.\n\nValues can be interpolated into @async via $, which copies the value directly into the constructed underlying closure. This allows you to insert the value of a variable, isolating the asynchronous code from changes to the variable's value in the current task.\n\ncompat: Julia 1.4\nInterpolating values via $ is available as of Julia 1.4.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@b_str-Tuple{Any}","page":"References","title":"Base.@b_str","text":"@b_str\n\nCreate an immutable byte (UInt8) vector using string syntax.\n\nExamples\n\njulia> v = b\"12\\x01\\x02\"\n4-element Base.CodeUnits{UInt8, String}:\n 0x31\n 0x32\n 0x01\n 0x02\n\njulia> v[2]\n0x32\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@boundscheck-Tuple{Any}","page":"References","title":"Base.@boundscheck","text":"@boundscheck(blk)\n\nAnnotates the expression blk as a bounds checking block, allowing it to be elided by @inbounds.\n\nnote: Note\nThe function in which @boundscheck is written must be inlined into its caller in order for @inbounds to have effect.\n\nExamples\n\njulia> @inline function g(A, i)\n           @boundscheck checkbounds(A, i)\n           return \"accessing ($A)[$i]\"\n       end;\n\njulia> f1() = return g(1:2, -1);\n\njulia> f2() = @inbounds return g(1:2, -1);\n\njulia> f1()\nERROR: BoundsError: attempt to access 2-element UnitRange{Int64} at index [-1]\nStacktrace:\n [1] throw_boundserror(::UnitRange{Int64}, ::Tuple{Int64}) at ./abstractarray.jl:455\n [2] checkbounds at ./abstractarray.jl:420 [inlined]\n [3] g at ./none:2 [inlined]\n [4] f1() at ./none:1\n [5] top-level scope\n\njulia> f2()\n\"accessing (1:2)[-1]\"\n\nwarning: Warning\nThe @boundscheck annotation allows you, as a library writer, to opt-in to allowing other code to remove your bounds checks with @inbounds. As noted there, the caller must verify—using information they can access—that their accesses are valid before using @inbounds. For indexing into your AbstractArray subclasses, for example, this involves checking the indices against its size. Therefore, @boundscheck annotations should only be added to a getindex or setindex! implementation after you are certain its behavior is correct.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@ccall-Tuple{Any}","page":"References","title":"Base.@ccall","text":"@ccall library.function_name(argvalue1::argtype1, ...)::returntype\n@ccall function_name(argvalue1::argtype1, ...)::returntype\n@ccall $function_pointer(argvalue1::argtype1, ...)::returntype\n\nCall a function in a C-exported shared library, specified by library.function_name, where library is a string constant or literal. The library may be omitted, in which case the function_name is resolved in the current process. Alternatively, @ccall may also be used to call a function pointer $function_pointer, such as one returned by dlsym.\n\nEach argvalue to @ccall is converted to the corresponding argtype, by automatic insertion of calls to unsafe_convert(argtype, cconvert(argtype, argvalue)). (See also the documentation for unsafe_convert and cconvert for further details.) In most cases, this simply results in a call to convert(argtype, argvalue).\n\nExamples\n\n@ccall strlen(s::Cstring)::Csize_t\n\nThis calls the C standard library function:\n\nsize_t strlen(char *)\n\nwith a Julia variable named s. See also ccall.\n\nVarargs are supported with the following convention:\n\n@ccall printf(\"%s = %d\"::Cstring ; \"foo\"::Cstring, foo::Cint)::Cint\n\nThe semicolon is used to separate required arguments (of which there must be at least one) from variadic arguments.\n\nExample using an external library:\n\n# C signature of g_uri_escape_string:\n# char *g_uri_escape_string(const char *unescaped, const char *reserved_chars_allowed, gboolean allow_utf8);\n\nconst glib = \"libglib-2.0\"\n@ccall glib.g_uri_escape_string(my_uri::Cstring, \":/\"::Cstring, true::Cint)::Cstring\n\nThe string literal could also be used directly before the function name, if desired \"libglib-2.0\".g_uri_escape_string(...\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@cfunction-Tuple{Any, Any, Any}","page":"References","title":"Base.@cfunction","text":"@cfunction(callable, ReturnType, (ArgumentTypes...,)) -> Ptr{Cvoid}\n@cfunction($callable, ReturnType, (ArgumentTypes...,)) -> CFunction\n\nGenerate a C-callable function pointer from the Julia function callable for the given type signature. To pass the return value to a ccall, use the argument type Ptr{Cvoid} in the signature.\n\nNote that the argument type tuple must be a literal tuple, and not a tuple-valued variable or expression (although it can include a splat expression). And that these arguments will be evaluated in global scope during compile-time (not deferred until runtime). Adding a '$' in front of the function argument changes this to instead create a runtime closure over the local variable callable (this is not supported on all architectures).\n\nSee manual section on ccall and cfunction usage.\n\nExamples\n\njulia> function foo(x::Int, y::Int)\n           return x + y\n       end\n\njulia> @cfunction(foo, Int, (Int, Int))\nPtr{Cvoid} @0x000000001b82fcd0\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@deprecate","page":"References","title":"Base.@deprecate","text":"@deprecate old new [ex=true]\n\nDeprecate method old and specify the replacement call new. Prevent @deprecate from exporting old by setting ex to false. @deprecate defines a new method with the same signature as old.\n\ncompat: Julia 1.5\nAs of Julia 1.5, functions defined by @deprecate do not print warning when julia is run without the --depwarn=yes flag set, as the default value of --depwarn option is no.  The warnings are printed from tests run by Pkg.test().\n\nExamples\n\njulia> @deprecate old(x) new(x)\nold (generic function with 1 method)\n\njulia> @deprecate old(x) new(x) false\nold (generic function with 1 method)\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@elapsed-Tuple{Any}","page":"References","title":"Base.@elapsed","text":"@elapsed\n\nA macro to evaluate an expression, discarding the resulting value, instead returning the number of seconds it took to execute as a floating-point number.\n\nIn some cases the system will look inside the @elapsed expression and compile some of the called code before execution of the top-level expression begins. When that happens, some compilation time will not be counted. To include this time you can run @elapsed @eval ....\n\nSee also @time, @timev, @timed, and @allocated.\n\njulia> @elapsed sleep(0.3)\n0.301391426\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@eval-Tuple{Any}","page":"References","title":"Base.@eval","text":"@eval [mod,] ex\n\nEvaluate an expression with values interpolated into it using eval. If two arguments are provided, the first is the module to evaluate in.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@generated-Tuple{Any}","page":"References","title":"Base.@generated","text":"@generated f\n@generated(f)\n\n@generated is used to annotate a function which will be generated. In the body of the generated function, only types of arguments can be read (not the values). The function returns a quoted expression evaluated when the function is called. The @generated macro should not be used on functions mutating the global scope or depending on mutable elements.\n\nSee Metaprogramming for further details.\n\nExample:\n\njulia> @generated function bar(x)\n           if x <: Integer\n               return :(x ^ 2)\n           else\n               return :(x)\n           end\n       end\nbar (generic function with 1 method)\n\njulia> bar(4)\n16\n\njulia> bar(\"baz\")\n\"baz\"\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@gensym-Tuple","page":"References","title":"Base.@gensym","text":"@gensym\n\nGenerates a gensym symbol for a variable. For example, @gensym x y is transformed into x = gensym(\"x\"); y = gensym(\"y\").\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@goto-Tuple{Symbol}","page":"References","title":"Base.@goto","text":"@goto name\n\n@goto name unconditionally jumps to the statement at the location @label name.\n\n@label and @goto cannot create jumps to different top-level statements. Attempts cause an error. To still use @goto, enclose the @label and @goto in a block.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@inbounds-Tuple{Any}","page":"References","title":"Base.@inbounds","text":"@inbounds(blk)\n\nEliminates array bounds checking within expressions.\n\nIn the example below the in-range check for referencing element i of array A is skipped to improve performance.\n\nfunction sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i = 1:length(A)\n        @inbounds r += A[i]\n    end\n    return r\nend\n\nwarning: Warning\nUsing @inbounds may return incorrect results/crashes/corruption for out-of-bounds indices. The user is responsible for checking it manually. Only use @inbounds when it is certain from the information locally available that all accesses are in bounds.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@inline-Tuple{Any}","page":"References","title":"Base.@inline","text":"@inline\n\nGive a hint to the compiler that this function is worth inlining.\n\nSmall functions typically do not need the @inline annotation, as the compiler does it automatically. By using @inline on bigger functions, an extra nudge can be given to the compiler to inline it. This is shown in the following example:\n\n@inline function bigfunction(x)\n    #=\n        Function Definition\n    =#\nend\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@invokelatest-Tuple{Any}","page":"References","title":"Base.@invokelatest","text":"@invokelatest f(args...; kwargs...)\n\nProvides a convenient way to call Base.invokelatest. @invokelatest f(args...; kwargs...) will simply be expanded into Base.invokelatest(f, args...; kwargs...).\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@irrational-Tuple{Any, Any, Any}","page":"References","title":"Base.@irrational","text":"@irrational sym val def\n@irrational(sym, val, def)\n\nDefine a new Irrational value, sym, with pre-computed Float64 value val, and arbitrary-precision definition in terms of BigFloats given by the expression def.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@isdefined-Tuple{Symbol}","page":"References","title":"Base.@isdefined","text":"@isdefined s -> Bool\n\nTests whether variable s is defined in the current scope.\n\nSee also isdefined.\n\nExamples\n\njulia> @isdefined newvar\nfalse\n\njulia> newvar = 1\n1\n\njulia> @isdefined newvar\ntrue\n\njulia> function f()\n           println(@isdefined x)\n           x = 3\n           println(@isdefined x)\n       end\nf (generic function with 1 method)\n\njulia> f()\nfalse\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@kwdef-Tuple{Any}","page":"References","title":"Base.@kwdef","text":"@kwdef typedef\n\nThis is a helper macro that automatically defines a keyword-based constructor for the type declared in the expression typedef, which must be a struct or mutable struct expression. The default argument is supplied by declaring fields of the form field::T = default or field = default. If no default is provided then the keyword argument becomes a required keyword argument in the resulting type constructor.\n\nInner constructors can still be defined, but at least one should accept arguments in the same form as the default inner constructor (i.e. one positional argument per field) in order to function correctly with the keyword outer constructor.\n\ncompat: Julia 1.1\nBase.@kwdef for parametric structs, and structs with supertypes requires at least Julia 1.1.\n\nExamples\n\njulia> Base.@kwdef struct Foo\n           a::Int = 1         # specified default\n           b::String          # required keyword\n       end\nFoo\n\njulia> Foo(b=\"hi\")\nFoo(1, \"hi\")\n\njulia> Foo()\nERROR: UndefKeywordError: keyword argument b not assigned\nStacktrace:\n[...]\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@label-Tuple{Symbol}","page":"References","title":"Base.@label","text":"@label name\n\nLabels a statement with the symbolic label name. The label marks the end-point of an unconditional jump with @goto name.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@locals-Tuple{}","page":"References","title":"Base.@locals","text":"@locals()\n\nConstruct a dictionary of the names (as symbols) and values of all local variables defined as of the call site.\n\ncompat: Julia 1.1\nThis macro requires at least Julia 1.1.\n\nExamples\n\njulia> let x = 1, y = 2\n           Base.@locals\n       end\nDict{Symbol, Any} with 2 entries:\n  :y => 2\n  :x => 1\n\njulia> function f(x)\n           local y\n           show(Base.@locals); println()\n           for i = 1:1\n               show(Base.@locals); println()\n           end\n           y = 2\n           show(Base.@locals); println()\n           nothing\n       end;\n\njulia> f(42)\nDict{Symbol, Any}(:x => 42)\nDict{Symbol, Any}(:i => 1, :x => 42)\nDict{Symbol, Any}(:y => 2, :x => 42)\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@macroexpand-Tuple{Any}","page":"References","title":"Base.@macroexpand","text":"@macroexpand\n\nReturn equivalent expression with all macros removed (expanded).\n\nThere are differences between @macroexpand and macroexpand.\n\nWhile macroexpand takes a keyword argument recursive, @macroexpand is always recursive. For a non recursive macro version, see @macroexpand1.\nWhile macroexpand has an explicit module argument, @macroexpand always expands with respect to the module in which it is called.\n\nThis is best seen in the following example:\n\njulia> module M\n           macro m()\n               1\n           end\n           function f()\n               (@macroexpand(@m),\n                macroexpand(M, :(@m)),\n                macroexpand(Main, :(@m))\n               )\n           end\n       end\nM\n\njulia> macro m()\n           2\n       end\n@m (macro with 1 method)\n\njulia> M.f()\n(1, 1, 2)\n\nWith @macroexpand the expression expands where @macroexpand appears in the code (module M in the example). With macroexpand the expression expands in the module given as the first argument.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@macroexpand1-Tuple{Any}","page":"References","title":"Base.@macroexpand1","text":"@macroexpand1\n\nNon recursive version of @macroexpand.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@noinline-Tuple{Any}","page":"References","title":"Base.@noinline","text":"@noinline\n\nGive a hint to the compiler that it should not inline a function.\n\nSmall functions are typically inlined automatically. By using @noinline on small functions, auto-inlining can be prevented. This is shown in the following example:\n\n@noinline function smallfunction(x)\n    #=\n        Function Definition\n    =#\nend\n\nnote: Note\nIf the function is trivial (for example returning a constant) it might get inlined anyway.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@nospecialize-Tuple","page":"References","title":"Base.@nospecialize","text":"@nospecialize\n\nApplied to a function argument name, hints to the compiler that the method should not be specialized for different types of that argument, but instead to use precisely the declared type for each argument. This is only a hint for avoiding excess code generation. Can be applied to an argument within a formal argument list, or in the function body. When applied to an argument, the macro must wrap the entire argument expression. When used in a function body, the macro must occur in statement position and before any code.\n\nWhen used without arguments, it applies to all arguments of the parent scope. In local scope, this means all arguments of the containing function. In global (top-level) scope, this means all methods subsequently defined in the current module.\n\nSpecialization can reset back to the default by using @specialize.\n\nfunction example_function(@nospecialize x)\n    ...\nend\n\nfunction example_function(x, @nospecialize(y = 1))\n    ...\nend\n\nfunction example_function(x, y, z)\n    @nospecialize x y\n    ...\nend\n\n@nospecialize\nf(y) = [x for x in y]\n@specialize\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@polly-Tuple{Any}","page":"References","title":"Base.@polly","text":"@polly\n\nTells the compiler to apply the polyhedral optimizer Polly to a function.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@propagate_inbounds-Tuple{Any}","page":"References","title":"Base.@propagate_inbounds","text":"@propagate_inbounds\n\nTells the compiler to inline a function while retaining the caller's inbounds context.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@pure-Tuple{Any}","page":"References","title":"Base.@pure","text":"@pure ex\n@pure(ex)\n\n@pure gives the compiler a hint for the definition of a pure function, helping for type inference.\n\nA pure function can only depend on immutable information. This also means a @pure function cannot use any global mutable state, including generic functions. Calls to generic functions depend on method tables which are mutable global state. Use with caution, incorrect @pure annotation of a function may introduce hard to identify bugs. Double check for calls to generic functions. This macro is intended for internal compiler use and may be subject to changes.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@r_str-Tuple{Any, Vararg{Any, N} where N}","page":"References","title":"Base.@r_str","text":"@r_str -> Regex\n\nConstruct a regex, such as r\"^[a-z]*$\", without interpolation and unescaping (except for quotation mark \" which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:\n\ni enables case-insensitive matching\nm treats the ^ and $ tokens as matching the start and end of individual lines, as opposed to the whole string.\ns allows the . modifier to match newlines.\nx enables \"comment mode\": whitespace is enabled except when escaped with \\, and # is treated as starting a comment.\na disables UCP mode (enables ASCII mode). By default \\B, \\b, \\D, \\d, \\S, \\s, \\W, \\w, etc. match based on Unicode character properties. With this option, these sequences only match ASCII characters.\n\nSee Regex if interpolation is needed.\n\nExamples\n\njulia> match(r\"a+.*b+.*?d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\nRegexMatch(\"angry,\\nBad world\")\n\nThis regex has the first three flags enabled.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@raw_str-Tuple{Any}","page":"References","title":"Base.@raw_str","text":"@raw_str -> String\n\nCreate a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.\n\nExamples\n\njulia> println(raw\"\\ $x\")\n\\ $x\n\njulia> println(raw\"\\\"\")\n\"\n\njulia> println(raw\"\\\\\\\"\")\n\\\"\n\njulia> println(raw\"\\\\x \\\\\\\"\")\n\\\\x \\\"\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@s_str-Tuple{Any}","page":"References","title":"Base.@s_str","text":"@s_str -> SubstitutionString\n\nConstruct a substitution string, used for regular expression substitutions.  Within the string, sequences of the form \\N refer to the Nth capture group in the regex, and \\g<groupname> refers to a named capture group with name groupname.\n\njulia> msg = \"#Hello# from Julia\";\n\njulia> replace(msg, r\"#(.+)# from (?<from>\\w+)\" => s\"FROM: \\g<from>; MESSAGE: \\1\")\n\"FROM: Julia; MESSAGE: Hello\"\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@show-Tuple","page":"References","title":"Base.@show","text":"@show\n\nShow an expression and result, returning the result. See also show.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@specialize-Tuple","page":"References","title":"Base.@specialize","text":"@specialize\n\nReset the specialization hint for an argument back to the default. For details, see @nospecialize.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@static-Tuple{Any}","page":"References","title":"Base.@static","text":"@static\n\nPartially evaluate an expression at parse time.\n\nFor example, @static Sys.iswindows() ? foo : bar will evaluate Sys.iswindows() and insert either foo or bar into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a ccall to a non-existent function. @static if Sys.isapple() foo end and @static foo <&&,||> bar are also valid syntax.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@sync-Tuple{Any}","page":"References","title":"Base.@sync","text":"@sync\n\nWait until all lexically-enclosed uses of @async, @spawn, @spawnat and @distributed are complete. All exceptions thrown by enclosed async operations are collected and thrown as a CompositeException.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@task-Tuple{Any}","page":"References","title":"Base.@task","text":"@task\n\nWrap an expression in a Task without executing it, and return the Task. This only creates a task, and does not run it.\n\nExamples\n\njulia> a1() = sum(i for i in 1:1000);\n\njulia> b = @task a1();\n\njulia> istaskstarted(b)\nfalse\n\njulia> schedule(b);\n\njulia> yield();\n\njulia> istaskdone(b)\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@threadcall-Tuple{Any, Any, Any, Vararg{Any, N} where N}","page":"References","title":"Base.@threadcall","text":"@threadcall((cfunc, clib), rettype, (argtypes...), argvals...)\n\nThe @threadcall macro is called in the same way as ccall but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main julia thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the UV_THREADPOOL_SIZE environment variable and restarting the julia process.\n\nNote that the called function should never call back into Julia.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@time-Tuple{Any}","page":"References","title":"Base.@time","text":"@time\n\nA macro to execute an expression, printing the time it took to execute, the number of allocations, and the total number of bytes its execution caused to be allocated, before returning the value of the expression. Any time spent garbage collecting (gc) or compiling is shown as a percentage.\n\nIn some cases the system will look inside the @time expression and compile some of the called code before execution of the top-level expression begins. When that happens, some compilation time will not be counted. To include this time you can run @time @eval ....\n\nSee also @timev, @timed, @elapsed, and @allocated.\n\nnote: Note\nFor more serious benchmarking, consider the @btime macro from the BenchmarkTools.jl package which among other things evaluates the function multiple times in order to reduce noise.\n\njulia> x = rand(10,10);\n\njulia> @time x * x;\n  0.606588 seconds (2.19 M allocations: 116.555 MiB, 3.75% gc time, 99.94% compilation time)\n\njulia> @time x * x;\n  0.000009 seconds (1 allocation: 896 bytes)\n\njulia> @time begin\n           sleep(0.3)\n           1+1\n       end\n  0.301395 seconds (8 allocations: 336 bytes)\n2\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@timed-Tuple{Any}","page":"References","title":"Base.@timed","text":"@timed\n\nA macro to execute an expression, and return the value of the expression, elapsed time, total bytes allocated, garbage collection time, and an object with various memory allocation counters.\n\nIn some cases the system will look inside the @timed expression and compile some of the called code before execution of the top-level expression begins. When that happens, some compilation time will not be counted. To include this time you can run @timed @eval ....\n\nSee also @time, @timev, @elapsed, and @allocated.\n\njulia> stats = @timed rand(10^6);\n\njulia> stats.time\n0.006634834\n\njulia> stats.bytes\n8000256\n\njulia> stats.gctime\n0.0055765\n\njulia> propertynames(stats.gcstats)\n(:allocd, :malloc, :realloc, :poolalloc, :bigalloc, :freecall, :total_time, :pause, :full_sweep)\n\njulia> stats.gcstats.total_time\n5576500\n\ncompat: Julia 1.5\nThe return type of this macro was changed from Tuple to NamedTuple in Julia 1.5.\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@timev-Tuple{Any}","page":"References","title":"Base.@timev","text":"@timev\n\nThis is a verbose version of the @time macro. It first prints the same information as @time, then any non-zero memory allocation counters, and then returns the value of the expression.\n\nSee also @time, @timed, @elapsed, and @allocated.\n\njulia> x = rand(10,10);\n\njulia> @timev x * x;\n  0.546770 seconds (2.20 M allocations: 116.632 MiB, 4.23% gc time, 99.94% compilation time)\nelapsed time (ns): 546769547\ngc time (ns):      23115606\nbytes allocated:   122297811\npool allocs:       2197930\nnon-pool GC allocs:1327\nmalloc() calls:    36\nrealloc() calls:   5\nGC pauses:         3\n\njulia> @timev x * x;\n  0.000010 seconds (1 allocation: 896 bytes)\nelapsed time (ns): 9848\nbytes allocated:   896\npool allocs:       1\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@v_str-Tuple{Any}","page":"References","title":"Base.@v_str","text":"@v_str\n\nString macro used to parse a string to a VersionNumber.\n\nExamples\n\njulia> v\"1.2.3\"\nv\"1.2.3\"\n\njulia> v\"2.0.1-rc1\"\nv\"2.0.1-rc1\"\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@view-Tuple{Any}","page":"References","title":"Base.@view","text":"@view A[inds...]\n\nCreates a SubArray from an indexing expression. This can only be applied directly to a reference expression (e.g. @view A[1,2:end]), and should not be used as the target of an assignment (e.g. @view(A[1,2:end]) = ...).  See also @views to switch an entire block of code to use views for slicing.\n\ncompat: Julia 1.5\nUsing begin in an indexing expression to refer to the first index requires at least Julia 1.5.\n\nExamples\n\njulia> A = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> b = @view A[:, 1]\n2-element view(::Matrix{Int64}, :, 1) with eltype Int64:\n 1\n 3\n\njulia> fill!(b, 0)\n2-element view(::Matrix{Int64}, :, 1) with eltype Int64:\n 0\n 0\n\njulia> A\n2×2 Matrix{Int64}:\n 0  2\n 0  4\n\n\n\n\n\n","category":"macro"},{"location":"references/#Base.@views-Tuple{Any}","page":"References","title":"Base.@views","text":"@views expression\n\nConvert every array-slicing operation in the given expression (which may be a begin/end block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit getindex calls (as opposed to array[...]) are unaffected.\n\nnote: Note\nThe @views macro only affects array[...] expressions that appear explicitly in the given expression, not array slicing that occurs in functions called by that code.\n\ncompat: Julia 1.5\nUsing begin in an indexing expression to refer to the first index requires at least Julia 1.5.\n\nExamples\n\njulia> A = zeros(3, 3);\n\njulia> @views for row in 1:3\n           b = A[row, :]\n           b[:] .= row\n       end\n\njulia> A\n3×3 Matrix{Float64}:\n 1.0  1.0  1.0\n 2.0  2.0  2.0\n 3.0  3.0  3.0\n\n\n\n\n\n","category":"macro"},{"location":"references/#Core.@big_str-Tuple{Any}","page":"References","title":"Core.@big_str","text":"@big_str str\n@big_str(str)\n\nParse a string into a BigInt or BigFloat, and throw an ArgumentError if the string is not a valid number. For integers _ is allowed in the string as a separator.\n\nExamples\n\njulia> big\"123_456\"\n123456\n\njulia> big\"7891.5\"\n7891.5\n\n\n\n\n\n","category":"macro"},{"location":"references/#Core.@cmd-Tuple{Any}","page":"References","title":"Core.@cmd","text":"@cmd str\n\nSimilar to cmd, generate a Cmd from the str string which represents the shell command(s) to be executed. The Cmd object can be run as a process and can outlive the spawning julia process (see Cmd for more).\n\nExamples\n\njulia> cm = @cmd \" echo 1 \"\n`echo 1`\n\njulia> run(cm)\n1\nProcess(`echo 1`, ProcessExited(0))\n\n\n\n\n\n","category":"macro"},{"location":"references/#Core.@int128_str-Tuple{Any}","page":"References","title":"Core.@int128_str","text":"@int128_str str\n@int128_str(str)\n\n@int128_str parses a string into a Int128 Throws an ArgumentError if the string is not a valid integer\n\n\n\n\n\n","category":"macro"},{"location":"references/#Core.@uint128_str-Tuple{Any}","page":"References","title":"Core.@uint128_str","text":"@uint128_str str\n@uint128_str(str)\n\n@uint128_str parses a string into a UInt128 Throws an ArgumentError if the string is not a valid integer\n\n\n\n\n\n","category":"macro"},{"location":"interfaces/#Resizing-Interfaces","page":"Resizing Interfaces","title":"Resizing Interfaces","text":"","category":"section"},{"location":"interfaces/#Resizable-Dense-Array","page":"Resizing Interfaces","title":"Resizable Dense Array","text":"","category":"section"},{"location":"interfaces/","page":"Resizing Interfaces","title":"Resizing Interfaces","text":"AbstractRDArray is a subtype of DenseArray with some predefined methods. So if an array type RDArray is a subtype of DenseArray,  a convenient way is to make it a subtype of AbstractRDArray, the defined methods below:","category":"page"},{"location":"interfaces/","page":"Resizing Interfaces","title":"Resizing Interfaces","text":"Required methods Brief description\nBase.parent(A::RDArray) Returns a dense array containing the data, which must be resizable.\nArrayInterface.parent_type(::Type{<:RDArray}) Returns the type of its parent\nResizingTools.getsize(A::RDArray{T,N}) where {T,N} Returns the dimensions of A\nResizingTools.setsize!(A::RDArray{T,N}, dims::Dims{N}) where {T,N} Mutates the dimensions of A into dims","category":"page"},{"location":"interfaces/","page":"Resizing Interfaces","title":"Resizing Interfaces","text":"Optional methods Default definition Brief description\nResizingTools.getsize(A::RDArray, i::Int) getsize(A)[i] Returns the ith dimension of A\nResizingTools.setsize!(A::RDArray, d::Int, i::Int) setsize!(A, setindex(getsize(A), d, i)) Mutates ith dimension of A into dim\nResizingTools.mapindex(A::RDArray, I::Tuple) I Map the index(s) I of A to index(s) of parent(A)\nResizingTools.mapindex(A::RDArray, i, I) I Map the i-dim index(s) I of A to index(s) of parent(A)","category":"page"},{"location":"interfaces/","page":"Resizing Interfaces","title":"Resizing Interfaces","text":"Note: To resize! an array, parent_type of the array must be resizable such as Vector or SimpleRDArray.","category":"page"},{"location":"interfaces/#Normal-Case","page":"Resizing Interfaces","title":"Normal Case","text":"","category":"section"},{"location":"interfaces/","page":"Resizing Interfaces","title":"Resizing Interfaces","text":"If your array type is not a dense array, or you don't want to make it a subtype of AbstractRDArray. You must define more methods in Julia array interfaces.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ResizingTools provide some tools to help you resize multi-dimensional arrays with a set of interface methods. Besides, there is a simple implementation of resizable dense array type named SimpleRDArray as a resizable alternative of Array.","category":"page"},{"location":"#Get-started-with-SimpleRDArray","page":"Introduction","title":"Get started with SimpleRDArray","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SimpleRDArray is a simple implementation of the resizable dense array, which can be created simply:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"M = reshape(1:9, 3, 3)\nRM = SimpleRDArray(M)\nM == RM","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once a SimpleRDArray is created, you can almost do anything with which likes a normal Array with similar performance:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@benchmark $RM * $RM\n@benchmark $M * $M\nRM * RM == M * M","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Besides, a SimpleRDArray can be resized in many ways:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"resize!(RM, (4, 4)) # resize RM to 4 * 4\nRM[1:3,1:3] == M\nresize!(RM, 3, 2) # resize the 2nd dimension of RM to 3\nRM[4, :] .= 0\nresize!(RM, Bool[1, 1, 0, 1], 1) # delete RM[3, :]","category":"page"}]
}
